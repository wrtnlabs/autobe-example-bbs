import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IBan } from "../../../structures/IBan";
import { IPageIBan } from "../../../structures/IPageIBan";

/**
 * Permanently ban a user by creating a ban record (bans table).
 *
 * The POST operation creates a new ban record based on input from the
 * moderation team. The input payload includes banned user, moderator,
 * rationale, and timestamp. Validation ensures that only eligible users
 * (moderator/admin) can ban, and that a user cannot have multiple active bans.
 * The conditions necessitating a ban (severe/spam/harassment etc.) are checked
 * or noted in the reason string. The creation is logged for auditing. This
 * endpoint is related to PATCH (search/list), GET, PUT (update), and DELETE for
 * individual bans.
 *
 * @param props.body Details necessary to create a new ban, including target
 *   user, moderator, reason, and timestamps.
 * @path /moderation/bans
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Details necessary to create a new ban, including target user,
     * moderator, reason, and timestamps.
     */
    body: IBan.ICreate;
  };
  export type Body = IBan.ICreate;
  export type Response = IBan;

  export const METADATA = {
    method: "POST",
    path: "/moderation/bans",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/moderation/bans";
  export const random = (g?: Partial<typia.IRandomGenerator>): IBan =>
    typia.random<IBan>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Search or page through user ban records (bans table).
 *
 * The endpoint allows moderation staff to search, browse, and review all
 * permanent ban records via complex filters in the request body. Paginated
 * results include user data, ban reasons, moderator information, and
 * timestamps. Only privileged roles may query this endpoint, to protect
 * personal and sensitive data. Supports sorting by date issued, retrieval by
 * search strings (e.g., by username or email), and filtering by time interval,
 * moderator, or ban reason. This operation is typically accompanied by other
 * GET/PUT/DELETE endpoints for detailed view or management of individual ban
 * events. Errors return valid status codes and descriptive messages.
 *
 * @param props.body Filtering parameters for searching and paging through bans.
 * @path /moderation/bans
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Filtering parameters for searching and paging through bans. */
    body: IBan.IRequest;
  };
  export type Body = IBan.IRequest;
  export type Response = IPageIBan;

  export const METADATA = {
    method: "PATCH",
    path: "/moderation/bans",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/moderation/bans";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIBan =>
    typia.random<IPageIBan>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get details about a specific user ban (bans table).
 *
 * The GET operation fetches the ban event by unique ID. Access restricted to
 * moderation roles; regular users cannot retrieve ban history. The operation
 * validates input (UUID), checks for existence, and returns 404 if not found.
 * Returns a comprehensive record including user/target, moderator/issuer,
 * rationale, and ban date. If applicable, provides links or references to
 * moderation logs. Related to PATCH (list/search), POST (creation), PUT
 * (update), and DELETE endpoints for the bans resource.
 *
 * @param props.id The unique identifier for a permanent ban event to retrieve.
 * @path /moderation/bans/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** The unique identifier for a permanent ban event to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IBan;

  export const METADATA = {
    method: "GET",
    path: "/moderation/bans/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/moderation/bans/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IBan =>
    typia.random<IBan>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update information about an existing user ban (bans table).
 *
 * This PUT operation enables privileged staff to modify a ban record. Editable
 * fields typically include reason, annotated notes, or correcting moderator
 * assignment. Changes are subject to strict audit and are logged. Only
 * authorized users may execute the operation. Requests for non-existent bans or
 * attempts to un-ban via this endpoint are rejected. This endpoint supports
 * procedural justice and transparency by allowing updates based on user appeals
 * or evidence.
 *
 * @param props.id The unique identifier for the ban to update.
 * @param props.body Update fields for the ban event, such as reason or
 *   moderator.
 * @path /moderation/bans/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** The unique identifier for the ban to update. */
    id: string & tags.Format<"uuid">;

    /** Update fields for the ban event, such as reason or moderator. */
    body: IBan.IUpdate;
  };
  export type Body = IBan.IUpdate;
  export type Response = IBan;

  export const METADATA = {
    method: "PUT",
    path: "/moderation/bans/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/moderation/bans/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IBan =>
    typia.random<IBan>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Remove a (soft-delete) permanent ban by ID (bans table).
 *
 * The DELETE operation flags a ban record as no longer active, rather than
 * deleting for audit/legal purposes. This maintains transparency for appeals,
 * reporting, or compliance. The endpoint validates the provided ban ID and
 * ensures only authorized roles can remove bans. Attempts to delete
 * non-existent bans return 404. Related moderation logs may be updated for
 * reference. Only admins or authorized moderators can use this action. This
 * endpoint complements creation (POST), update (PUT), retrieval (GET), and
 * search (PATCH) endpoints for bans.
 *
 * @param props.id The unique ban record to remove/unban.
 * @path /moderation/bans/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** The unique ban record to remove/unban. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IBan;

  export const METADATA = {
    method: "DELETE",
    path: "/moderation/bans/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/moderation/bans/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IBan =>
    typia.random<IBan>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
