import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IModerationLog } from "../../../structures/IModerationLog";
import { IPageIModerationLog } from "../../../structures/IPageIModerationLog";

/**
 * Create a new moderation log record for an action/event (moderation_logs
 * table).
 *
 * This POST endpoint creates a new moderation log entry, reflecting a
 * moderation action performed by a moderator/admin. The request body must
 * contain all required details per the moderation_logs schema: moderator_id,
 * action_type, reason, and any related user, post, or comment data. Validation
 * checks ensure the requester has moderator/admin privileges, and data is
 * correctly formed.
 *
 * Upon success, a new moderation_logs record is created and timestamped. The
 * action is available for auditing, dispute resolution, and transparency.
 * Business rules dictate required action_type values and field consistency.
 * Error handling covers field validation, permission checks, and integrity
 * errors. The response gives back the newly written moderation log entry for
 * further reference or review.
 *
 * @param props.body Moderation log event details: moderator_id, action_type,
 *   reason, related entities.
 * @path /moderation/moderationLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Moderation log event details: moderator_id, action_type, reason,
     * related entities.
     */
    body: IModerationLog.ICreate;
  };
  export type Body = IModerationLog.ICreate;
  export type Response = IModerationLog;

  export const METADATA = {
    method: "POST",
    path: "/moderation/moderationLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/moderation/moderationLogs";
  export const random = (g?: Partial<typia.IRandomGenerator>): IModerationLog =>
    typia.random<IModerationLog>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve multiple moderation logs with search/filter/pagination
 * (moderation_logs table).
 *
 * This endpoint enables retrieval of the moderation logs list with advanced
 * querying: filters (such as action_type, moderator_id, target_user_id,
 * post_id, comment_id, date ranges), pagination (offset/limit), and sorting (by
 * created_at or type). Only moderators and admins are authorized for
 * comprehensive access; regular users may access only their own moderation
 * history if business rules allow. The response contains page info and an array
 * of moderation_log records.
 *
 * Security checks enforce authentication and role authorization. Utilizes
 * efficient querying for large log volumes. The endpoint helps with audit,
 * transparency, and resolving disputes regarding moderation actions. Related to
 * GET for single log and POST for new moderation actions.
 *
 * @param props.body Query/filter parameters for searching moderation logs
 *   (e.g., action_type, moderator_id, pagination settings).
 * @path /moderation/moderationLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Query/filter parameters for searching moderation logs (e.g.,
     * action_type, moderator_id, pagination settings).
     */
    body: IModerationLog.IRequest;
  };
  export type Body = IModerationLog.IRequest;
  export type Response = IPageIModerationLog;

  export const METADATA = {
    method: "PATCH",
    path: "/moderation/moderationLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/moderation/moderationLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIModerationLog => typia.random<IPageIModerationLog>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get full details for a specific moderation log by ID (moderation_logs table).
 *
 * This endpoint fetches in detail a single moderation log from the
 * moderation_logs table, identified by its ID. The log contains all information
 * about a moderation action: moderator, target user (if any), affected
 * post/comment (if any), action_type, reason, and timestamp. Access may be
 * restricted by user role: moderators/admins have broader access, while regular
 * users can only view logs relating to themselves (and only as permitted by
 * business rules).
 *
 * Proper authorization, audit trail, and error handling are enforced. The API
 * ensures that only valid, authorized requests are served, with not found or
 * forbidden errors as needed. Related endpoint: PATCH logs for list, POST for
 * new log creation.
 *
 * @param props.id Moderation log record's unique ID.
 * @path /moderation/moderationLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Moderation log record's unique ID. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IModerationLog;

  export const METADATA = {
    method: "GET",
    path: "/moderation/moderationLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/moderation/moderationLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IModerationLog =>
    typia.random<IModerationLog>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing moderation log record by its ID (moderation_logs table).
 *
 * This endpoint allows a moderator or admin to update mutable fields (such as
 * reason or certain non-critical metadata) of a moderation_logs record,
 * identified by its unique ID. Strict business rules ensure some fields (like
 * created_at, moderator_id, action_type) are immutable, unless fixing
 * administrative errors by superuser. Authorization checks enforce that only
 * the owner moderator or designated admin may edit, and audit logs are
 * maintained for any update operations.
 *
 * The request body specifies permitted updated values. The update is written to
 * the moderation_logs table, and the detailed result is returned. Errors
 * returned if log is not found, update forbidden, or invalid data is supplied.
 * All updates are tracked for audit.
 *
 * @param props.id Moderation log record's unique ID.
 * @param props.body Permitted updates to the moderation log (typically reason
 *   or metadata).
 * @path /moderation/moderationLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Moderation log record's unique ID. */
    id: string & tags.Format<"uuid">;

    /**
     * Permitted updates to the moderation log (typically reason or
     * metadata).
     */
    body: IModerationLog.IUpdate;
  };
  export type Body = IModerationLog.IUpdate;
  export type Response = IModerationLog;

  export const METADATA = {
    method: "PUT",
    path: "/moderation/moderationLogs/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/moderation/moderationLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IModerationLog =>
    typia.random<IModerationLog>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a moderation log record by its ID (moderation_logs table).
 *
 * This endpoint enables deletion of a moderation log entry by its ID from the
 * moderation_logs table. Only highly privileged users (admins or designated
 * superusers) may invoke this operation. The system enforces business rules:
 * records must not be deleted if needed for open investigations/audit, and
 * every deletion is logged for transparency. The deletion is physical or soft
 * (depending on policy/audit requirements), removing the log from standard
 * queries. Related endpoints include log retrieval, listing, or creation.
 *
 * Errors returned for unauthorized actions, attempting to remove protected or
 * in-use logs, or non-existent IDs. The return value confirms deletion or
 * provides error explanation.
 *
 * @param props.id Moderation log record's unique ID.
 * @path /moderation/moderationLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Moderation log record's unique ID. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IModerationLog.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/moderation/moderationLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/moderation/moderationLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IModerationLog.IDeleteResult =>
    typia.random<IModerationLog.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
