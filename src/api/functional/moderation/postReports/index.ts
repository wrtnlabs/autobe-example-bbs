import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPostReport } from "../../../structures/IPostReport";
import { IPageIPostReport } from "../../../structures/IPageIPostReport";

/**
 * Create a new post report (flag/report a post for moderation, post_reports
 * table).
 *
 * This POST endpoint allows any registered user to report a post—flagging it
 * for moderation action. The request body must provide the reporting user's ID,
 * targeted post's ID, the report reason (e.g., spam, harassment, off-topic),
 * and other metadata required by the post_reports schema. The system verifies
 * existence and eligibility (the reporter is not already restricted/banned, and
 * the post exists/eligible).
 *
 * A new post_reports row is created, status set to 'pending', and timestamped.
 * The report becomes available to moderators/admins for workflow triage.
 * Subsequent endpoints handle inspection (GET), bulk listing (PATCH),
 * escalation, or resolution (PUT). Error handling covers invalid data,
 * unauthorized reporters, or duplicate report rules.
 *
 * @param props.body New post report details: reporter_id, post_id, reason, etc.
 * @path /moderation/postReports
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** New post report details: reporter_id, post_id, reason, etc. */
    body: IPostReport.ICreate;
  };
  export type Body = IPostReport.ICreate;
  export type Response = IPostReport;

  export const METADATA = {
    method: "POST",
    path: "/moderation/postReports",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/moderation/postReports";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPostReport =>
    typia.random<IPostReport>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Query/list post reports with filters and pagination (post_reports table).
 *
 * This PATCH endpoint searches the post_reports table for matching report
 * records, supporting pagination (offset/limit), sorting (by created_at or
 * status), and filtering (by fields such as status, reporter_id, post_id,
 * reason, date ranges). Only moderators/admins or authorized support users may
 * perform arbitrary queries; regular users may only access their own reports
 * where business rules allow. The response is a page of report entries with
 * details for UI and moderation processing.
 *
 * Request body specifies filter options and page/sort preferences. All queries
 * are subject to business and security restrictions. Results are only records
 * matching filters, and support audit/review of moderation workflows. Related
 * endpoints include POST to create reports, GET for single report detail, PUT
 * to update, DELETE (if allowed) for removal.
 *
 * @param props.body Post report search/filter/pagination criteria as supported
 *   by business rules and DB schema.
 * @path /moderation/postReports
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Post report search/filter/pagination criteria as supported by
     * business rules and DB schema.
     */
    body: IPostReport.IRequest;
  };
  export type Body = IPostReport.IRequest;
  export type Response = IPageIPostReport;

  export const METADATA = {
    method: "PATCH",
    path: "/moderation/postReports",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/moderation/postReports";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIPostReport => typia.random<IPageIPostReport>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get full details for a specific post report (post_reports table).
 *
 * This endpoint fetches full details of an individual post report, identified
 * by its unique ID, from the post_reports table. All fields—including reporter,
 * post, reason, status, timestamps—are returned. Access is strictly managed for
 * sensitive moderation records: regular users may only view their own reports,
 * whereas moderators and admins may review all for moderation workflow.
 *
 * Business and security rules enforce appropriate access, error responses are
 * returned for not found, forbidden, or unauthorized access attempts. Related
 * endpoints handle report creation (POST), listing (PATCH for table), and
 * updating (PUT).
 *
 * @param props.id Post report record's unique ID.
 * @path /moderation/postReports/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Post report record's unique ID. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IPostReport;

  export const METADATA = {
    method: "GET",
    path: "/moderation/postReports/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/moderation/postReports/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IPostReport =>
    typia.random<IPostReport>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing post report by its ID (post_reports table).
 *
 * This endpoint permits authorized users (typically moderators/admins) to
 * update certain fields of a post_reports record (such as moderation status,
 * resolved_at, or reason text) identified by its ID. Fields controlling the
 * reporter or original post are not mutable post-creation. Security/enforcement
 * checks ensure only designated roles may perform updating actions, with all
 * modifications tracked for audit.
 *
 * Request body provides legal updates as per business logic and DB schema. On
 * success, the report entry is updated and returned with the latest info.
 * Errors are emitted for invalid updates, unauthorized users, or attempts to
 * edit immutable fields.
 *
 * @param props.id Post report record's unique ID.
 * @param props.body Permitted updatable fields for post report (e.g., status,
 *   reason, resolved_at).
 * @path /moderation/postReports/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Post report record's unique ID. */
    id: string & tags.Format<"uuid">;

    /**
     * Permitted updatable fields for post report (e.g., status, reason,
     * resolved_at).
     */
    body: IPostReport.IUpdate;
  };
  export type Body = IPostReport.IUpdate;
  export type Response = IPostReport;

  export const METADATA = {
    method: "PUT",
    path: "/moderation/postReports/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/moderation/postReports/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IPostReport =>
    typia.random<IPostReport>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Deletes a post report by ID from the post_reports Prisma table.
 *
 * This operation allows a moderator or admin to delete a post report identified
 * by its ID from the post_reports table. The deleted post report will no longer
 * be available for moderation review or display, supporting streamlined
 * workflows in content moderation.
 *
 * Access is restricted to users with appropriate permissions (moderator or
 * admin roles), as defined in the roles and role_assignments tables. This
 * endpoint is generally invoked after a report has been addressed and is deemed
 * no longer necessary to retain. It is important for compliance and audit to
 * ensure only authorized users can perform this operation, and all actions
 * should be logged in moderation_logs for transparency.
 *
 * Preceding or related API operations may include reviewing the report details
 * and updating its status via a PUT endpoint. Error cases include non-existent
 * ID, insufficient permissions, or attempting to delete a report that is still
 * under review.
 *
 * @param props.id Target post report's unique ID to delete (UUID).
 * @path /moderation/postReports/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target post report's unique ID to delete (UUID). */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/moderation/postReports/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/moderation/postReports/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
