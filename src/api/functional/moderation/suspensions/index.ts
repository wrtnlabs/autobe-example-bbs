import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ISuspension } from "../../../structures/ISuspension";
import { IPageISuspension } from "../../../structures/IPageISuspension";

/**
 * Create a new user suspension (suspensions table).
 *
 * This POST operation creates a new suspension event for a specified user. The
 * request body must include all required atomic and referenced values: target
 * user's user_id, assigning moderator_id, the reason for discipline, and
 * precise starting and ending timestamps. Upon creation, the operation logs the
 * event (for audit, transparency, and legal compliance). Validation ensures
 * that the suspended user's ID exists and that the start/end times are valid
 * (start precedes end and is not in the past). Only verified moderators or
 * admins may invoke this endpoint—registered users are not authorized. The
 * response returns the new suspension record as confirmation, supporting
 * subsequent retrieval, editing, or reporting. Edge behavior: Overlapping
 * suspensions for same user are discouraged or flagged for review.
 *
 * @param props.body Information required to create a new suspension record.
 * @path /moderation/suspensions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Information required to create a new suspension record. */
    body: ISuspension.ICreate;
  };
  export type Body = ISuspension.ICreate;
  export type Response = ISuspension;

  export const METADATA = {
    method: "POST",
    path: "/moderation/suspensions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/moderation/suspensions";
  export const random = (g?: Partial<typia.IRandomGenerator>): ISuspension =>
    typia.random<ISuspension>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List and filter user suspensions from the suspensions table for moderation.
 *
 * Enables moderators/admins to obtain a paginated, filterable list of
 * suspensions, searching by user, moderator, reason, period, and status.
 * Critical for enforcing temporary bans, current status visibility, and review
 * of repeated or severe infractions, as referenced in business rules. RBAC
 * restricts access to privileged roles, with large result sets paged for load
 * management.
 *
 * In support of workflow, results may be filtered by time window (active,
 * expired), target user, or reason. Typical dashboard and analytics access for
 * ongoing moderation activity. Related endpoints: POST for creating new
 * suspensions, PUT for modifying, GET by ID for detail, and DELETE for removal.
 * Errors: permission issues, invalid search filters.
 *
 * @param props.body Search, filter, and pagination for retrieving suspensions
 *   as moderation events.
 * @path /moderation/suspensions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Search, filter, and pagination for retrieving suspensions as
     * moderation events.
     */
    body: ISuspension.IRequest;
  };
  export type Body = ISuspension.IRequest;
  export type Response = IPageISuspension.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/moderation/suspensions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/moderation/suspensions";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageISuspension.ISummary => typia.random<IPageISuspension.ISummary>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get details about a specific user suspension (suspensions table).
 *
 * This GET operation fetches all available details for a suspension event from
 * the 'suspensions' table. The operation is intended for use by moderation
 * staff who must review the suspension's duration, reason, involved users,
 * assigned moderator, and timestamps. Security is paramount—only privileged
 * users can access this endpoint, per moderation, audit, and privacy
 * requirements in the business rules. The parameter 'id' is validated as a UUID
 * and checked for existence. If the ID does not exist, a 404 error is returned.
 * Soft-deleted suspensions are ignored. The response contains all atomic and
 * referenced data except potentially sensitive moderator notes, depending on
 * role. This endpoint is related to POST/PUT/DELETE operations for creation,
 * modification, or removal of suspensions by the moderation team.
 *
 * @param props.id The unique identifier of the suspension event to retrieve.
 * @path /moderation/suspensions/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** The unique identifier of the suspension event to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ISuspension;

  export const METADATA = {
    method: "GET",
    path: "/moderation/suspensions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/moderation/suspensions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ISuspension =>
    typia.random<ISuspension>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing suspension record (suspensions table).
 *
 * This PUT operation enables moderation staff to update the details of an
 * existing suspension. Input validation ensures the payload contains a valid
 * suspension ID with permissible fields (adjusting time range, reason, or
 * moderator only). The operation verifies that the requesting user is permitted
 * to adjust suspensions and audits the action. Linked business rules ensure
 * expired suspensions cannot be edited except when changing reason or for audit
 * annotation. The endpoint rejects updates to non-existent IDs (returns 404)
 * and enforces that end time must follow start time. On success, the full
 * updated suspension record is returned. This operation supports moderation
 * audit trails and compliance.
 *
 * @param props.id The unique identifier of the suspension record to update.
 * @param props.body Fields and data to update a suspension event.
 * @path /moderation/suspensions/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** The unique identifier of the suspension record to update. */
    id: string & tags.Format<"uuid">;

    /** Fields and data to update a suspension event. */
    body: ISuspension.IUpdate;
  };
  export type Body = ISuspension.IUpdate;
  export type Response = ISuspension;

  export const METADATA = {
    method: "PUT",
    path: "/moderation/suspensions/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/moderation/suspensions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ISuspension =>
    typia.random<ISuspension>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete (soft-remove) a suspension event (suspensions table).
 *
 * The DELETE operation sets the 'deleted' or removal status for a suspension
 * record by its unique primary key ID. Only moderators and admins are
 * authorized to use this endpoint. Integrity checks ensure the suspension
 * exists and is not already expired (or already deleted). Deletions are soft
 * (for audit/legal purposes); the record remains for compliance. The operation
 * is logged in the moderation audit trail. Requests for non-existent or already
 * deleted suspensions return a 404 error. Related moderation logs or user
 * access checks may reference the 'deleted' status.
 *
 * @param props.id The unique ID of the suspension record to delete.
 * @path /moderation/suspensions/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** The unique ID of the suspension record to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ISuspension;

  export const METADATA = {
    method: "DELETE",
    path: "/moderation/suspensions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/moderation/suspensions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ISuspension =>
    typia.random<ISuspension>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
