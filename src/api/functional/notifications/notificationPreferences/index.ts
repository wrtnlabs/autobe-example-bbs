import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { INotificationPreference } from "../../../structures/INotificationPreference";
import { IPageINotificationPreference } from "../../../structures/IPageINotificationPreference";

/**
 * Create a notification preference record in 'notification_preferences'.
 *
 * This operation creates a new notification preference identified by user ID
 * and notification type, enabling the user to set up their own custom delivery
 * toggles (e.g., enable/disable upvote notifications, reply alerts). Data is
 * stored in the normalized 'notification_preferences' table per Prisma schema.
 *
 * All new records are schema-validated (e.g., allowed notification types,
 * boolean enabled status) and checked for duplicates (unique per (user, type)).
 * Security rules restrict users so they can create preferences only for
 * themselves unless an admin overrides. Errors include duplicate preference
 * (already exists for this type), invalid data, or permissions failures. This
 * endpoint is often used during onboarding or when adding new notification
 * features/capabilities to the app.
 *
 * The endpoint pairs with patch (list/search), get (fetch), put (update), and
 * delete (remove) for CRUD coverage of notification settings.
 *
 * @param props.body Data to create the notification preference (user, type,
 *   enabled).
 * @path /notifications/notificationPreferences
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Data to create the notification preference (user, type, enabled). */
    body: INotificationPreference.ICreate;
  };
  export type Body = INotificationPreference.ICreate;
  export type Response = INotificationPreference;

  export const METADATA = {
    method: "POST",
    path: "/notifications/notificationPreferences",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/notifications/notificationPreferences";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): INotificationPreference => typia.random<INotificationPreference>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Search and page notification preferences from the 'notification_preferences'
 * table.
 *
 * This operation retrieves a paginated, filterable list of notification
 * preference records matching given search criteria. The underlying
 * 'notification_preferences' table enables users to customize notification
 * types/delivery. Typical filters include notification type, enabled/disabled
 * status, or user associations.
 *
 * Supports UI listing, preference reviews, and potential administrative
 * oversight. It honors user privacy by only showing preferences to the current
 * authenticated user (or, in the case of admins, for all users). Pagination
 * controls, sorting (by type or date), and flexible searching are supported.
 * Error scenarios include invalid search criteria, exceeding pagination limits,
 * or permission errors for non-owners/admins.
 *
 * This endpoint is intended to be paired with GET (details), POST (create), PUT
 * (update), and DELETE (remove) operations on individual preference records.
 *
 * @param props.body Search/filter criteria, pagination, and sorting options.
 * @path /notifications/notificationPreferences
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search/filter criteria, pagination, and sorting options. */
    body: INotificationPreference.IRequest;
  };
  export type Body = INotificationPreference.IRequest;
  export type Response = IPageINotificationPreference;

  export const METADATA = {
    method: "PATCH",
    path: "/notifications/notificationPreferences",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/notifications/notificationPreferences";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageINotificationPreference =>
    typia.random<IPageINotificationPreference>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a notification preference by ID from the 'notification_preferences'
 * table.
 *
 * Returns complete details for a single notification preference, such as type
 * (e.g., post_reply, upvote), enabled status, and which user it belongs to. The
 * data is read from the 'notification_preferences' Prisma table, referenced by
 * the unique primary key.
 *
 * The operation enforces security by verifying that only the preference owner
 * (or an admin) can view the preference. Business logic dictates that users may
 * only access/update their own preferences unless elevated privileges apply.
 * Error scenarios include not found (invalid id) and forbidden (insufficient
 * rights). This operation complements list, create, update, and delete
 * endpoints for full preference management.
 *
 * @param props.id Unique identifier for the notification preference setting.
 * @path /notifications/notificationPreferences/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier for the notification preference setting. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = INotificationPreference;

  export const METADATA = {
    method: "GET",
    path: "/notifications/notificationPreferences/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/notifications/notificationPreferences/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): INotificationPreference => typia.random<INotificationPreference>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a notification preference by ID in 'notification_preferences'.
 *
 * Updates an existing notification preference record (ID-based) in
 * 'notification_preferences'. For example, turning on or off notifications for
 * replies, upvotes, or mentions. The body specifies which fields to change
 * (e.g., enabled status).
 *
 * Security checks ensure the acting user is either the owner or a platform
 * admin. Validation covers unique constraints, allowable notification types,
 * and correct boolean data. Auditability is enforced by logging changes. Edge
 * cases handled are: attempting to update non-existent/foreign records (error),
 * constraint violations, and invalid data. This endpoint matches get (fetch),
 * post (create), patch (list), delete (remove) as standard CRUD support for
 * notification customization.
 *
 * @param props.id Notification preference unique ID.
 * @param props.body Updated notification preference fields (enabled, type).
 * @path /notifications/notificationPreferences/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Notification preference unique ID. */
    id: string & tags.Format<"uuid">;

    /** Updated notification preference fields (enabled, type). */
    body: INotificationPreference.IUpdate;
  };
  export type Body = INotificationPreference.IUpdate;
  export type Response = INotificationPreference;

  export const METADATA = {
    method: "PUT",
    path: "/notifications/notificationPreferences/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/notifications/notificationPreferences/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): INotificationPreference => typia.random<INotificationPreference>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a notification preference by ID in 'notification_preferences'.
 *
 * Permanently deletes a notification preference by its unique ID. Operation is
 * restricted to either the owner or an admin—attempts by others will fail with
 * permission errors. Underlying storage in 'notification_preferences' applies
 * cascade or restrict deletion policies per schema; related notification
 * deliveries are unaffected.
 *
 * Once deleted, the user's configuration for that notification type reverts to
 * platform defaults. The operation is standard in settings/configuration
 * interfaces and is paired with create, update, get, and patch (search)
 * endpoints. Auditable, fully validated, and returns clear error feedback for
 * not found, forbidden, or database constraint failures.
 *
 * @param props.id Notification preference unique ID.
 * @path /notifications/notificationPreferences/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Notification preference unique ID. */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/notifications/notificationPreferences/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/notifications/notificationPreferences/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
