import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IUserProfile } from "../../../structures/IUserProfile";
import { IPageIUserProfile } from "../../../structures/IPageIUserProfile";

/**
 * Create a new user profile (user_profiles table, after user creation).
 *
 * Input required profile details (display name, avatar URL, bio, joined_at) and
 * create the record as a normalized 1:1 extension of a specific user. Enforces
 * constraint of one profile per user. 'user_id' must be supplied and correspond
 * to an existing user.
 *
 * May only be invoked as part of complete onboarding or by admin actions. Upon
 * creation, related UI/profile endpoints may rely on this entity for profile
 * display, personalization, and audit. If user already has a profile, an error
 * is returned.
 *
 * Permission: Only user or admin may create/edit own profile. Related APIs:
 * Get/list/update/delete for user_profiles, user creation.
 *
 * @param props.body Profile creation details (display name, avatar URL, etc.).
 * @path /core/userProfiles
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Profile creation details (display name, avatar URL, etc.). */
    body: IUserProfile.ICreate;
  };
  export type Body = IUserProfile.ICreate;
  export type Response = IUserProfile;

  export const METADATA = {
    method: "POST",
    path: "/core/userProfiles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/core/userProfiles";
  export const random = (g?: Partial<typia.IRandomGenerator>): IUserProfile =>
    typia.random<IUserProfile>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search user profiles (user_profiles table) with filters/pagination.
 *
 * Retrieves a list of user profiles with support for searching by display name,
 * joining date, and optional filtering by profile completeness (bio, avatar
 * present, etc.). Built on the 'user_profiles' Prisma table, which is a 1:1
 * extension of 'users'. This API is designed for admin/moderator UI, community
 * statistics, or advanced search scenarios.
 *
 * Permissions: Only users with adequate authority (moderator, admin) can list
 * arbitrary profiles; regular users may only see their own or public records.
 * Data complies with privacy and business rules.
 *
 * Supports pagination and sorting. Related APIs: get, create, update, delete
 * for user profiles. Each profile is joined to a 'user', which may be further
 * linked to posts, comments, etc.
 *
 * @param props.body Search query and pagination information for profiles.
 * @path /core/userProfiles
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search query and pagination information for profiles. */
    body: IUserProfile.IRequest;
  };
  export type Body = IUserProfile.IRequest;
  export type Response = IPageIUserProfile;

  export const METADATA = {
    method: "PATCH",
    path: "/core/userProfiles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/core/userProfiles";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIUserProfile => typia.random<IPageIUserProfile>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get user profile details by profile ID (user_profiles table).
 *
 * Returns all relevant details from the 'user_profiles' table for the specified
 * profile ID, representing basic public and private profile data. This includes
 * display name, avatar URL, bio, and join date, as well as the linked user via
 * user_id.
 *
 * Permissions/business logic: Access is public for non-sensitive fields, but
 * some fields may be restricted based on viewer authorization (e.g., bio
 * privacy, admin notes). Returns 404 if not found.
 *
 * Related endpoints: Listing and CRUD for user_profiles, user details. Editing
 * and deletion handled by other endpoints, only accessible to
 * owner/admin/moderator as configured.
 *
 * Error handling: Not found if no record with the requested ID, or forbidden if
 * attempting to view a non-public profile without authorization.
 *
 * @param props.id Profile's unique ID (UUID) to retrieve.
 * @path /core/userProfiles/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Profile's unique ID (UUID) to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IUserProfile;

  export const METADATA = {
    method: "GET",
    path: "/core/userProfiles/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/core/userProfiles/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUserProfile =>
    typia.random<IUserProfile>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a user profile by profile ID (user_profiles table).
 *
 * Updates specific atomic fields for an existing user profile, identified by
 * profile ID. Fields such as display name, avatar_url, or bio can be updated,
 * matching the structure and descriptions in the user_profiles Prisma schema.
 * Used for user-driven customization, admin/corrective actions, or moderation
 * of profile content.
 *
 * Permissions: User can update their own profile; admins/moderators can update
 * any as permitted by role. Enforces 1:1 mapping by only allowing update for
 * existing profiles; creates error if not found.
 *
 * Validation: Non-null display name, and (where present) avatar URL must be
 * valid; bio may be optional. Update timestamp and audit trail maintained.
 * Related CRUD endpoints handle other profile lifecycle operations.
 *
 * @param props.id Profile's unique ID (UUID) to update.
 * @param props.body Profile fields to update (display name, avatar, bio, etc.).
 * @path /core/userProfiles/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Profile's unique ID (UUID) to update. */
    id: string & tags.Format<"uuid">;

    /** Profile fields to update (display name, avatar, bio, etc.). */
    body: IUserProfile.IUpdate;
  };
  export type Body = IUserProfile.IUpdate;
  export type Response = IUserProfile;

  export const METADATA = {
    method: "PUT",
    path: "/core/userProfiles/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/core/userProfiles/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUserProfile =>
    typia.random<IUserProfile>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a user profile by profile ID (user_profiles table).
 *
 * Deletes the profile record from user_profiles table for the given profile ID.
 * Intended primarily for admin and automated tasks (e.g., GDPR account erasure,
 * cleanup after account deletion). Enforces unique per-user constraint; normal
 * users cannot perform this action except on their own account.
 *
 * Permissions: Only admin or account owner may delete a profile. Ensures data
 * consistency and referential integrity. Returns 404 if not found or already
 * deleted, 403 for unauthorized deletes. Returns updated object (post-delete
 * state may indicate deletion).
 *
 * Error handling: Not found or forbidden for unauthorized operation. Related:
 * user account is still retained (soft-delete in users), but this removes
 * associated profile record. Related CRUD endpoints for user and profile.
 *
 * @param props.id Profile's unique ID (UUID) to delete.
 * @path /core/userProfiles/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Profile's unique ID (UUID) to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IUserProfile;

  export const METADATA = {
    method: "DELETE",
    path: "/core/userProfiles/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/core/userProfiles/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUserProfile =>
    typia.random<IUserProfile>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
