import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IUser } from "../../../structures/IUser";
import { IPageIUser } from "../../../structures/IPageIUser";

/**
 * Create a new user account (users table, registration).
 *
 * Accepts validated registration information and creates a new user record in
 * the 'users' table. The request includes the user's email, password (hashed
 * before storage), and initial profile details if needed. Ensures uniqueness
 * constraint on email and enforces best practices for password security
 * (hashing, not storing plaintext).
 *
 * Security: Only open to unauthenticated users (for self-registration) or
 * admins (for bulk invitations).
 *
 * Validation: Email format check, password strength requirements, and conflict
 * handling for existing emails.
 *
 * Business logic: After successful creation, an entry is also expected/created
 * in user_profiles for the user. Soft-deletion and audit trails apply on the
 * 'users' table.
 *
 * Related endpoints: User detail, update, deletion. Role assignment handled
 * separately upon creation or via admin interface.
 *
 * @param props.body User registration details (email, password, etc.).
 * @path /core/users
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** User registration details (email, password, etc.). */
    body: IUser.ICreate;
  };
  export type Body = IUser.ICreate;
  export type Response = IUser;

  export const METADATA = {
    method: "POST",
    path: "/core/users",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/core/users";
  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>
    typia.random<IUser>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List users with full search and pagination (users table).
 *
 * This operation retrieves a paginated, searchable, and sortable list of user
 * accounts from the 'users' table. The underlying Prisma schema describes
 * 'users' as the root entity for community membership, storing information like
 * email, hashed password, and creation date. User roles and permissions depend
 * on entries in the 'role_assignments' table, but each entry here represents a
 * unique account.
 *
 * Security considerations: Only users with admin or moderator roles can access
 * this list, as it may contain sensitive details (e.g., presence of deleted
 * accounts). The list includes both active and soft-deleted accounts, with
 * deletion status indicated by 'deleted_at'.
 *
 * For validation: Query parameters support pagination (e.g., page, limit),
 * search filters (e.g., by email or registration date), and sorting (e.g., by
 * created_at desc, email asc). Business logic ensures only authorized users can
 * retrieve this information. Related endpoints are the user detail, creation,
 * update, and deletion APIs.
 *
 * Related API: Each user in the returned list can be accessed in detail via
 * 'GET /core/users/{id}'. Creation, update, and delete operations are handled
 * elsewhere.
 *
 * @param props.body Search/filtering/sorting info for user list query.
 * @path /core/users
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search/filtering/sorting info for user list query. */
    body: IUser.IRequest;
  };
  export type Body = IUser.IRequest;
  export type Response = IPageIUser;

  export const METADATA = {
    method: "PATCH",
    path: "/core/users",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/core/users";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIUser =>
    typia.random<IPageIUser>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a single user's details by ID (users table).
 *
 * Retrieves all atomic and normalized information about a specific user as
 * defined by the 'users' table in the Prisma schema. The schema includes fields
 * such as id, email, hashed password (not returned), account creation date,
 * soft deletion timestamp, and all relationships such as user_profiles,
 * role_assignments, posts, comments, and audit logs.
 *
 * Permissions: Only admins, moderators, or the user themselves (via auth token)
 * may access this endpoint. Returns 404 if the specified user does not exist or
 * is soft-deleted and the caller is not authorized.
 *
 * Business logic: Prevents disclosure of sensitive data such as
 * hashed_password. Account status and key metadata are provided for audit or
 * account management views. Soft-deleted users remain available for audit
 * purposes.
 *
 * Error handling: Returns access denied for unauthorized requests; not found
 * for missing/invalid IDs. Related endpoints: user list, create, update, and
 * delete. Profile and role assignment APIs may reference this record.
 *
 * @param props.id User's unique ID (UUID) to fetch full user information.
 * @path /core/users/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** User's unique ID (UUID) to fetch full user information. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IUser;

  export const METADATA = {
    method: "GET",
    path: "/core/users/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/core/users/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>
    typia.random<IUser>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing user's info by ID (users table).
 *
 * Performs an update to specific fields (such as email, password hash, or
 * status) for an existing user entry in the 'users' table. Follows the
 * normalized structure, only updating atomic, non-derived fields and respecting
 * unique email constraint. Intended for user self-update (profile, password) or
 * administrative actions (status, email change).
 *
 * Permissions: Only the user themselves, admins, or relevant moderators can
 * make changes. Admins may also perform soft deletion/reactivation.
 *
 * Validation: Ensures new email remains unique; password updates are properly
 * hashed. Returns errors for invalid input, unauthorized access, or conflict
 * (duplicate email).
 *
 * Error handling: 404 if user not found. On success, returns the new user
 * record (with redacted sensitive fields). Related APIs: Get, list, and delete
 * for users.
 *
 * @param props.id User's unique ID (UUID) to update.
 * @param props.body Fields to update for this user (email, password, etc.)
 * @path /core/users/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** User's unique ID (UUID) to update. */
    id: string & tags.Format<"uuid">;

    /** Fields to update for this user (email, password, etc.) */
    body: IUser.IUpdate;
  };
  export type Body = IUser.IUpdate;
  export type Response = IUser;

  export const METADATA = {
    method: "PUT",
    path: "/core/users/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/core/users/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>
    typia.random<IUser>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete a user account by ID (users table).
 *
 * Marks a user as deleted (sets deleted_at) in the 'users' table, rather than
 * actually removing the record (soft deletion). Ensures compliance with privacy
 * and business rules about data retention and audit trails. Can only be
 * performed by the account owner (self-withdrawal) or admins/moderators
 * (account suspension, rule violation).
 *
 * Permissions: Strictly controlled; verifies caller's authority before
 * deletion. Maintains referential integrity and prevents accidental total
 * deletion.
 *
 * Error handling: 404 if user does not exist or is already deleted. 403 for
 * unauthorized attempts. Related: Restoration can be handled by clearing
 * deleted_at (not covered here); audit logs are retained for evidence. Related
 * endpoints: Get/list/update.
 *
 * @param props.id User's unique ID (UUID) to delete.
 * @path /core/users/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** User's unique ID (UUID) to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IUser;

  export const METADATA = {
    method: "DELETE",
    path: "/core/users/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/core/users/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>
    typia.random<IUser>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
