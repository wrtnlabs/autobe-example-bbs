import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IUser } from "../../../structures/IUser";
import { IPageIUser } from "../../../structures/IPageIUser";

/**
 * Register a new user (core.users table).
 *
 * This operation handles new user registration or administrator-created user
 * accounts. It accepts all required and optional fields per the users model:
 * username, email, bio (optional), status, and an associated user_role_id.
 * Passwords are securely hashed before saving, never stored in plain text.
 *
 * Unique constraints are enforced for both username and email to prevent
 * duplicates. The user role must point to an existing role defined in
 * user_roles. Timestamps for creation and update are handled automatically.
 * Successful creation returns the newly registered user's public profile and
 * role association (never the password hash).
 *
 * Security and validation reflect business rules, e.g., email visibility,
 * profile privacy, and initial status setting. Input errors or duplicates
 * return clear messages and codes. Related endpoints: list (PATCH), read (GET),
 * update (PUT), delete (DELETE).
 *
 * @param props.body Registration info for the new user, including username,
 *   email, password, user role, etc.
 * @path /core/users
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Registration info for the new user, including username, email,
     * password, user role, etc.
     */
    body: IUser.ICreate;
  };
  export type Body = IUser.ICreate;
  export type Response = IUser;

  export const METADATA = {
    method: "POST",
    path: "/core/users",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/core/users";
  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>
    typia.random<IUser>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve a paginated, filterable list of users (core.users table).
 *
 * This operation returns a paginated and filtered list of users registered on
 * the discussion board. Users may be searched by username, email, user role, or
 * status, and results are sorted and paginated according to the provided
 * parameters. The endpoint refers to the users table, whose structure includes
 * fields for username, email, bio, role reference, password hash, timestamps,
 * and status. Filters can help administrators or moderators locate specific
 * accounts, monitor new signups, or audit activity. Security is enforced: only
 * users with moderator or administrator roles can access or use advanced
 * filters.
 *
 * The endpoint applies business rules from the requirements, such as hiding
 * sensitive (e.g., password) information, and supports relations to user_roles
 * for displaying or filtering by user type. Pagination and sorting follow best
 * practices for usability and performance. Related endpoints: create (POST),
 * retrieve detail (GET), update (PUT), and delete (DELETE) for users.
 *
 * Error handling ensures invalid queries, unauthorized access, or database
 * issues are managed gracefully, returning clear status codes and messages.
 * Sensitive data, such as password hashes, is never included in responses.
 *
 * @param props.body Filtering, sorting, and pagination info for user listing
 *   request.
 * @path /core/users
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Filtering, sorting, and pagination info for user listing request. */
    body: IUser.IRequest;
  };
  export type Body = IUser.IRequest;
  export type Response = IPageIUser.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/core/users",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/core/users";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIUser.ISummary => typia.random<IPageIUser.ISummary>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve detailed profile info for a specific user (core.users table).
 *
 * This operation retrieves the full profile and related information for a
 * specific user, identified by their unique user ID. Fields returned follow the
 * schema comments: username, email, bio, status, timestamps, and a reference to
 * their user role. User roles are resolved to human-readable labels where
 * appropriate.
 *
 * Sensitive fields such as password_hash are never returned. This endpoint is
 * typically used by administrators for user management, or by users to view
 * their own account details. Where authorized, moderators may use this endpoint
 * for resolving moderation cases or audits. The data aligns exactly with the
 * users table comments and model.
 *
 * Related endpoints include listing (PATCH), creation (POST), update (PUT), and
 * deletion (DELETE) for users. Error handling covers not found, unauthorized,
 * or forbidden cases, always giving appropriate error codes and minimal leak of
 * protected info.
 *
 * @param props.id Target user's ID (UUID).
 * @path /core/users/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target user's ID (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IUser;

  export const METADATA = {
    method: "GET",
    path: "/core/users/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/core/users/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>
    typia.random<IUser>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update user profile and account fields (core.users table).
 *
 * Updates an existing user's information, addressing fields in the users
 * schema, such as username, email, bio, role, status, and update timestamp. The
 * input must include the user ID and only permitted fields are updateable.
 * Username/email uniqueness is enforced on update as well.
 * Moderators/administrators can change roles/statuses as permitted by business
 * rules.
 *
 * The request never allows direct password updates (managed by a separate
 * dedicated endpoint, or by password reset process for security). All change
 * history is reflected in the updated_at timestamp. Security measures prevent
 * users from editing others' profiles unless authorized; self-edits are limited
 * to certain fields.
 *
 * Related endpoints: detail (GET), list (PATCH), create (POST), delete
 * (DELETE). Strict validation and business rule application ensure stability
 * and data quality.
 *
 * @param props.id Target user's ID (UUID).
 * @param props.body Editable fields for user update, such as profile details or
 *   status/role changes (excludes password updates).
 * @path /core/users/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target user's ID (UUID). */
    id: string & tags.Format<"uuid">;

    /**
     * Editable fields for user update, such as profile details or
     * status/role changes (excludes password updates).
     */
    body: IUser.IUpdate;
  };
  export type Body = IUser.IUpdate;
  export type Response = IUser;

  export const METADATA = {
    method: "PUT",
    path: "/core/users/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/core/users/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>
    typia.random<IUser>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Softly or fully delete a user (core.users table).
 *
 * Deletes a user account with the specified ID. This typically marks the user's
 * status as deleted or suspended and/or sets a deletion flag in audit fields,
 * per the users Prisma schema and moderation rules. Associated content (posts,
 * comments, votes) may be retained for community reference, moderation, or
 * audit logs, as described in requirements.
 *
 * Only administrators may perform this action, and a detailed audit trail is
 * kept. Related endpoints are used for restoration or final hard-delete (if
 * policy allows). Errors for not found or forbidden actions are handled
 * appropriately; sensitive information on deleted users is not exposed.
 *
 * @param props.id Target user's ID (UUID).
 * @path /core/users/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target user's ID (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IUser.IDeleteResponse;

  export const METADATA = {
    method: "DELETE",
    path: "/core/users/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/core/users/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IUser.IDeleteResponse => typia.random<IUser.IDeleteResponse>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
