import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRoleAssignment } from "../../../structures/IRoleAssignment";
import { IPageIRoleAssignment } from "../../../structures/IPageIRoleAssignment";

/**
 * Create a new user role assignment (role_assignments table).
 *
 * This endpoint assigns a user to a role by creating a new 'role_assignments'
 * record, following strict normalization as shown in the Prisma schema. Its use
 * case is granting moderator/admin access or standard onboarding workflows.
 * Data includes the user ID, role ID, and assignment timestamp. Duplicate
 * assignments (same user/role) are rejected with an error, as the combination
 * is uniquely constrained in the DB.
 *
 * Security is enforced—only admins may access. All assignments are logged for
 * audit compliance. Errors include uniqueness violations, permission denials,
 * and missing referenced users or roles. Upon successful creation, the exact
 * assignment record is returned.
 *
 * Each assignment can later be updated or deleted using the corresponding
 * endpoints. Related endpoints involve listing, detail retrieval, update, and
 * delete for role assignments.
 *
 * @param props.body Data for creating a user role assignment (user ID, role
 *   ID).
 * @path /core/roleAssignments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Data for creating a user role assignment (user ID, role ID). */
    body: IRoleAssignment.ICreate;
  };
  export type Body = IRoleAssignment.ICreate;
  export type Response = IRoleAssignment;

  export const METADATA = {
    method: "POST",
    path: "/core/roleAssignments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/core/roleAssignments";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IRoleAssignment => typia.random<IRoleAssignment>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search user role assignments (role_assignments table).
 *
 * This endpoint retrieves a (possibly paginated and filtered) list of role
 * assignments that link users to roles in the 'role_assignments' table. Used
 * for administrative review, bulk role management, or audit trailing. Supports
 * query parameters or request body filters such as user ID, role ID, assignment
 * range, and sorting preferences. Each assignment includes the user and role
 * reference, with joined data when needed.
 *
 * Security is strict: only admins (and possibly moderators, if business rules
 * allow) may use this operation. Output is paginated for scalability, and can
 * be sorted by assignment date or related user/role fields. Error responses
 * account for invalid filters, missing resources, or permission denials.
 * Related endpoints are single record view, assignment creation, update, and
 * deletion.
 *
 * The endpoint references the strong normalization principles of the Prisma
 * schema—no redundant details, referential integrity maintained. Any query
 * performance considerations should be addressed for potentially large
 * datasets.
 *
 * @param props.body Query and filter info for role assignments list.
 * @path /core/roleAssignments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Query and filter info for role assignments list. */
    body: IRoleAssignment.IRequest;
  };
  export type Body = IRoleAssignment.IRequest;
  export type Response = IPageIRoleAssignment;

  export const METADATA = {
    method: "PATCH",
    path: "/core/roleAssignments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/core/roleAssignments";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIRoleAssignment => typia.random<IPageIRoleAssignment>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get details of a role assignment (role_assignments table) by ID.
 *
 * This endpoint fetches a single role assignment record by its ID from the
 * 'role_assignments' table. Returns all assignment details, including
 * references to the user, role, and assignment date. The Prisma schema ensures
 * the 'id' field uniquely identifies each assignment and maintains integrity
 * across roles and users.
 *
 * Security rules restrict access to admins. The output is used for inspection,
 * audit, or edit UI initialization. If the record does not exist, a clear error
 * is returned. The endpoint does not allow mutation—use update and delete for
 * those workflows. Error cases include not found and permission denied. Related
 * endpoints: list, create, update, and delete role assignments.
 *
 * @param props.id Target role assignment's ID.
 * @path /core/roleAssignments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target role assignment's ID. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IRoleAssignment;

  export const METADATA = {
    method: "GET",
    path: "/core/roleAssignments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/core/roleAssignments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IRoleAssignment => typia.random<IRoleAssignment>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a user role assignment (role_assignments table) by ID.
 *
 * Via this endpoint, admins can update which role is assigned to a user, or
 * update assignment metadata (such as timestamp), reflecting changes in system
 * access. Fully normalized per DB schema—updated fields include user_id,
 * role_id, assigned_at. Uniqueness is enforced for the (user_id, role_id) pair.
 * Attempts to create duplicates or reference non-existent users/roles produce
 * errors. Security means only admins operate this endpoint. The update action
 * is logged for audit and system security reporting.
 *
 * Related endpoints: assignment creation, deletion, list, and get detail. Error
 * handling is explicit for not found, permission, and uniqueness conflicts.
 *
 * @param props.id Target role assignment's ID.
 * @param props.body Payload for updated assignment data (user, role,
 *   assigned_at).
 * @path /core/roleAssignments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target role assignment's ID. */
    id: string & tags.Format<"uuid">;

    /** Payload for updated assignment data (user, role, assigned_at). */
    body: IRoleAssignment.IUpdate;
  };
  export type Body = IRoleAssignment.IUpdate;
  export type Response = IRoleAssignment;

  export const METADATA = {
    method: "PUT",
    path: "/core/roleAssignments/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/core/roleAssignments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IRoleAssignment => typia.random<IRoleAssignment>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a user role assignment (role_assignments table) by ID.
 *
 * This endpoint permanently deletes a user-to-role assignment, removing the
 * mapping in the 'role_assignments' table. Used for demoting users, revoking
 * privileges, or responding to user departures. Actions are strictly restricted
 * to admins, and the deletion is recorded in audit logs for transparency as
 * required in business rules.
 *
 * Validation ensures the assignment exists before deletion. Output includes a
 * confirmation or the deleted record. Attempts to delete non-existent
 * assignments return a 'not found' error. No cascading on users/roles is
 * done—only the assignment is affected.
 *
 * Referential integrity (via Prisma schema) ensures correct and safe operation.
 * Related endpoints: create, update, detail, and list role assignments.
 *
 * @param props.id Target role assignment's ID.
 * @path /core/roleAssignments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target role assignment's ID. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IRoleAssignment;

  export const METADATA = {
    method: "DELETE",
    path: "/core/roleAssignments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/core/roleAssignments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IRoleAssignment => typia.random<IRoleAssignment>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
