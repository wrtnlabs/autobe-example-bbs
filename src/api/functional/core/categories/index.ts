import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICategory } from "../../../structures/ICategory";
import { IPageICategory } from "../../../structures/IPageICategory";

/**
 * Create new category (Core.categories).
 *
 * Allows creation of a new category topic for the discussion board, by
 * inserting a new record into the 'categories' table in the database. The
 * provided name must be unique among all categories. Description field gives
 * users context. Only authorized users (administrators) are permitted to
 * execute this operation.
 *
 * Input validation includes ensuring that required fields are present, name
 * does not duplicate existing entries, and description respects length/content
 * rules. On success, the new category is created and returned with full detail
 * including its assigned UUID and creation timestamp.
 *
 * Error handling covers invalid parameters, uniqueness violations, or
 * insufficient permissions.
 *
 * Related endpoints: list/search (PATCH), get (GET), update (PUT), and delete
 * (DELETE) for categories.
 *
 * @param props.body Data for new category including unique name and
 *   description.
 * @path /core/categories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Data for new category including unique name and description. */
    body: ICategory.ICreate;
  };
  export type Body = ICategory.ICreate;
  export type Response = ICategory;

  export const METADATA = {
    method: "POST",
    path: "/core/categories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/core/categories";
  export const random = (g?: Partial<typia.IRandomGenerator>): ICategory =>
    typia.random<ICategory>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List and search categories (Core.categories).
 *
 * This API operation returns a list of categories, leveraging the 'categories'
 * table from the database.
 *
 * The response is paginated and may be filtered based on optional query
 * parameters such as name, partial matches in description, or created_at
 * window. Secure endpoints may restrict certain filters or result fields to
 * administrators. The main purpose is to allow users to browse or search
 * available discussion categories for post assignment or exploration.
 *
 * Security: Some filtering/search options may be restricted to users with
 * elevated roles, such as administrators or moderators. Regular users typically
 * see all active categories only.
 *
 * This endpoint is commonly used in category selection modals, administrative
 * dashboards, and on board homepages. Validation ensures page and pageSize are
 * non-negative, and sortBy field must match a valid column. Error handling will
 * return informative failures for invalid filter parameters or database
 * errors.
 *
 * This operation is related to single-category get, create, update, and delete
 * operations, and in large systems may be supplemented by category
 * suggestion/approval flows.
 *
 * @param props.body Search criteria, pagination, and sorting parameters for
 *   categories list query.
 * @path /core/categories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Search criteria, pagination, and sorting parameters for categories
     * list query.
     */
    body: ICategory.IRequest;
  };
  export type Body = ICategory.IRequest;
  export type Response = IPageICategory;

  export const METADATA = {
    method: "PATCH",
    path: "/core/categories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/core/categories";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageICategory =>
    typia.random<IPageICategory>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve specific category by ID (Core.categories).
 *
 * Retrieves category information for the specified ID from the 'categories'
 * table, including name, description, creation timestamp, and potentially
 * related post count or status if extended.
 *
 * If the category does not exist, the API returns a clear error message. Access
 * policies determine visibility of archived or deactivated categoriesâ€”regular
 * users can only view active categories, while admins may retrieve all states.
 *
 * This endpoint is essential for screens displaying category details prior to
 * editing/deleting, or for referencing during post creation/editing workflows.
 * Includes validation of the UUID path parameter. Returns 404 if not found or
 * permission denied.
 *
 * Related endpoints: categories list/search (PATCH), create (POST), update
 * (PUT), and delete (DELETE).
 *
 * @param props.id Unique ID of the target category
 * @path /core/categories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique ID of the target category */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ICategory;

  export const METADATA = {
    method: "GET",
    path: "/core/categories/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/core/categories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ICategory =>
    typia.random<ICategory>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a category by ID (Core.categories).
 *
 * Updates an existing category's name or description by changing the relevant
 * fields in the 'categories' table. The category is referenced by its unique
 * UUID path parameter, and the body provides updated data.
 *
 * This operation may only be performed by users with appropriate administrative
 * roles. Validation checks include verifying that the new category name does
 * not duplicate any other categories and that all required fields meet
 * formatting rules.
 *
 * Partial or full updates are supported; fields not included may retain their
 * current values. Business rules may restrict changes if the category is
 * currently associated with posts. On success, the full updated category
 * information is returned.
 *
 * Error handling includes failing if the category does not exist, trying to use
 * a duplicate name, or lacking sufficient rights. Related operations: get,
 * create, delete, and list/search categories.
 *
 * @param props.id Unique ID of the target category
 * @param props.body Updated name and/or description for the category.
 * @path /core/categories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique ID of the target category */
    id: string & tags.Format<"uuid">;

    /** Updated name and/or description for the category. */
    body: ICategory.IUpdate;
  };
  export type Body = ICategory.IUpdate;
  export type Response = ICategory;

  export const METADATA = {
    method: "PUT",
    path: "/core/categories/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/core/categories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ICategory =>
    typia.random<ICategory>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a category by ID (Core.categories).
 *
 * Deletes (or marks as deleted) a category based on its unique ID. This
 * operation usually employs soft-deletion: the category is flagged so it no
 * longer appears in lists or selection menus, but remains in the database for
 * historical tracking and audit purposes. Some implementations may require hard
 * deletion if the category has no posts attached.
 *
 * Permission to use this operation is typically restricted to administrators.
 * Attempts to delete active categories in use by posts may be rejected or
 * require confirmation. All deletion attempts are logged for audit.
 *
 * Error cases include non-existent category ID, attempts to delete categories
 * linked to live posts, or insufficient permissions. Related endpoints: create,
 * get, update, and list/search categories.
 *
 * @param props.id Unique ID of the target category
 * @path /core/categories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique ID of the target category */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ICategory.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/core/categories/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/core/categories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ICategory.IDeleteResult => typia.random<ICategory.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
