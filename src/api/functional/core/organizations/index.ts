import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IOrganization } from "../../../structures/IOrganization";
import { IPageIOrganization } from "../../../structures/IPageIOrganization";

/**
 * Create a new organization/team (organizations table).
 *
 * Creates a new organization/team/group in the system by inserting into the
 * 'organizations' table. Input contains the name and optional description, in
 * line with the normalization policy and uniqueness constraint (no duplicate
 * names). Used for advanced role, permission, or team management workflows as
 * described in future enhancements.
 *
 * Security restricts this operation to admin/moderator. Validation covers
 * required fields, name uniqueness, and proper format. Successful creation
 * returns the new record. Errors for permission, format, or name conflicts.
 * Related endpoints: detail fetch, update, list, and delete organizations.
 *
 * Creation actions should be logged for audit and transparency per business
 * rules.
 *
 * @param props.body Payload for new organization (name, description).
 * @path /core/organizations
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Payload for new organization (name, description). */
    body: IOrganization.ICreate;
  };
  export type Body = IOrganization.ICreate;
  export type Response = IOrganization;

  export const METADATA = {
    method: "POST",
    path: "/core/organizations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/core/organizations";
  export const random = (g?: Partial<typia.IRandomGenerator>): IOrganization =>
    typia.random<IOrganization>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search organizations (organizations table).
 *
 * Lists all organization records (e.g., groups, teams) in a paginated,
 * optionally filtered format using the 'organizations' table of the Prisma
 * schema. Used for permission group management, group role assignment, or
 * future moderator team features as per business requirements. Admin or
 * moderator access is enforced by security rules.
 *
 * The endpoint supports searching by name, filtering, and various sort orders.
 * Return includes organization info: name, description, and creation data.
 * Related endpoints include detail retrieval, creation, update, and deletion
 * (if permitted). Implements strict normalization and indexing per schema.
 *
 * Errors include bad search parameters, missing resources, or access
 * violations. Deliver paginated output for large lists.
 *
 * @param props.body Request query/filter info for organizations list.
 * @path /core/organizations
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Request query/filter info for organizations list. */
    body: IOrganization.IRequest;
  };
  export type Body = IOrganization.IRequest;
  export type Response = IPageIOrganization;

  export const METADATA = {
    method: "PATCH",
    path: "/core/organizations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/core/organizations";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIOrganization => typia.random<IPageIOrganization>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get organization details (organizations table) by ID.
 *
 * Fetches a single organization record (team, group, etc.) from the
 * 'organizations' table using its unique ID. Includes fields like name and
 * description. Access limited to admins or moderators. If the ID is invalid or
 * not found, return an appropriate error. The returned object is used for
 * management UI population, further editing, or audit reporting. Referential
 * integrity and strict normalization are critical per Prisma schema. Related
 * endpoints: list, create, update, and delete organizations.
 *
 * @param props.id Target organization record's ID.
 * @path /core/organizations/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target organization record's ID. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IOrganization;

  export const METADATA = {
    method: "GET",
    path: "/core/organizations/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/core/organizations/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IOrganization =>
    typia.random<IOrganization>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update organization/team (organizations table) by ID.
 *
 * Updates an existing organization's properties by ID for admins or moderators.
 * Payload may alter the name or description, per the 'organizations' table
 * normalization policy. Checks for valid organization, unique name (no
 * duplicates), and logs the activity for transparency.
 *
 * Errors are provided for not found, name conflicts, or permission violations.
 * Only atomic field updates are madeâ€”no related data is modified. Related
 * endpoints: listing, creation, deletion, single record view. Strict
 * referential integrity per Prisma enforced.
 *
 * @param props.id Target organization record's ID.
 * @param props.body Payload for updated organization data (name, description).
 * @path /core/organizations/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target organization record's ID. */
    id: string & tags.Format<"uuid">;

    /** Payload for updated organization data (name, description). */
    body: IOrganization.IUpdate;
  };
  export type Body = IOrganization.IUpdate;
  export type Response = IOrganization;

  export const METADATA = {
    method: "PUT",
    path: "/core/organizations/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/core/organizations/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IOrganization =>
    typia.random<IOrganization>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete an organization from the Core.organizations table by ID.
 *
 * This API endpoint allows an administrator to remove an organization entry
 * from the platform. Organizations are used for grouping users and potential
 * future features related to organizational roles or permissions. Deleting an
 * organization will disassociate all users and roles from the organization but
 * must ensure referential integrity is preserved throughout the system.
 *
 * Before deleting an organization, the system must validate that the
 * organization exists and check for any dependencies, such as users assigned
 * exclusively to this organization, which may require reassignment or further
 * validation. Only users with administrative privileges should be allowed to
 * perform this operation, and all deletions should be soft deletions to support
 * auditability and potential recovery, according to GDPR and business
 * requirements.
 *
 * Attempting to delete a non-existent organization should return an appropriate
 * error message. This endpoint is related to other organization management
 * APIs, like creation and update. Deletion actions should be logged and subject
 * to the same audit controls described in site and moderation settings.
 *
 * @param props.id Unique identifier of the organization to delete.
 * @path /core/organizations/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier of the organization to delete. */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/core/organizations/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/core/organizations/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
