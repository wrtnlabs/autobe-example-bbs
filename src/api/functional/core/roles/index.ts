import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRole } from "../../../structures/IRole";
import { IPageIRole } from "../../../structures/IPageIRole";

/**
 * Create a new role (roles table) for RBAC management.
 *
 * This endpoint allows administrators to define new roles for permission
 * management, supporting RBAC (role-based access control) as outlined in the
 * platform's business rules and moderation workflows. The 'roles' table ensures
 * each role name is unique. The creation payload should include the 'name' and
 * 'description' fields, implementing normalization principles from the Prisma
 * schema. Security measures should restrict this operation to admin users only.
 * If a duplicate name is provided, an appropriate error should be raised.
 * Related endpoints include updating and deleting roles. Operation returns the
 * created role object, or an error if creation fails due to validation or
 * uniqueness constraints.
 *
 * Admins leverage this operation during system setup or to introduce new access
 * levels as the platform evolves. Post-creation, roles can be assigned to users
 * via the role assignment endpoints. Error handling includes validation for
 * required fields, database errors, and permission checks. Logs should record
 * who created the role for audit purposes.
 *
 * Errors and success responses must be clearly defined, ensuring administrative
 * actions are transparent and reversible if necessary.
 *
 * @param props.body Payload to create a new role, including name and
 *   description.
 * @path /core/roles
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Payload to create a new role, including name and description. */
    body: IRole.ICreate;
  };
  export type Body = IRole.ICreate;
  export type Response = IRole;

  export const METADATA = {
    method: "POST",
    path: "/core/roles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/core/roles";
  export const random = (g?: Partial<typia.IRandomGenerator>): IRole =>
    typia.random<IRole>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List all roles in the platform (roles table, RBAC).
 *
 * Retrieves a paginated and searchable list of all roles in the platform,
 * according to the 'roles' table from Prisma schema. Each record describes a
 * system-wide role (such as 'user', 'moderator', 'admin'), with a unique name
 * and description. This list is used by the admin UI for role assignment and
 * permissions management.
 *
 * RBAC (role-based access control) means that access is often limited to admin
 * or privileged users for this endpoint. The list is atomic and
 * normalizedâ€”never includes assignment details in this API.
 *
 * Supports search by name or description, sorting, and pagination for admin
 * dashboard or audit interfaces. Related operations: assigning users to roles,
 * role assignment CRUD. Error handling covers invalid queries, unauthorized
 * access, and standard paging edge-cases.
 *
 * @param props.body Query parameters for searching/sorting roles.
 * @path /core/roles
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Query parameters for searching/sorting roles. */
    body: IRole.IRequest;
  };
  export type Body = IRole.IRequest;
  export type Response = IPageIRole;

  export const METADATA = {
    method: "PATCH",
    path: "/core/roles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/core/roles";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIRole =>
    typia.random<IPageIRole>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a single role's details by ID (roles table, RBAC).
 *
 * Fetches full detail of a role, as defined by the 'roles' Prisma table.
 * Typical usage is for admin tools that display or manage system-wide
 * authorization types. Each role has a stable, unique name (used for permission
 * checking), description, and assigned IDs. Assignment of users to roles is
 * handled separately.
 *
 * Authorization: Only admins or privileged staff can query arbitrary roles. Not
 * found is returned if no such role exists; business logic may restrict direct
 * manipulation of certain system roles (e.g., 'admin').
 *
 * Error handling: Access denied for unauthorized requests; not found for
 * non-existent role.
 *
 * Related endpoints: List/search for roles; role assignment management not
 * covered here.
 *
 * @param props.id Role's unique ID (UUID) to retrieve details for.
 * @path /core/roles/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Role's unique ID (UUID) to retrieve details for. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IRole;

  export const METADATA = {
    method: "GET",
    path: "/core/roles/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/core/roles/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IRole =>
    typia.random<IRole>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing role by ID (roles table).
 *
 * This endpoint allows an admin to update the properties (such as the name and
 * description) of an existing RBAC role using its unique ID. The operation is
 * grounded in the 'roles' table as described in the Prisma schema, with strong
 * normalization discipline on role identification. Validation rules require
 * that the role exists, and that any updated 'name' remains unique across the
 * table. This operation is essential for administrative maintenance and adapts
 * the system to evolving requirements or refined role definitions.
 *
 * Role updates are performed via a JSON request body mirroring 'IRole.IUpdate',
 * typically providing the new name and/or description. The update is logged for
 * audit purposes. Security is enforced: only admin users may access.
 * Validations include null checks, duplicate name checks, and verifying whether
 * the ID exists. Error handling must deliver clear messages for not found and
 * uniqueness violations.
 *
 * Related endpoints include role creation and deletion. RBAC logic ensures that
 * updates do not inadvertently escalate privileges beyond admin-controlled
 * workflows.
 *
 * @param props.id Target role's ID.
 * @param props.body Payload containing updated role data.
 * @path /core/roles/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target role's ID. */
    id: string & tags.Format<"uuid">;

    /** Payload containing updated role data. */
    body: IRole.IUpdate;
  };
  export type Body = IRole.IUpdate;
  export type Response = IRole;

  export const METADATA = {
    method: "PUT",
    path: "/core/roles/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/core/roles/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IRole =>
    typia.random<IRole>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete an existing role by ID (roles table).
 *
 * This endpoint permanently deletes a role identified by its unique ID. Only
 * users with admin privileges can invoke this operation, as it affects RBAC
 * configuration. The associated Prisma table, 'roles', is normalized and
 * indexed for unique names; deletion checks should consider referential
 * integrity with the 'role_assignments' table. If the role is assigned to
 * users, rejection or cascaded removal must follow explicit business rules. The
 * deleted role is no longer available for assignment or in user-facing role
 * lists.
 *
 * Logs should record the acting admin and the deletion event for transparency.
 * If deletion is blocked due to existing assignments, an error is returned.
 * Upon successful deletion, a confirmation message or the deleted record may be
 * returned. Related operations: role creation and updates.
 *
 * Compliant error messages and secure access are critical to prevent privilege
 * escalation or accidental RBAC reconfiguration.
 *
 * @param props.id Target role's ID.
 * @path /core/roles/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target role's ID. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IRole;

  export const METADATA = {
    method: "DELETE",
    path: "/core/roles/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/core/roles/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IRole =>
    typia.random<IRole>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
