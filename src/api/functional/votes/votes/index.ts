import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IVote } from "../../../structures/IVote";
import { IPageIVote } from "../../../structures/IPageIVote";

/**
 * Create a new vote (Votes domain, 'votes' table).
 *
 * Lets a user cast a vote—either upvote or downvote—on a post or comment.
 * Input: must include user ID, value (+1/-1), and reference to either a post or
 * a comment (but not both). Performs validation to ensure target exists and
 * user has not already voted. On success, returns created vote record.
 *
 * Vote limit: only one vote per user per content item, enforced via unique
 * constraint. Can be used for voting analytics, user history, and tally
 * calculations. Related endpoints: retrieve (GET /votes/votes/{id}), update
 * (PUT /votes/votes/{id}), delete (DELETE /votes/votes/{id}), list (PATCH
 * /votes/votes).
 *
 * @param props.body Cast a vote on a post or comment: must include value (+1 or
 *   -1) and target (postId or commentId).
 * @path /votes/votes
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Cast a vote on a post or comment: must include value (+1 or -1) and
     * target (postId or commentId).
     */
    body: IVote.ICreate;
  };
  export type Body = IVote.ICreate;
  export type Response = IVote;

  export const METADATA = {
    method: "POST",
    path: "/votes/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/votes/votes";
  export const random = (g?: Partial<typia.IRandomGenerator>): IVote =>
    typia.random<IVote>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve a filtered, paginated list of votes (Votes domain, 'votes' table).
 *
 * This API returns a list of vote records, most commonly used for reviewing
 * moderation history, analytics, or a user's own votes. Supports filtering by
 * userId, postId, or commentId; pagination (offset/limit); sort order (most
 * recent, oldest first). Optionally, can search for patterns if metadata fields
 * exist.
 *
 * References the 'votes' table (Votes domain) and makes use of unique
 * constraints (one vote per user per item) in its filtering logic. Security
 * notes: regular users can only see their own votes, admins/moderators may
 * audit all. Related endpoints: create (POST /votes/votes), update (PUT
 * /votes/votes/{id}), detail (GET /votes/votes/{id}), delete (DELETE
 * /votes/votes/{id}).
 *
 * @param props.body Filtering, pagination, and sorting for votes list. Fields:
 *   userId, postId, commentId, offset, limit, sort.
 * @path /votes/votes
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Filtering, pagination, and sorting for votes list. Fields: userId,
     * postId, commentId, offset, limit, sort.
     */
    body: IVote.IRequest;
  };
  export type Body = IVote.IRequest;
  export type Response = IPageIVote;

  export const METADATA = {
    method: "PATCH",
    path: "/votes/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/votes/votes";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIVote =>
    typia.random<IPageIVote>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve full details for a single vote (Votes domain, 'votes' table).
 *
 * Fetches detail for a specific vote, identified by its unique ID. Useful for
 * moderation review or self-audit by a voting user. Information includes which
 * user voted, the value (+1/-1), what post/comment was targeted, and
 * timestamps.
 *
 * References the 'votes' table (Votes domain). Only visible to the vote's owner
 * or those with sufficient privilege. Error handling covers not found,
 * unauthorized access, and malformed IDs. Related endpoints: create (POST
 * /votes/votes), update (PUT /votes/votes/{id}), details (PATCH /votes/votes),
 * delete (DELETE /votes/votes/{id}).
 *
 * @param props.id Vote record's ID
 * @path /votes/votes/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Vote record's ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVote;

  export const METADATA = {
    method: "GET",
    path: "/votes/votes/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/votes/votes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IVote =>
    typia.random<IVote>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Edit an existing vote's value (Votes domain, 'votes' table).
 *
 * Lets a user (or moderator/admin) edit an existing vote—typically to change
 * their upvote to downvote or vice versa, or to correct an input error. Only
 * the vote's owner or privileged users may edit. Only value can change; postId
 * or commentId are immutable.
 *
 * Business logic is enforced as per the 'votes' table (Votes domain): only one
 * vote per user/content, mutual exclusivity between postId/commentId, and all
 * references must remain valid. Returns the updated vote on success. Related
 * endpoints: create (POST /votes/votes), retrieve (GET /votes/votes/{id}), list
 * (PATCH /votes/votes), delete (DELETE /votes/votes/{id}).
 *
 * @param props.id Vote record's ID to update
 * @param props.body Fields to update in the vote (only value may be changed).
 * @path /votes/votes/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Vote record's ID to update */
    id: string & tags.Format<"uuid">;

    /** Fields to update in the vote (only value may be changed). */
    body: IVote.IUpdate;
  };
  export type Body = IVote.IUpdate;
  export type Response = IVote;

  export const METADATA = {
    method: "PUT",
    path: "/votes/votes/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/votes/votes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IVote =>
    typia.random<IVote>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a vote record from the database (Votes domain, 'votes' table).
 *
 * This endpoint removes a specific vote by its ID. Common use-cases: a user
 * withdraws their vote or a moderator/admin removes a vote for violating
 * policy. The vote is deleted from the database (hard delete), and any relevant
 * tally is decremented.
 *
 * Authorization checks ensure only the vote's owner or privileged roles may
 * perform deletion. Related endpoints: create (POST /votes/votes), update (PUT
 * /votes/votes/{id}), retrieve (GET /votes/votes/{id}), list (PATCH
 * /votes/votes). Audit logging may be triggered for moderation actions.
 *
 * @param props.id Vote record's ID to delete
 * @path /votes/votes/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Vote record's ID to delete */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IVote.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/votes/votes/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/votes/votes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IVote.IDeleteResult => typia.random<IVote.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
