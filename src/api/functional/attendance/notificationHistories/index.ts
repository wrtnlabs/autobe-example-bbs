import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAttendanceNotificationHistory } from "../../../structures/IAttendanceNotificationHistory";
import { IPageIAttendanceNotificationHistory } from "../../../structures/IPageIAttendanceNotificationHistory";

/**
 * Creates a new attendance_notification_history record in the database.
 *
 * This API endpoint allows the system to log a new delivery event for a
 * notification sent to parents, teachers, or admins. As described in the Prisma
 * schema: each record must store the foreign keys to the notification
 * (attendance_notification), the channel used for delivery
 * (attendance_notification_channel), the expected or actual sent/delivered
 * timestamps, delivery status (e.g., pending, delivered, failed), and any error
 * message returned from the channel provider. This is crucial for post-event
 * auditing and troubleshooting delivery issues.
 *
 * Permission checks must ensure that notification and channel refs are valid
 * and that only authorized system roles (notification relay/process runners,
 * not students or parents) are allowed to invoke this operation. Error handling
 * follows the schema: failing on missing required FK, invalid statuses, or
 * business rule violations (e.g., duplicate log for same
 * notification+channel+timestamp).
 *
 * Related API operations may include querying notification history (for
 * notification status dashboards or parent/teacher review) and bulk log import
 * (for external relay integration).
 *
 * @param props.connection
 * @param props.body Delivery attempt/result info of the notification history
 *   event.
 * @path /attendance/notificationHistories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Delivery attempt/result info of the notification history event. */
    body: IAttendanceNotificationHistory.ICreate;
  };
  export type Body = IAttendanceNotificationHistory.ICreate;
  export type Response = IAttendanceNotificationHistory;

  export const METADATA = {
    method: "POST",
    path: "/attendance/notificationHistories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/notificationHistories";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceNotificationHistory =>
    typia.random<IAttendanceNotificationHistory>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Search/list notification delivery history records
 * (attendance_notification_history).
 *
 * This API operation lists or searches notification delivery attempt histories
 * based on search/paging parameters as an atomic (paginated) query against
 * attendance_notification_history table. The client may filter by
 * notification_id, channel_id/type, recipient, delivery status,
 * sent_at/delivered_at window, etc. Only normalized detail records are
 * returned: do not aggregate/join message bodies or event meta here. Used in
 * parent/student dashboards, admin troubleshooting, analytics, or compliance
 * audit logs. Access is restricted to owners (for their events) or admin (full
 * scope). Errors are returned on access failure, invalid filters, or paging
 * issues. Standard pagination is always present (page, total, page_size, etc.),
 * plus an array of atomic history records for consumption by client UIs.
 *
 * @param props.connection
 * @param props.body Search, filter, and paging parameters for notification
 *   histories.
 * @path /attendance/notificationHistories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search, filter, and paging parameters for notification histories. */
    body: IAttendanceNotificationHistory.IRequest;
  };
  export type Body = IAttendanceNotificationHistory.IRequest;
  export type Response = IPageIAttendanceNotificationHistory;

  export const METADATA = {
    method: "PATCH",
    path: "/attendance/notificationHistories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/notificationHistories";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIAttendanceNotificationHistory =>
    typia.random<IPageIAttendanceNotificationHistory>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get details for a single notification delivery attempt by ID
 * (attendance_notification_history).
 *
 * This endpoint fetches atomic details for a single notification delivery
 * attempt by its UUID from attendance_notification_history. Returned data
 * includes notification_id, channel_id, all timestamps (sent, delivered, etc),
 * status, and any error codes/messages. Authorization required: only channel
 * owner (student/parent or their admin) may view. Used in troubleshooting
 * failed notifications, detail popups in notification status views, and audit
 * tasks. Proper error response for not found or privilege/record violations.
 * Result contains only normalized atomic log row.
 *
 * @param props.connection
 * @param props.id Target notification history delivery attempt's UUID.
 * @path /attendance/notificationHistories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target notification history delivery attempt's UUID. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceNotificationHistory;

  export const METADATA = {
    method: "GET",
    path: "/attendance/notificationHistories/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/notificationHistories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceNotificationHistory =>
    typia.random<IAttendanceNotificationHistory>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Updates a specific attendance_notification_history record.
 *
 * This API updates an existing notification history record. According to the
 * schema, the identifier (id) in the path selects the target row, while the
 * request body provides new values for status, error messages, and delivery
 * timestamps as appropriate. Editing is strictly controlled: only server
 * processes, notification relays, or authorized admins can amend delivery
 * results, and audit logs for such changes are mandated.
 *
 * Error handling includes checks for existence of target row, permissions, and
 * valid status transitions (e.g., cannot move from delivered to pending).
 *
 * This endpoint is related to the notification sending and monitoring API in
 * that it may be called asynchronously in response to webhook callbacks from
 * push/SMS/email providers.
 *
 * @param props.connection
 * @param props.id Target notification history record's ID (UUID).
 * @param props.body Partial/full update for the notification history record.
 * @path /attendance/notificationHistories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target notification history record's ID (UUID). */
    id: string & tags.Format<"uuid">;

    /** Partial/full update for the notification history record. */
    body: IAttendanceNotificationHistory.IUpdate;
  };
  export type Body = IAttendanceNotificationHistory.IUpdate;
  export type Response = IAttendanceNotificationHistory;

  export const METADATA = {
    method: "PUT",
    path: "/attendance/notificationHistories/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/attendance/notificationHistories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceNotificationHistory =>
    typia.random<IAttendanceNotificationHistory>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Deletes a specific attendance_notification_history record from the database.
 *
 * This endpoint allows the removal of a delivery attempt log for an attendance
 * notification. As described in the schema, deletion is only permissible for
 * authorized admin/system roles and must either soft-delete (audit fields: mark
 * deleted at) or hard-delete (fully remove the row for data
 * minimization/compliance) as per configuration.
 *
 * Deleting notification histories can impact the audit trail for notifications;
 * ensure cross-checks and proper permission checks before destructive actions.
 *
 * This is typically related to compliance operations or admin panel
 * troubleshooting/fixes for orphaned/erroneous log rows, not regular app flow.
 *
 * @param props.connection
 * @param props.id Target notification history record's ID (UUID).
 * @path /attendance/notificationHistories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target notification history record's ID (UUID). */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/attendance/notificationHistories/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/notificationHistories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
