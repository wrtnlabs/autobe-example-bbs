import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAttendanceAttendanceMethod } from "../../../structures/IAttendanceAttendanceMethod";
import { IPageAttendanceAttendanceMethod } from "../../../structures/IPageAttendanceAttendanceMethod";
import { _null } from "../../../structures/_null";

/**
 * Attendance_attendance_method(출석 방식) 신규 생성(post) API.
 *
 * 이 API는 attendance_attendance_method(출석 방식 마스터)에 신규 방식을 추가 생성(post)하는
 * 엔드포인트입니다.
 *
 * 예를 들어, 시스템 확장·조직별 정책에 의해 'NFC', '얼굴인식' 등 출석 방식이 추가될 때 사용합니다. 모든 필수
 * 칼럼(method_name/description)은 request body에 반드시 포함되어야 하며, 입력 누락/중복 시 422/400
 * 등의 에러 처리 필요.
 *
 * 생성 성공 시 PK(id)까지 포함한 전체 출석 방식 데이터를 반환하며, 비즈니스 정책에 따라 생성 권한 제어가 반드시 동반됩니다.
 *
 * @param props.connection
 * @param props.body 출석체크 방식 생성 정보 (method_name, description 포함)
 * @path /attendance/attendanceMethods
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** 출석체크 방식 생성 정보 (method_name, description 포함) */
    body: IAttendanceAttendanceMethod.ICreate;
  };
  export type Body = IAttendanceAttendanceMethod.ICreate;
  export type Response = IAttendanceAttendanceMethod;

  export const METADATA = {
    method: "POST",
    path: "/attendance/attendanceMethods",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/attendanceMethods";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAttendanceMethod =>
    typia.random<IAttendanceAttendanceMethod>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Attendance_attendance_method(출석 방식) 마스터 리스트 조회(검색/페이징 등 지원) 패치 API.
 *
 * 이 API는 attendance_attendance_method 테이블에 저장된 모든 출석 방식(출석체크 방법 마스터)의 리스트를 검색 및
 * 페이징/정렬과 함께 반환합니다.
 *
 * Ex) 메뉴에 '코드입력', 'QR스캔', 'API직접', '수기입력' 방식 제공시, 실제 가능한 방법/설명을 포함한 목록을 동적으로
 * 읽어와야 합니다. 검색 조건(method_name, description 등 텍스트 검색), 페이지네이션, 정렬 옵션의
 * requestBody를 구성하여 시스템 전체에서 일관성 있게 동작해야 하며, 반환 데이터 또한
 * IPageAttendanceAttendanceMethod와 같이 표준 페이징+복수레코드 구조를 가집니다.
 *
 * 실제 사용처는 교사용 대시보드, 출석 등록 UI, 설정페이지 등이며, Prisma 스키마 description을 반영해
 * method_name, description 등 키 정보를 반드시 포함해야 합니다.
 *
 * @param props.connection
 * @param props.body 출석 방식 리스트 패치 요청 정보 (검색조건/페이징/정렬)
 * @path /attendance/attendanceMethods
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** 출석 방식 리스트 패치 요청 정보 (검색조건/페이징/정렬) */
    body: IAttendanceAttendanceMethod.IRequest;
  };
  export type Body = IAttendanceAttendanceMethod.IRequest;
  export type Response = IPageAttendanceAttendanceMethod;

  export const METADATA = {
    method: "PATCH",
    path: "/attendance/attendanceMethods",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/attendanceMethods";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageAttendanceAttendanceMethod =>
    typia.random<IPageAttendanceAttendanceMethod>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Attendance_attendance_method(출석 방식) 단건 상세 조회(get) API.
 *
 * 본 API는 attendance_attendance_method(출석 방식 마스터) 테이블에서 PK(id)로 단일 방식을 조회하는 get
 * 방식 엔드포인트입니다.
 *
 * 사용 예시로는, 출석 등록 화면에서 사용가능한 선택 방법이나 설정 페이지에서 특정 방식 상세 정보 팝업을 열 때 등입니다. 반환 데이터는
 * method_name, description 등 테이블의 모든 컬럼을 포함해야 하며, id가 잘못되거나 없는 경우 404 반환되어야 하고,
 * 권한 문제는 403
 *
 * 검색 필드는 path param의 id(필수) 하나로 충분합니다.
 *
 * @param props.connection
 * @param props.id 조회 대상 출석 방식의 PK(UUID)
 * @path /attendance/attendanceMethods/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** 조회 대상 출석 방식의 PK(UUID) */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceAttendanceMethod;

  export const METADATA = {
    method: "GET",
    path: "/attendance/attendanceMethods/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/attendanceMethods/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAttendanceMethod =>
    typia.random<IAttendanceAttendanceMethod>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Attendance_attendance_method(출석 방식) 수정(put) API (PK id 기반).
 *
 * 본 API는 attendance_attendance_method(출석 방식) 마스터에서 PK(id)로 식별된 데이터를 수정(전체 대체)하는
 * put 엔드포인트입니다.
 *
 * 예로, 출석 방식 명칭 또는 설명을 변경할 때 사용되며, 실수/변경 정책 등으로 수정사항이 발생하면 본 API로 갱신합니다. request
 * body에는 수정가능한 모든 컬럼(method_name, description 등)이 포함되어야 하며, id 파라미터로 대상 명시, 이 후
 * 바뀐 전체 데이터를 반환합니다. 없는 id면 404, 입력 누락/제약 위반 등은 422, 권한 문제 403 반환.
 *
 * 정책상 수정시 audit log 연동을 권장합니다.
 *
 * @param props.connection
 * @param props.id 수정 대상 출석 방식 마스터의 PK(UUID)
 * @param props.body 수정 정보 (method_name, description 등)
 * @path /attendance/attendanceMethods/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** 수정 대상 출석 방식 마스터의 PK(UUID) */
    id: string & tags.Format<"uuid">;

    /** 수정 정보 (method_name, description 등) */
    body: IAttendanceAttendanceMethod.IUpdate;
  };
  export type Body = IAttendanceAttendanceMethod.IUpdate;
  export type Response = IAttendanceAttendanceMethod;

  export const METADATA = {
    method: "PUT",
    path: "/attendance/attendanceMethods/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/attendance/attendanceMethods/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAttendanceMethod =>
    typia.random<IAttendanceAttendanceMethod>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Attendance_attendance_method(출석 방식) 삭제(delete) API (PK id 기반).
 *
 * 이 API는 attendance_attendance_method 마스터에서 PK(id)를 기준으로 특정 출석 방식을 삭제(delete)하는
 * 엔드포인트입니다.
 *
 * 삭제 성공 시 200 혹은 204를 반환하며, 없는 id 404, 권한 부족/정책 위배 403 등을 명확히 핸들링해야 합니다. 실제 삭제
 * 방식(物리/논리)은 비즈니스 정책·감사업무 정책에 따라 변동됩니다.
 *
 * 모든 삭제는 감사 로그 등 연동, Prisma 모델의 컬럼 설계를 그대로 따릅니다.
 *
 * @param props.connection
 * @param props.id 삭제 대상 출석 방식 마스터의 PK(UUID)
 * @path /attendance/attendanceMethods/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** 삭제 대상 출석 방식 마스터의 PK(UUID) */
    id: string & tags.Format<"uuid">;
  };
  export type Response = _null;

  export const METADATA = {
    method: "DELETE",
    path: "/attendance/attendanceMethods/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/attendanceMethods/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): _null =>
    typia.random<_null>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
