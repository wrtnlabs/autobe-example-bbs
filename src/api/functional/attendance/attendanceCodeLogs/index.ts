import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAttendanceAttendanceCodeLog } from "../../../structures/IAttendanceAttendanceCodeLog";
import { IPageAttendanceAttendanceCodeLog } from "../../../structures/IPageAttendanceAttendanceCodeLog";
import { _null } from "../../../structures/_null";

/**
 * 출석 코드 로그(이벤트 기록) 신규 생성(post) API (attendance_attendance_code_log).
 *
 * 본 엔드포인트는 attendance_attendance_code_log 테이블(출석 코드 이벤트 이력)에 신규 이벤트 로그를 추가(생성)할
 * 때 사용합니다.
 *
 * 첫째, 출석 코드의 생성/사용/만료/오류 등 라이프사이클 이벤트가 발생하면 이 API를 호출해 새로운 로그를 저장합니다. 모든 필수
 * 요소(code_id, event_type, event_time, actor_id, actor_type)가 누락 없이 입력되어야 하며,
 * 시스템·관리자·교사 등 이벤트 주체(actor_type)에 따라 다양한 행위 감사를 지원해야 합니다.
 *
 * 둘째, 생성 성공 시 PK(id)와 함께 새 레코드 전체 데이터를 반환; 입력값 불충분 시 422, 권한 오류 시 403, 중복·규칙 위반
 * 시 400을 반환합니다.
 *
 * 셋째, 이 API는 부정 출석 탐지, 코드 감사, 실시간 대시보드 이벤트 삽입 등 다양한 비즈니스 로직의 기반이 됩니다.
 *
 * DB 구조 및 모든 컬럼/비즈니스 규칙은 attendance_attendance_code_log Prisma 테이블 description을
 * 그대로 따릅니다.
 *
 * @param props.connection
 * @param props.body 출석 코드 이벤트 로그 생성 정보 (code_id, event_type, ...반드시 포함)
 * @path /attendance/attendanceCodeLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** 출석 코드 이벤트 로그 생성 정보 (code_id, event_type, ...반드시 포함) */
    body: IAttendanceAttendanceCodeLog.ICreate;
  };
  export type Body = IAttendanceAttendanceCodeLog.ICreate;
  export type Response = IAttendanceAttendanceCodeLog;

  export const METADATA = {
    method: "POST",
    path: "/attendance/attendanceCodeLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/attendanceCodeLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAttendanceCodeLog =>
    typia.random<IAttendanceAttendanceCodeLog>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Attendance_attendance_code_log 테이블의 출석 코드 이벤트 이력 리스트 조회 (검색/페이징/정렬 지원).
 *
 * 이 API는 attendance_attendance_code_log 테이블 내용을 다수 조회하는 패치 엔드포인트입니다. 출석 코드의 사용
 * 이력 및 라이프사이클(발급/사용/만료/실패 등) 정보를 다양한 조건으로 필터링합니다.
 *
 * 첫 번째로, 교사와 관리자는 특정 코드별 이력, 학생 부정 출석 탐지, 발급일/사용일 기준 범위 검색, 이벤트 유형별 통계 등 실무에 맞는
 * 정보를 효율적으로 조회할 수 있습니다. Prisma 스키마의 description에 따라 code_id, event_type,
 * event_time 등의 컬럼을 기준으로 검색 필드를 제공해야 하며, 페이징(page, pageSize), 정렬(sortBy,
 * order), 기간 필터(startDate, endDate)도 지원해야 합니다.
 *
 * 두 번째로, 이 엔드포인트는 감사/보안 관점의 감사 로그 활용도 고려해야 하므로,
 * 액터(teacher/student/admin/system)별 이벤트 목록을 감시할 수 있습니다.
 *
 * 세 번째로, 반환 형식은 attendance_attendance_code_log의 복수결과(페이징 포함)로 하며, 응답 구조 또한
 * IPageAttendanceAttendanceCodeLog와 같은 표준 구조로 요약정보+데이터+카운트 방식이 되는 것이 바람직합니다.
 *
 * 이 API는 출석 코드 관련 대시보드, 보안감사, 부정 탐지 모듈 등과 연동되어 콜될 수 있습니다. DB 상 Prisma 테이블:
 * attendance_attendance_code_log.
 *
 * @param props.connection
 * @param props.body 출석 코드 로그 리스트 패치 요청 정보 (검색조건/페이징/정렬)
 * @path /attendance/attendanceCodeLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** 출석 코드 로그 리스트 패치 요청 정보 (검색조건/페이징/정렬) */
    body: IAttendanceAttendanceCodeLog.IRequest;
  };
  export type Body = IAttendanceAttendanceCodeLog.IRequest;
  export type Response = IPageAttendanceAttendanceCodeLog;

  export const METADATA = {
    method: "PATCH",
    path: "/attendance/attendanceCodeLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/attendanceCodeLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageAttendanceAttendanceCodeLog =>
    typia.random<IPageAttendanceAttendanceCodeLog>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Attendance_attendance_code_log 단일 이벤트 로그(PK) 상세 조회 API.
 *
 * 이 API는 attendance_attendance_code_log 레코드를 식별자(PK, id)로 조회하는 get 방식 디테일 조회
 * 엔드포인트입니다.
 *
 * 첫 번째로, 이 API는 현장 대시보드·이상 징후 상세 팝업·관리 감사 화면 등에서 단일 출석 코드 이벤트 로그의 세부사항을 조회할 때
 * 사용합니다. 반환 필드는 테이블의 모든 컬럼(code_id, event_type, event_time, actor_id,
 * actor_type, details 등)을 포함해야 하며, 오류 시 404(없는 로그) 및 403(권한 없음) 처리가 필요합니다.
 *
 * 두 번째로, 이 API는 actor_id/actor_type 등으로 인해 polymorphic 액터케이스(teacher, student,
 * admin, system)에 대한 설명이 필요하며, 프론트에서 이를 활용해 적절한 UI를 구성해야 합니다.
 *
 * 세 번째로는 error handling/documentation에서 Prisma 주석의 각각의 컬럼 목적까지 정확히 안내해야 하며,
 * query param 없이 path param id만 필요합니다.
 *
 * DB상의 attendance_attendance_code_log 테이블과 1:1 매핑됩니다.
 *
 * @param props.connection
 * @param props.id 조회 대상 출석 코드 이벤트 로그의 PK(UUID)
 * @path /attendance/attendanceCodeLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** 조회 대상 출석 코드 이벤트 로그의 PK(UUID) */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceAttendanceCodeLog;

  export const METADATA = {
    method: "GET",
    path: "/attendance/attendanceCodeLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/attendanceCodeLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAttendanceCodeLog =>
    typia.random<IAttendanceAttendanceCodeLog>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Attendance_attendance_code_log PK(id) 기반 이벤트 로그 수정/업데이트(put) API.
 *
 * 이 API는 attendance_attendance_code_log 엔터티에서 특정 PK(id)로 식별되는 이벤트 로그의 일부/전체 요소를
 * 수정(전체 대체/PUT)하는 엔드포인트입니다.
 *
 * 실제로 출석 코드 이력은 append-only가 원칙이나, 예외적으로 잘못 기록된 이벤트나 비고 필드(details) 오타 등 수정이
 * 필요할 때 제한적으로 활용됩니다. 수정 가능한 컬럼/제약 사항은 관련 Prisma 테이블 주석을 반드시 따르며, path param id
 * 지정과 함께 변경할 필드를 request body 형태로 구조화해야 합니다.
 *
 * 수정 성공 시 최신 상태 레코드를 반환하고, 권한·유효성 위반 등은 403/422 코드로 반환해야 합니다. 보안·감사 로그 역시 연동되어야
 * 하며, 불가항력 수정 케이스 기록을 위한 감사 로그 연계가 바람직합니다.
 *
 * @param props.connection
 * @param props.id 수정 대상 출석 코드 로그의 PK(UUID)
 * @param props.body 출석 코드 이벤트 로그 수정 정보(details, actor_id 등)
 * @path /attendance/attendanceCodeLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** 수정 대상 출석 코드 로그의 PK(UUID) */
    id: string & tags.Format<"uuid">;

    /** 출석 코드 이벤트 로그 수정 정보(details, actor_id 등) */
    body: IAttendanceAttendanceCodeLog.IUpdate;
  };
  export type Body = IAttendanceAttendanceCodeLog.IUpdate;
  export type Response = IAttendanceAttendanceCodeLog;

  export const METADATA = {
    method: "PUT",
    path: "/attendance/attendanceCodeLogs/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/attendance/attendanceCodeLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAttendanceCodeLog =>
    typia.random<IAttendanceAttendanceCodeLog>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Attendance_attendance_code_log 이벤트 로그(PK) 삭제 API.
 *
 * 이 API는 attendance_attendance_code_log 엔터티의 특정 단일 이벤트 로그(PK, id)를 삭제하는 delete
 * 방식 엔드포인트입니다.
 *
 * 실제 비즈니스 정책에 따라 물리 삭제(hard) 혹은 소프트 삭제 플래그 처리 정책이 적용 가능하며, 삭제 완료 시 200 OK(혹은
 * 204 No Content), 실패 시 404(존재 X), 403(권한 없음) 에러 처리를 명확히 해야 합니다.
 *
 * 모든 삭제는 반드시 해당 id로 식별/검증 후 진행되며, 감사/보안 로그 연동 등 추가 업무플로우와의 연계도 고려할 것. Prisma 주석
 * 및 컬럼 구조 그대로 따름.
 *
 * @param props.connection
 * @param props.id 삭제 대상 출석 코드 이벤트 로그의 PK(UUID)
 * @path /attendance/attendanceCodeLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** 삭제 대상 출석 코드 이벤트 로그의 PK(UUID) */
    id: string & tags.Format<"uuid">;
  };
  export type Response = _null;

  export const METADATA = {
    method: "DELETE",
    path: "/attendance/attendanceCodeLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/attendanceCodeLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): _null =>
    typia.random<_null>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
