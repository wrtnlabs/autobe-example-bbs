import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAttendanceAuditLog } from "../../../structures/IAttendanceAuditLog";
import { IPageIAttendanceAuditLog } from "../../../structures/IPageIAttendanceAuditLog";

/**
 * Insert new audit log record for critical system action (attendance_audit_log
 * table).
 *
 * This endpoint inserts a new critical action/event in the audit log table.
 * Used by the system and privileged actors to record essential/critical changes
 * or accesses for forensic and legal compliance. Required inputs: actor
 * (teacher, student, parent, admin), event type, entity/context, details,
 * outcome, timestamps. Records are append-onlyâ€”there is no support for
 * update/delete for most users after creation (except very limited
 * admin/rectification workflows). Related endpoints: patch for search, get for
 * single, put for limited updates.
 *
 * @param props.connection
 * @param props.body Details for the new audit log entry (actor, event, context,
 *   etc.).
 * @path /attendance/auditLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Details for the new audit log entry (actor, event, context, etc.). */
    body: IAttendanceAuditLog.ICreate;
  };
  export type Body = IAttendanceAuditLog.ICreate;
  export type Response = IAttendanceAuditLog;

  export const METADATA = {
    method: "POST",
    path: "/attendance/auditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/auditLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAuditLog => typia.random<IAttendanceAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Filter and paginate audit logs (attendance_audit_log table).
 *
 * This API enables administrators and auditors to retrieve and paginate through
 * critical action logs (audit trail) as recorded in attendance_audit_log.
 * Filters include event types (policy changes, export, edits), user/role
 * actors, date intervals, classroom, success/failure, and more. This operation
 * fulfills compliance, system monitoring, and post-incident review
 * requirements. Each entry details the actor (teacher, student, parent, admin),
 * the action, affected entity, result, timestamps, and other audit context.
 * Paginated results support bulk review or export. Related endpoints: get for
 * detail, post for creating log entries, put for updating (where allowed),
 * delete.
 *
 * @param props.connection
 * @param props.body Advanced search/filter criteria for audit logs (event type,
 *   actor, date range, etc.).
 * @path /attendance/auditLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Advanced search/filter criteria for audit logs (event type, actor,
     * date range, etc.).
     */
    body: IAttendanceAuditLog.IRequest;
  };
  export type Body = IAttendanceAuditLog.IRequest;
  export type Response = IPageIAttendanceAuditLog;

  export const METADATA = {
    method: "PATCH",
    path: "/attendance/auditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/auditLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIAttendanceAuditLog => typia.random<IPageIAttendanceAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get single audit log event detail by id (attendance_audit_log table).
 *
 * This API returns a single audit log event (such as a critical policy change,
 * export action, user privilege alteration, etc.) by its unique log id. Each
 * audit entry in attendance_audit_log includes action type, actor, classroom
 * context, action details, success/failure, and timestamps. This endpoint
 * supports investigations, compliance review, and detailed auditing in the
 * admin dashboard or by command log. Related endpoints include patch for
 * searching/filtering, post for log creation, put for record corrections, and
 * delete for removal (rarely allowed for audit integrity).
 *
 * @param props.connection
 * @param props.id Unique identifier for the audit log entry to retrieve.
 * @path /attendance/auditLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier for the audit log entry to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceAuditLog;

  export const METADATA = {
    method: "GET",
    path: "/attendance/auditLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/auditLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAuditLog => typia.random<IAttendanceAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update specific audit log entry by id (attendance_audit_log table).
 *
 * This API updates the details of an existing audit log entry, such as error
 * correction, clarifying action details, or annotating results. Action is
 * reserved for system-level or privileged/lead compliance actors. Only atomic
 * properties are updatable; action must itself be logged. Editing audit logs is
 * rare and regulated. If record does not exist, a not-found error is returned.
 * Related endpoints: patch for search, get for detail, post for creation,
 * delete for removal (rarely allowed).
 *
 * @param props.connection
 * @param props.id Unique id of audit log record to edit.
 * @param props.body Fields to update in the audit log record.
 * @path /attendance/auditLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique id of audit log record to edit. */
    id: string & tags.Format<"uuid">;

    /** Fields to update in the audit log record. */
    body: IAttendanceAuditLog.IUpdate;
  };
  export type Body = IAttendanceAuditLog.IUpdate;
  export type Response = IAttendanceAuditLog;

  export const METADATA = {
    method: "PUT",
    path: "/attendance/auditLogs/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/attendance/auditLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAuditLog => typia.random<IAttendanceAuditLog>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete specific audit log entry by id (attendance_audit_log table).
 *
 * This API permanently deletes an audit log record. Only system administrators
 * or legal compliance officials may use this endpoint, and the deletion is
 * itself audited elsewhere. Typical scenarios: redaction upon valid legal
 * request, expiration under retention policy, or correction of mislogged
 * records. Related endpoints: patch for search, get for detail, post for
 * creation, put for limited edits.
 *
 * @param props.connection
 * @param props.id Unique id for the audit log record to delete.
 * @path /attendance/auditLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique id for the audit log record to delete. */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/attendance/auditLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/auditLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
