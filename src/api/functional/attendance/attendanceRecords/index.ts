import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAttendanceAttendanceRecord } from "../../../structures/IAttendanceAttendanceRecord";
import { IPageAttendanceAttendanceRecord } from "../../../structures/IPageAttendanceAttendanceRecord";

/**
 * Creates a new attendance submission in attendance_attendance_record
 * (student/teacher event log).
 *
 * This POST endpoint creates a new student-attendance event in
 * attendance_attendance_record, with normalized references to student, teacher,
 * class, method, and (optionally) code. Used by students submitting attendance,
 * teachers adding/adjusting, or admin bulk-import. All values strictly
 * validated (auth/account role checks, referential integrity, time window,
 * duplicate protection). Returns created record (with all fields filled, for
 * notification/audit UX). Linked downstream to notification/event flows and
 * stats/dashboard. Fails with 409 (duplicate), 422 (invalid), 401/403
 * (permission).
 *
 * @param props.connection
 * @param props.body Input/new attendance submission to be inserted (student,
 *   class, time, method, code/status, etc).
 * @path /attendance/attendanceRecords
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Input/new attendance submission to be inserted (student, class, time,
     * method, code/status, etc).
     */
    body: IAttendanceAttendanceRecord.ICreate;
  };
  export type Body = IAttendanceAttendanceRecord.ICreate;
  export type Response = IAttendanceAttendanceRecord;

  export const METADATA = {
    method: "POST",
    path: "/attendance/attendanceRecords",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/attendanceRecords";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAttendanceRecord =>
    typia.random<IAttendanceAttendanceRecord>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Gets a paginated/searchable list of attendance records from
 * attendance_attendance_record.
 *
 * This PATCH endpoint provides a filtered, paginated list of attendance records
 * (attendance_attendance_record) for dashboards/statistical reporting and
 * export. Allows criteria such as classroom, date range, student, teacher,
 * method, or attendance status. Supports search, pagination (offset/limit), and
 * sort order. Especially useful for teacher/admin viewing of class-wide or
 * date-wide attendance, anomaly detection, parent notification preparation, and
 * export flows (e.g., Excel/CSV). Returned data includes basic metadata for
 * each matching record as well as pagination summary. Endpoint requires
 * authentication (admin/teacher/parent/student with relevant school/class
 * role). Validation errors or unauthorized queries return 401 or 422. Each
 * attendance record entry includes links to its student, class, teacher,
 * method, and code (where applicable).
 *
 * @param props.connection
 * @param props.body Filtering/search, pagination, and sort request for
 *   attendance_attendance_record list retrieval.
 * @path /attendance/attendanceRecords
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Filtering/search, pagination, and sort request for
     * attendance_attendance_record list retrieval.
     */
    body: IAttendanceAttendanceRecord.IRequest;
  };
  export type Body = IAttendanceAttendanceRecord.IRequest;
  export type Response = IPageAttendanceAttendanceRecord;

  export const METADATA = {
    method: "PATCH",
    path: "/attendance/attendanceRecords",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/attendanceRecords";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageAttendanceAttendanceRecord =>
    typia.random<IPageAttendanceAttendanceRecord>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieves detail for an attendance_attendance_record by id.
 *
 * This GET endpoint retrieves all details of a single attendance record from
 * attendance_attendance_record, given a record id. Used for drill-down
 * (dashboard, parent/teacher audit), correction request, or status display.
 * Requires access rights to the event (auth enforcement:
 * teacher/admin/student/parent as mapped). Returns structured object with
 * student, classroom, teacher, method, status, codes, check-in time, exception
 * details, and related notification/anomaly info as needed. Handles 401 (auth
 * failure), 403 (not permitted), 404 (no such record) as errors.
 *
 * @param props.connection
 * @param props.id The id of the attendance_attendance_record (UUID) to
 *   retrieve.
 * @path /attendance/attendanceRecords/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** The id of the attendance_attendance_record (UUID) to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceAttendanceRecord;

  export const METADATA = {
    method: "GET",
    path: "/attendance/attendanceRecords/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/attendanceRecords/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAttendanceRecord =>
    typia.random<IAttendanceAttendanceRecord>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Updates (replaces) an attendance_attendance_record by id.
 *
 * This PUT endpoint updates/modifies an existing attendance_attendance_record,
 * allowing all modifiable fields to be set. Essential for teacher-side
 * corrections, admin audit replay, or student-submitted corrections. Validates
 * record existence, links (student, teacher, method, code), referential
 * integrity, and applies concurrency protection. Returns updated object after
 * mutation. Fails 404 (no record), 409 (conflict), 422 (validation), 401/403
 * (auth). Linked to audit/notification/statistics. Limited to actors with
 * access rights (student/teacher/parent/admin by attendance record).
 *
 * @param props.connection
 * @param props.id The id (UUID) of the attendance record to update.
 * @param props.body Updated/entire attendance record info (replaces/prunes
 *   atomic fields) for attendance_attendance_record.
 * @path /attendance/attendanceRecords/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** The id (UUID) of the attendance record to update. */
    id: string & tags.Format<"uuid">;

    /**
     * Updated/entire attendance record info (replaces/prunes atomic fields)
     * for attendance_attendance_record.
     */
    body: IAttendanceAttendanceRecord.IUpdate;
  };
  export type Body = IAttendanceAttendanceRecord.IUpdate;
  export type Response = IAttendanceAttendanceRecord;

  export const METADATA = {
    method: "PUT",
    path: "/attendance/attendanceRecords/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/attendance/attendanceRecords/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAttendanceRecord =>
    typia.random<IAttendanceAttendanceRecord>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Deletes an attendance_attendance_record (atomic attendance event log) by id.
 *
 * This DELETE endpoint permanently deletes or flags as deleted a specific
 * attendance_attendance_record identified by uuid. Only actors with explicit
 * permission (teacher/admin, or self student/parent with authority) may invoke.
 * All deletions are evidence tracked in audit log (who, when, why, etc).
 * Removes main record and updates or deletes related notification/stat counters
 * as per referential integrity. Used for audit/data hygiene/fixes. Fails 404
 * (not found), 403 (no permission), 401 (not authenticated), 409 (ref
 * conflict). Returns 204 No Content on success.
 *
 * @param props.connection
 * @param props.id UUID of attendance_attendance_record to delete.
 * @path /attendance/attendanceRecords/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of attendance_attendance_record to delete. */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/attendance/attendanceRecords/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/attendanceRecords/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
