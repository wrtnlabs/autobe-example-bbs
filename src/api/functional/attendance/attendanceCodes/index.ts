import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAttendanceAttendanceCode } from "../../../structures/IAttendanceAttendanceCode";
import { IPageAttendanceAttendanceCode } from "../../../structures/IPageAttendanceAttendanceCode";

/**
 * Issues/adds a new code row in attendance_attendance_code table
 * (class/teacher/code distribution).
 *
 * This POST endpoint creates a new attendance_attendance_code object and
 * returns it. For automatic/manual code distribution in teacher
 * dashboard/automation, only teacher/admin roles can issue. Required
 * parameters: class, code value, issue/expire times, active flag, creator
 * teacher. Strict reference/constraint check: target class, creator,
 * conflict/duplicate, valid code string, time window. Successful creation
 * returns code object for display/sharing. Triggers code created log and audit
 * snapshot. Errors include 409 (duplicate/collision), 422 (constraint), 401/403
 * (no permission). Always audit trail.
 *
 * @param props.connection
 * @param props.body Attributes for new attendance code (class, code string,
 *   issuer, active, dates).
 * @path /attendance/attendanceCodes
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Attributes for new attendance code (class, code string, issuer,
     * active, dates).
     */
    body: IAttendanceAttendanceCode.ICreate;
  };
  export type Body = IAttendanceAttendanceCode.ICreate;
  export type Response = IAttendanceAttendanceCode;

  export const METADATA = {
    method: "POST",
    path: "/attendance/attendanceCodes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/attendanceCodes";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAttendanceCode => typia.random<IAttendanceAttendanceCode>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieves a paginated/filterable list of attendance codes
 * (attendance_attendance_code) for dashboards/audit.
 *
 * This endpoint provides a paginated, sortable, and searchable list of
 * attendance codes (attendance_attendance_code) based on filter criteria
 * supplied in the request body. Used in teacher dashboards to view issued
 * codes, for controller audits, or to check for active code conflicts/session
 * history. Filters include teacher id, classroom id, active flag, window
 * constraint (issue/expire date), etc. Only accessible to actors with code
 * access rights: teacher, admin, etc. Returns paginated result with total
 * count, current page, and codes info for UI. Validation: 401 (no token), 403
 * (no permission), 422 (bad parameters). Linked to audit log for search/export
 * evidence.
 *
 * @param props.connection
 * @param props.body Code list filtering/search and pagination/sort request for
 *   attendance_attendance_code.
 * @path /attendance/attendanceCodes
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Code list filtering/search and pagination/sort request for
     * attendance_attendance_code.
     */
    body: IAttendanceAttendanceCode.IRequest;
  };
  export type Body = IAttendanceAttendanceCode.IRequest;
  export type Response = IPageAttendanceAttendanceCode;

  export const METADATA = {
    method: "PATCH",
    path: "/attendance/attendanceCodes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/attendanceCodes";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageAttendanceAttendanceCode =>
    typia.random<IPageAttendanceAttendanceCode>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Fetches a detail attendance_attendance_code entity by UUID.
 *
 * GET detail of an attendance_attendance_code by id. Requires authorized user
 * (teacher, admin, etc). Returns all code attributes, including string,
 * expiration, classroom/teacher (dereferenced/embedded). Validation: 404 (code
 * not found), 401 (unauthenticated) or 403 (insufficient role). Used for
 * validation/audit, code value UX. Fails on non-existing code or permission
 * error. Result can drive UX, report, or security export.
 *
 * @param props.connection
 * @param props.id Target attendance_attendance_code's ID (UUID) to fetch.
 * @path /attendance/attendanceCodes/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target attendance_attendance_code's ID (UUID) to fetch. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceAttendanceCode;

  export const METADATA = {
    method: "GET",
    path: "/attendance/attendanceCodes/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/attendanceCodes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAttendanceCode => typia.random<IAttendanceAttendanceCode>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Updates/replaces fields in attendance_attendance_code (by id, all atomic
 * fields).
 *
 * This PUT endpoint modifies an existing attendance_attendance_code identified
 * by id. Used for teacher/admin code management: extend, expire, fix. Requires
 * referential and uniqueness constraint checks on all fields and references
 * (classroom/teacher), code string/active/expiry. Returns updated code entity.
 * On error: 404 (not found), 409 (conflict), 401/403 (perms), 422
 * (constraint/bad data). Always triggers audit log and downstream refresh
 * events. Used in teacher dashboards, code admin panels.
 *
 * @param props.connection
 * @param props.id UUID of attendance_attendance_code entity to update/replace.
 * @param props.body New/updated attributes (classroom, code, time, flag,
 *   teacher) to overwrite attendance code.
 * @path /attendance/attendanceCodes/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** UUID of attendance_attendance_code entity to update/replace. */
    id: string & tags.Format<"uuid">;

    /**
     * New/updated attributes (classroom, code, time, flag, teacher) to
     * overwrite attendance code.
     */
    body: IAttendanceAttendanceCode.IUpdate;
  };
  export type Body = IAttendanceAttendanceCode.IUpdate;
  export type Response = IAttendanceAttendanceCode;

  export const METADATA = {
    method: "PUT",
    path: "/attendance/attendanceCodes/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/attendance/attendanceCodes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAttendanceCode => typia.random<IAttendanceAttendanceCode>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Removes (invalidates or deletes) an attendance_attendance_code by id.
 *
 * DELETE endpoint for attendance_attendance_code. Permits code
 * invalidation/removal when code is expired, revoked, or mistaken. Only
 * teacher/admin actor may issue request, strict by code id. All permission and
 * reference errors handled (404: no code; 401/403: no right). Removes code
 * entity (or marks as inactive/blocklisted in DB). Cascade policy (if any) on
 * related logs/attendance records handled per referential integrity. On
 * successful deletion, code invalid and no longer distributed/usable for
 * attendance. Returns 204 No Content.
 *
 * @param props.connection
 * @param props.id UUID of attendance_attendance_code to delete.
 * @path /attendance/attendanceCodes/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of attendance_attendance_code to delete. */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/attendance/attendanceCodes/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/attendanceCodes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
