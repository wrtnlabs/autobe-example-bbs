import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAttendanceNotification } from "../../../structures/IAttendanceNotification";
import { IPageAttendanceNotification } from "../../../structures/IPageAttendanceNotification";

/**
 * Create a new attendance notification event (attendance_notification table).
 *
 * This API operation is used to post (create) a new attendance notification in
 * the attendance_notification table, reflecting an event that is to trigger
 * communication toward guardians (parents), admins, or other monitoring roles.
 * The operation requires the caller to specify all mandatory atomic
 * fields—attendance_record_id (what event this is for), student_id (who it
 * pertains to), classroom_id (which group/class), event_type (present, absent,
 * late, leave, etc.), triggered_at (when the notification event was generated),
 * and message_template (the canonical or customized message for the
 * notification). Optionally, teacher_id can be specified if the notification
 * resulted from a teacher's manual action. This endpoint enforces normalized
 * storage (never aggregates per delivery channel) and is directly linked via FK
 * to notification histories and channels for actual delivery attempts/logging.
 * Only authorized users (teachers for their students; admins for their
 * school/unit) can invoke this function. Validation includes referential
 * integrity checks for all provided IDs, input length/range validation (e.g.,
 * for message template), and legal status checks (e.g., no duplicate for the
 * same attendance record and event_type). Error handling covers privilege
 * errors, referential integrity failures, or unexpected system states. Upon
 * success, the created notification is returned; automated delivery to channels
 * may follow as a background job or be explicitly triggered via secondary
 * endpoints.
 *
 * @param props.connection
 * @param props.body New notification event atomic info, referencing student,
 *   attendance record, classroom, message, and optional teacher.
 * @path /attendance/notifications
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * New notification event atomic info, referencing student, attendance
     * record, classroom, message, and optional teacher.
     */
    body: IAttendanceNotification.ICreate;
  };
  export type Body = IAttendanceNotification.ICreate;
  export type Response = IAttendanceNotification;

  export const METADATA = {
    method: "POST",
    path: "/attendance/notifications",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/notifications";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceNotification => typia.random<IAttendanceNotification>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Attendance_notification 마스터 다수 알림 이벤트 패치 리스트 조회(검색/페이징 지원).
 *
 * 이 API는 attendance_notification 엔터티의 여러 행을 조건(학생id, classroom, event_type, 기간
 * 등)과 페이징/정렬과 함께 리스트(패치)로 조회하는 엔드포인트입니다.
 *
 * 주요 용도는 교사 대시보드의 알림 내역, 학부모의 자녀 출결 알림 현황 열람, 관리자의 전체 이벤트 트레이스 등이며, 검색 필드는
 * Prisma 스키마 컬럼을 기준으로 학교/클래스/학생/발송시간/이벤트 등 다각도로 노출해야 합니다.
 *
 * 반환 구조는 IPageAttendanceNotification 같이 표준 페이징(요약 정보+데이터) 방식이 이상적이고, data와
 * total, page 등의 키를 포함합니다. 구체적 컬럼/조건 등은 Prisma 모델 주석에 명시된 용도·구조를 준수합니다.
 *
 * @param props.connection
 * @param props.body 알림 이벤트 마스터 리스트 패치 요청 정보 (검색조건/페이징 등)
 * @path /attendance/notifications
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** 알림 이벤트 마스터 리스트 패치 요청 정보 (검색조건/페이징 등) */
    body: IAttendanceNotification.IRequest;
  };
  export type Body = IAttendanceNotification.IRequest;
  export type Response = IPageAttendanceNotification;

  export const METADATA = {
    method: "PATCH",
    path: "/attendance/notifications",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/notifications";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageAttendanceNotification =>
    typia.random<IPageAttendanceNotification>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Fetch a single attendance notification event by ID (attendance_notification
 * table).
 *
 * This API operation fetches a single attendance notification based on its
 * system-unique identifier, as defined in the attendance_notification table.
 * The notification contains the core event data: which student and classroom it
 * references, who (if any) triggered the event (such as a teacher), the event
 * type (present, absent, late, leave), the exact time it was triggered, and the
 * associated message template intended for parent/authority communication. The
 * attendance_notification record is strictly normalized, referencing atomically
 * the relevant attendance record, student, teacher (if applicable), and
 * classroom, without containing denormalized or aggregated data from any join.
 * The API enforces strict access controls so that: 1) Teachers can only fetch
 * notifications issued for their own classes/students; 2) Parents can only
 * access notifications regarding their child(ren); 3) Administrators and
 * authorized officials may retrieve any notification within their jurisdiction.
 * The API robustly returns appropriate error responses for requests for records
 * outside the authorized scope, for deleted/expired IDs, or malformed requests.
 * Related notification history and channel information for this notification
 * are accessed via their own endpoints but may be referenced in the response.
 * This endpoint is often used in parent-facing notification detail screens,
 * admin audits, or incident response workflows.
 *
 * @param props.connection
 * @param props.id Target notification's unique identifier (UUID).
 * @path /attendance/notifications/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target notification's unique identifier (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceNotification;

  export const METADATA = {
    method: "GET",
    path: "/attendance/notifications/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/notifications/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceNotification => typia.random<IAttendanceNotification>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing attendance notification event (attendance_notification).
 *
 * This API operation allows updating a single attendance notification's atomic
 * event fields, as represented in the attendance_notification table. The
 * operation requires the caller to specify the notification ID (UUID, path
 * parameter) and a payload (normalized and atomic) specifying only the fields
 * to be updated—such as event_type, triggered_at, message_template, teacher_id,
 * or classroom_id. Restrictions are enforced so that delivery attempts, channel
 * history, and delivery status are immutable via this endpoint; changes here
 * affect only the master event record's content (used for subsequent or
 * corrected notifications). Strict referential integrity must be checked for
 * all updated FKs, and policy-enforced constraints are applied for event_type
 * and allowed editing windows (e.g., after delivery, editing may be
 * restricted). Role-based permissions dictate that only the originating teacher
 * (for their own classes) or admins (systemwide) may update notification
 * events, with all changes appended to the audit log. Proper error responses
 * are returned for privilege failures, missing/invalid IDs, or business logic
 * violations. The final returned data includes the full updated notification
 * event, matching atomic schema.
 *
 * @param props.connection
 * @param props.id Target notification's unique identifier (UUID) to update.
 * @param props.body Fields for attendance notification update (atomic, only
 *   updatable fields allowed).
 * @path /attendance/notifications/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target notification's unique identifier (UUID) to update. */
    id: string & tags.Format<"uuid">;

    /**
     * Fields for attendance notification update (atomic, only updatable
     * fields allowed).
     */
    body: IAttendanceNotification.IUpdate;
  };
  export type Body = IAttendanceNotification.IUpdate;
  export type Response = IAttendanceNotification;

  export const METADATA = {
    method: "PUT",
    path: "/attendance/notifications/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/attendance/notifications/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceNotification => typia.random<IAttendanceNotification>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete an attendance notification event by ID (attendance_notification).
 *
 * This API removes an atomic attendance notification event from the
 * attendance_notification table. Deletion is by UUID, and the endpoint enforces
 * referential checks (ensuring that if there are dependent notification history
 * records, the request is rejected unless policies allow cascading deletes or
 * soft deletion). The endpoint returns success/failure status upon completion,
 * and any removal is logged for compliance tracing. Typically, only admins or
 * owning teachers may remove records, and only if not critical to
 * operational/audit chains (if so, must mark as inactive rather than delete).
 * Errors include not found, permission denied, or foreign key constraint
 * violations. This is commonly invoked for data correction, legal requests, or
 * duplicate error clean-up by teachers or system admins.
 *
 * @param props.connection
 * @param props.id Target notification's unique identifier (UUID) for deletion.
 * @path /attendance/notifications/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target notification's unique identifier (UUID) for deletion. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceNotification.IDeleteResponse;

  export const METADATA = {
    method: "DELETE",
    path: "/attendance/notifications/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/notifications/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceNotification.IDeleteResponse =>
    typia.random<IAttendanceNotification.IDeleteResponse>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
