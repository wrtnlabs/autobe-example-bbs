import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAttendanceStatsDaily } from "../../../../structures/IAttendanceStatsDaily";
import { IPageIAttendanceStatsDaily } from "../../../../structures/IPageIAttendanceStatsDaily";

/**
 * Creates a new attendance_stats_daily record.
 *
 * Inserts a new attendance_stats_daily record. The request body (see schema)
 * must specify which classroom, school, and day, and the daily counts for
 * present/late/absent/early_leave. Insertions are strictly controlled: cannot
 * duplicate a (classroom, day) pair and must honor all atomic normalization
 * rules.
 *
 * Role check: only admins or system cron jobs can create stats directly
 * (teacher dashboards usually rely on automatic aggregation).
 *
 * Error handling on duplicate entry, invalid FKs, or missing data is critical.
 *
 * Linked operations: stats update, daily summary dashboard refresh, etc.
 *
 * @param props.connection
 * @param props.body New daily classroom/school summary statistics to add.
 * @path /attendance/stats/daily
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** New daily classroom/school summary statistics to add. */
    body: IAttendanceStatsDaily.ICreate;
  };
  export type Body = IAttendanceStatsDaily.ICreate;
  export type Response = IAttendanceStatsDaily;

  export const METADATA = {
    method: "POST",
    path: "/attendance/stats/daily",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/stats/daily";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceStatsDaily => typia.random<IAttendanceStatsDaily>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Returns a paginated list of attendance_stats_daily records matching the
 * query.
 *
 * This endpoint enables clients (dashboard/reporting UIs, admin panels) to
 * query one or more attendance_stats_daily records filtered by classroom,
 * school, time-range, etc., with optional pagination and sorting. According to
 * the schema, response includes day-level present/late/absent/leave counts and
 * references to relevant classroom/school.
 *
 * Security: All users may query, but results are filtered (teachers/parents see
 * only relevant classes, admins have broader access).
 *
 * Validation: Ensures only valid filters are processed and controls size of
 * result set.
 *
 * Related: result set powers dashboards, calendar exports, and trend analysis
 * for both teachers and administrators.
 *
 * @param props.connection
 * @param props.body Query/filtering/search conditions for
 *   attendance_stats_daily listing.
 * @path /attendance/stats/daily
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Query/filtering/search conditions for attendance_stats_daily listing. */
    body: IAttendanceStatsDaily.IRequest;
  };
  export type Body = IAttendanceStatsDaily.IRequest;
  export type Response = IPageIAttendanceStatsDaily;

  export const METADATA = {
    method: "PATCH",
    path: "/attendance/stats/daily",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/stats/daily";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIAttendanceStatsDaily => typia.random<IPageIAttendanceStatsDaily>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Returns details for a specific attendance_stats_daily record.
 *
 * Retrieves a specific attendance_stats_daily row by its unique identifier. The
 * response includes all fields (present, late, absent, early_leave counts) and
 * references (classroom, school, day) as described in the schema. Authorization
 * checks filter access to only allowed users per classroom/school.
 *
 * Errors include not found, permission denied, or invalid id.
 *
 * @param props.connection
 * @param props.id Target day-level stats record's ID (UUID).
 * @path /attendance/stats/daily/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target day-level stats record's ID (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceStatsDaily;

  export const METADATA = {
    method: "GET",
    path: "/attendance/stats/daily/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/stats/daily/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceStatsDaily => typia.random<IAttendanceStatsDaily>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Updates a specific attendance_stats_daily record.
 *
 * Updates a day's stats summary (present/late/absent/leave counts) or the
 * relevant classroom or school IDs. The operation checks for dupe constraints
 * (unique (classroom, day)), enforces permission (admin-only), and creates an
 * audit trail.
 *
 * Input validation: only valid status counts, proper classroom/school
 * references, and correct day format (YYYY-MM-DD) allowed.
 *
 * Related: May be called from dashboards, error correction flows, or stats sync
 * jobs.
 *
 * @param props.connection
 * @param props.id Target stats_daily record's ID (UUID).
 * @param props.body Columns to update for the day-level stats row.
 * @path /attendance/stats/daily/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target stats_daily record's ID (UUID). */
    id: string & tags.Format<"uuid">;

    /** Columns to update for the day-level stats row. */
    body: IAttendanceStatsDaily.IUpdate;
  };
  export type Body = IAttendanceStatsDaily.IUpdate;
  export type Response = IAttendanceStatsDaily;

  export const METADATA = {
    method: "PUT",
    path: "/attendance/stats/daily/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/attendance/stats/daily/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceStatsDaily => typia.random<IAttendanceStatsDaily>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Deletes an attendance_stats_daily record specified by ID.
 *
 * Removes a stats_daily record by ID (UUID). Only super-admin/system users
 * allowed to perform this action, as it can affect dashboards, reports, and
 * exports. Will check for referential integrity (e.g., don't orphan summaries
 * needed by reporting).
 *
 * All deletes should be auditable, with soft delete preferred unless hard
 * delete is required (for data retention/GDPR-period expiration, etc.). Errors
 * on FK violation, not found, or permission denied are to be handled as per
 * standard convention.
 *
 * Linked to: data correction, reporting, record retention enforcement.
 *
 * @param props.connection
 * @param props.id Target daily stats record's ID (UUID).
 * @path /attendance/stats/daily/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target daily stats record's ID (UUID). */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/attendance/stats/daily/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/stats/daily/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
