import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAttendanceStatsStudentSummary } from "../../../../structures/IAttendanceStatsStudentSummary";
import { IPageIAttendanceStatsStudentSummary } from "../../../../structures/IPageIAttendanceStatsStudentSummary";

/**
 * Creates a new attendance_stats_student_summary record.
 *
 * Adds a summary row for a specific student, classroom, and period with
 * associated present/late/absent/leave totals as per the schema. It must
 * enforce uniqueness by (student, period_start, period_end), validate all
 * references, and allow only staff/admin users to create directly (student
 * summaries are normally computed automatically).
 *
 * Error checks: references valid, period-format validated, no duplicate summary
 * record for the same student/period/subject.
 *
 * May be related to mass import/refresh, or correction workflows/workarounds
 * for data issue remediation.
 *
 * @param props.connection
 * @param props.body New period summary for a student, classroom, and period.
 * @path /attendance/stats/studentSummaries
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** New period summary for a student, classroom, and period. */
    body: IAttendanceStatsStudentSummary.ICreate;
  };
  export type Body = IAttendanceStatsStudentSummary.ICreate;
  export type Response = IAttendanceStatsStudentSummary;

  export const METADATA = {
    method: "POST",
    path: "/attendance/stats/studentSummaries",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/stats/studentSummaries";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceStatsStudentSummary =>
    typia.random<IAttendanceStatsStudentSummary>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Returns a paginated list of attendance_stats_student_summary records.
 *
 * Query for a list of student summary stats records with search, filtering, and
 * pagination. Response includes period-based totals for present, late, absent,
 * early_leave by student and classroom ref, as described in the schema and
 * requirements. Supports drilldown for dashboards, risk assessments, and
 * progress review by admin/teacher/parent.
 *
 * Security: filters output to allowed users (e.g., teachers see only their
 * students, parents only children), with paging/size control as per policy.
 *
 * May aggregate over semesters, months, or user-defined periods.
 *
 * @param props.connection
 * @param props.body Search, filtering, and pagination criteria for retrieving
 *   student summaries.
 * @path /attendance/stats/studentSummaries
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Search, filtering, and pagination criteria for retrieving student
     * summaries.
     */
    body: IAttendanceStatsStudentSummary.IRequest;
  };
  export type Body = IAttendanceStatsStudentSummary.IRequest;
  export type Response = IPageIAttendanceStatsStudentSummary;

  export const METADATA = {
    method: "PATCH",
    path: "/attendance/stats/studentSummaries",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/stats/studentSummaries";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIAttendanceStatsStudentSummary =>
    typia.random<IPageIAttendanceStatsStudentSummary>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Returns details about a specific attendance_stats_student_summary record.
 *
 * Get the details for one summary stats record by its UUID. Response includes
 * student, classroom, period, and counters as described in schema for
 * dashboards and analysis/progress workflows. Authorization and validation per
 * role, record existence, etc. Errors handled for not found, not permitted,
 * etc.
 *
 * @param props.connection
 * @param props.id Target student summary stats record's ID (UUID).
 * @path /attendance/stats/studentSummaries/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target student summary stats record's ID (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceStatsStudentSummary;

  export const METADATA = {
    method: "GET",
    path: "/attendance/stats/studentSummaries/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/stats/studentSummaries/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceStatsStudentSummary =>
    typia.random<IAttendanceStatsStudentSummary>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a specific student summary statistics record
 * (attendance_stats_student_summary).
 *
 * This endpoint updates a single student summary statistics record in the
 * attendance_stats_student_summary table.
 *
 * Permission is limited to authorized roles (typically admins or teachers). It
 * strictly follows the database's 3NF policy, ensuring that no derived or
 * denormalized data is introduced/injected -- the update applies only to the
 * canonical summary for the student and period. Every update must reference the
 * audit policy, meaning changes must be tracked by audit logs for compliance
 * and traceability.
 *
 * Validation ensures the target student exists, the period is valid, and all
 * summary data (such as present, late, absent, early_leave counts) adheres to
 * integrity rules. The system rejects updates that would create duplicate
 * (student_id, period_start, period_end) records. If the summary statistics
 * need to be recalculated (e.g., after correcting individual records), this
 * endpoint also refreshes the total fields.
 *
 * Automatic update timestamps enable downstream dashboards to refresh in
 * near-real time. If the update leads to any abnormal pattern detected,
 * relevant hooks for abnormal log insertion are triggered.
 *
 * @param props.connection
 * @param props.id UUID of the student summary statistics record to update.
 * @param props.body The updated data for the student summary statistics record.
 * @path /attendance/stats/studentSummaries/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** UUID of the student summary statistics record to update. */
    id: string & tags.Format<"uuid">;

    /** The updated data for the student summary statistics record. */
    body: IAttendanceStatsStudentSummary.IUpdate;
  };
  export type Body = IAttendanceStatsStudentSummary.IUpdate;
  export type Response = IAttendanceStatsStudentSummary;

  export const METADATA = {
    method: "PUT",
    path: "/attendance/stats/studentSummaries/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/attendance/stats/studentSummaries/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceStatsStudentSummary =>
    typia.random<IAttendanceStatsStudentSummary>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a student summary stats record (attendance_stats_student_summary).
 *
 * This endpoint deletes (removes) a student summary statistics record from the
 * attendance_stats_student_summary table for a given ID.
 *
 * Only users with admin or high-level teacher privileges are authorized to
 * perform the deletion. Every deletion action is logged in the audit log for
 * full system compliance, supporting incident investigation or administrative
 * rollback if required. The endpoint strictly deletes by the canonical primary
 * key (id) and enforces referential integrity: deletion is blocked if summary
 * records are referenced elsewhere or would violate integrity constraints.
 *
 * Complies with data retention policies as per system requirements: soft-delete
 * policies or archiving may be applied at the application/business logic layer
 * but are not detailed here. System provides appropriate error messages for not
 * found, forbidden, or integrity constraint violations.
 *
 * @param props.connection
 * @param props.id UUID of the student summary statistics record to delete.
 * @path /attendance/stats/studentSummaries/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of the student summary statistics record to delete. */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/attendance/stats/studentSummaries/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/stats/studentSummaries/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
