import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAttendanceStatsAbnormalLog } from "../../../../structures/IAttendanceStatsAbnormalLog";
import { IPageIAttendanceStatsAbnormalLog } from "../../../../structures/IPageIAttendanceStatsAbnormalLog";

/**
 * Create a new abnormal attendance log record (attendance_stats_abnormal_log).
 *
 * This endpoint creates a new abnormal attendance log record in the
 * attendance_stats_abnormal_log table.
 *
 * Action is restricted to admin or teacher roles. All record fields must comply
 * with referential/integrity checks: e.g., referenced attendance record and
 * student must exist, anomaly type valid, etc. Used as part of review
 * dashboard, manual flagging, or in support of anomaly detection features.
 * Creation of a log triggers downstream hooks (anomaly notification, dashboard
 * widgets).
 *
 * Audit log is created to track who/what triggered each new anomaly event.
 * Returns the newly inserted abnormal log record for further review/action.
 *
 * @param props.connection
 * @param props.body Data to insert as a new abnormal log record.
 * @path /attendance/stats/abnormalLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Data to insert as a new abnormal log record. */
    body: IAttendanceStatsAbnormalLog.ICreate;
  };
  export type Body = IAttendanceStatsAbnormalLog.ICreate;
  export type Response = IAttendanceStatsAbnormalLog;

  export const METADATA = {
    method: "POST",
    path: "/attendance/stats/abnormalLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/stats/abnormalLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceStatsAbnormalLog =>
    typia.random<IAttendanceStatsAbnormalLog>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List abnormal attendance logs with filter/search
 * (attendance_stats_abnormal_log).
 *
 * This endpoint returns a filtered, ordered list of abnormal attendance log
 * records from attendance_stats_abnormal_log (suspicious/corrected/flagged
 * attendance events over a period/class/student).
 *
 * Filters/search parameters are provided in the request body: e.g., by student,
 * class, anomaly type, period.
 *
 * Permissions restricted to admin and teacher roles: only data matching user
 * privileges are returned. Validation checks search parameter validity and page
 * constraints.
 *
 * The response is a list or paginated structure suitable for rendering
 * dashboard anomaly widgets, reports, or audit review. System may apply
 * additional business filters (e.g., open/closed only) as per request.
 *
 * @param props.connection
 * @param props.body Search criteria for listing abnormal attendance log
 *   records.
 * @path /attendance/stats/abnormalLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search criteria for listing abnormal attendance log records. */
    body: IAttendanceStatsAbnormalLog.IRequest;
  };
  export type Body = IAttendanceStatsAbnormalLog.IRequest;
  export type Response = IPageIAttendanceStatsAbnormalLog;

  export const METADATA = {
    method: "PATCH",
    path: "/attendance/stats/abnormalLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/stats/abnormalLogs";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIAttendanceStatsAbnormalLog =>
    typia.random<IPageIAttendanceStatsAbnormalLog>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get details of a specific abnormal attendance log record
 * (attendance_stats_abnormal_log).
 *
 * This endpoint retrieves the full details for a specific abnormal attendance
 * log record from attendance_stats_abnormal_log by id (UUID).
 *
 * Only accessible to authorized admin/teacher users. All event metadata,
 * detection rule, anomaly type, and work status are returned, enabling
 * corrective action, annotation, or further review. Not found errors are
 * possible if ID does not exist or access is disallowed. Audit logs may record
 * this access for compliance/audit purposes.
 *
 * @param props.connection
 * @param props.id UUID of the abnormal log record to retrieve.
 * @path /attendance/stats/abnormalLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** UUID of the abnormal log record to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceStatsAbnormalLog;

  export const METADATA = {
    method: "GET",
    path: "/attendance/stats/abnormalLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/stats/abnormalLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceStatsAbnormalLog =>
    typia.random<IAttendanceStatsAbnormalLog>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a specific abnormal attendance log record
 * (attendance_stats_abnormal_log).
 *
 * This endpoint updates an abnormal attendance log record for a specified id in
 * the attendance_stats_abnormal_log table.
 *
 * Only accessible to admin/teacher users with appropriate privileges.
 * Updateable fields may include status (open, closed, in_review), anomaly
 * description/rule, associated admin, or note fields. All changes are recorded
 * in an audit log for compliance. Input validation ensures updated fields
 * adhere to normalization/integrity rules and that referenced entities exist
 * (e.g., attendance record, student).
 *
 * Returns the updated abnormal log record with the full detailed view for
 * dashboards or downstream alerting.
 *
 * @param props.connection
 * @param props.id UUID of the abnormal log record to update.
 * @param props.body Fields to update in the abnormal log record.
 * @path /attendance/stats/abnormalLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** UUID of the abnormal log record to update. */
    id: string & tags.Format<"uuid">;

    /** Fields to update in the abnormal log record. */
    body: IAttendanceStatsAbnormalLog.IUpdate;
  };
  export type Body = IAttendanceStatsAbnormalLog.IUpdate;
  export type Response = IAttendanceStatsAbnormalLog;

  export const METADATA = {
    method: "PUT",
    path: "/attendance/stats/abnormalLogs/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/attendance/stats/abnormalLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceStatsAbnormalLog =>
    typia.random<IAttendanceStatsAbnormalLog>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a specific abnormal attendance log (attendance_stats_abnormal_log
 * table) by its id.
 *
 * This API deletes an abnormal log entry for attendance, which documents a
 * detected anomaly regarding a student's attendance (such as suspected proxy
 * check-in, duplicate, code invalidation, or other rule violations). The
 * endpoint is protected for use by system administrators or users with
 * administrative rights. When invoked, the specified log record is permanently
 * removed from the database, provided the actor has the required permissions,
 * per security and audit requirements. If the id does not exist, an appropriate
 * error is returned. This API directly manipulates the
 * attendance_stats_abnormal_log table, which implements per-event anomaly
 * tracking and review for teacher/admin dashboards, and is referenced for audit
 * and compliance reporting. Related record deletions (such as dependent
 * references) follow database cascade rules as defined in the schema.
 *
 * @param props.connection
 * @param props.id Unique identifier of the abnormal log to delete
 * @path /attendance/stats/abnormalLogs/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier of the abnormal log to delete */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/attendance/stats/abnormalLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/stats/abnormalLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
