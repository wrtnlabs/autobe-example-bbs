import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAttendanceSchool } from "../../../structures/IAttendanceSchool";
import { IPageIAttendanceSchool } from "../../../structures/IPageIAttendanceSchool";
import { IDeleteResult } from "../../../structures/IDeleteResult";

/**
 * Create new school (attendance_school table).
 *
 * This endpoint allows the creation of a new school in the attendance system,
 * as required by the administrator interface for school management (see
 * 06_attendance_admin_page.md). The input must include atomic, normalized
 * school properties, specifically the school name and address. These fields
 * must be validated for uniqueness at the database level to prevent the
 * registration of duplicate schools. The operation is restricted to users with
 * admin privileges, as identified via bearer token JWT authentication. Upon
 * successful creation, the endpoint returns the full school record with a
 * unique school ID, time of creation, and all submitted fields. Validation
 * errors, such as duplicate school name/address or missing required fields,
 * yield appropriate error responses. This operation is critical for onboarding
 * new institutions into the platform and creating the reference anchor for
 * related entities such as teachers, students, admins, and classrooms. It
 * should be used before registering users or classes for new schools.
 *
 * @param props.connection
 * @param props.body Information required to create a new school (name,
 *   address).
 * @path /attendance/schools
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Information required to create a new school (name, address). */
    body: IAttendanceSchool.ICreate;
  };
  export type Body = IAttendanceSchool.ICreate;
  export type Response = IAttendanceSchool;

  export const METADATA = {
    method: "POST",
    path: "/attendance/schools",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/schools";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceSchool => typia.random<IAttendanceSchool>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Attendance_school 테이블의 학교 검색/조회 API.
 *
 * 학교 엔터티(attendance_school) 리스트 검색/조회(페이징/필터) API입니다. 요청자는 권한별 필터링 가능, 페이징/검색
 * 조건을 requestBody로 받고, IPageIAttendanceSchool 응답합니다. 이름/주소 등 핵심 필드 위주 설계.
 *
 * @param props.connection
 * @param props.body 학교 검색/필터/페이징 조건 오브젝트
 * @path /attendance/schools
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** 학교 검색/필터/페이징 조건 오브젝트 */
    body: IAttendanceSchool.IRequest;
  };
  export type Body = IAttendanceSchool.IRequest;
  export type Response = IPageIAttendanceSchool;

  export const METADATA = {
    method: "PATCH",
    path: "/attendance/schools",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/schools";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIAttendanceSchool => typia.random<IPageIAttendanceSchool>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Attendance_school 학교 단일 상세 정보 조회 API.
 *
 * Attendance_school 테이블의 단일 학교 상세정보 조회 API입니다. 유저(교사/학생/학부모/관리자) 모두 활용 가능,
 * PK(id) 기준 학교 오브젝트 반환. 등급/권한별 응답 제한 가변화 가능합니다.
 *
 * @param props.connection
 * @param props.id 상세정보를 조회할 대상 학교 UUID (Primary Key)
 * @path /attendance/schools/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** 상세정보를 조회할 대상 학교 UUID (Primary Key) */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceSchool;

  export const METADATA = {
    method: "GET",
    path: "/attendance/schools/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/schools/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceSchool => typia.random<IAttendanceSchool>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a school's name or address (attendance_school table).
 *
 * This endpoint permits updating an existing school's name or address,
 * referenced by its unique school ID, as managed in the attendance_school
 * table. Only admin-level users may access this route, which requires JWT
 * bearer authentication. The operation confirms the existence of the school,
 * ensures any changes comply with uniqueness constraints for name/address, and
 * propagates updates to all referencing records. Attempting to update to a
 * duplicate name/address will return a validation error. All changes are
 * timestamped for audit purposes. Use this endpoint to correct or modify
 * institution information as required in administrative workflows.
 *
 * @param props.connection
 * @param props.id Target school's unique ID
 * @param props.body School update information (name/address/other allowed
 *   changes).
 * @path /attendance/schools/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target school's unique ID */
    id: string & tags.Format<"uuid">;

    /** School update information (name/address/other allowed changes). */
    body: IAttendanceSchool.IUpdate;
  };
  export type Body = IAttendanceSchool.IUpdate;
  export type Response = IAttendanceSchool;

  export const METADATA = {
    method: "PUT",
    path: "/attendance/schools/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/attendance/schools/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceSchool => typia.random<IAttendanceSchool>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a school from the attendance system (attendance_school table).
 *
 * Deletes an existing school identified by its unique school ID (from the
 * attendance_school table). Only system administrators may access this
 * endpoint. Before deletion, the service must check for dependent entities
 * (students, teachers, classrooms, admins) and either refuse the operation if
 * links remain or cascade delete/reassign according to the system's policy.
 * Operates under strict audit logging. On successful deletion, a confirmation
 * is returned; otherwise, appropriate error or conflict responses are given.
 * Refer to administrator data management policies for real-world data removal
 * impacts.
 *
 * @param props.connection
 * @param props.id Target school's unique ID
 * @path /attendance/schools/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target school's unique ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/attendance/schools/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/schools/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IDeleteResult =>
    typia.random<IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
