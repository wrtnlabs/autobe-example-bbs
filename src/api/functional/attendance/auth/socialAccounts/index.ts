import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAttendanceSocialAccount } from "../../../../structures/IAttendanceSocialAccount";
import { IPageIAttendanceSocialAccount } from "../../../../structures/IPageIAttendanceSocialAccount";

/**
 * Creates a new social account mapping linked to an authentication account.
 *
 * Creates a new row in attendance_social_account linking a given external
 * social account to an existing authentication account (ID in
 * attendance_auth_account). Enforces unique constraint on (provider, social_id)
 * and ensures correct linkage to local account. On successful creation, a new
 * mapping is stored with audit information for compliance and logging. Used in
 * registration, social login/account-linking flows. Requires authentication
 * with bearer token. Security policy enforces that only owner or admin can link
 * accounts.
 *
 * @param props.connection
 * @param props.body Payload with provider, social_id, and linked
 *   auth_account_id information.
 * @path /attendance/auth/socialAccounts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Payload with provider, social_id, and linked auth_account_id
     * information.
     */
    body: IAttendanceSocialAccount.ICreate;
  };
  export type Body = IAttendanceSocialAccount.ICreate;
  export type Response = IAttendanceSocialAccount;

  export const METADATA = {
    method: "POST",
    path: "/attendance/auth/socialAccounts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/auth/socialAccounts";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceSocialAccount => typia.random<IAttendanceSocialAccount>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieves a paginated, filterable list of social account mappings.
 *
 * Retrieves a list of mapped social accounts in attendance_social_account,
 * supporting pagination, search, and filter options on provider, social_id, or
 * account linkage. This is used by admin UIs or account management modules to
 * review social login configurations, confirm linkages, or audit possible
 * conflicts. Requires authentication as an admin or the account owner, and
 * returns paginated data with filtering support for auditability. Sensitive
 * auditing may be performed for provider management or security review.
 *
 * @param props.connection
 * @param props.body Pagination, search, or filtering criteria for the list of
 *   social accounts.
 * @path /attendance/auth/socialAccounts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Pagination, search, or filtering criteria for the list of social
     * accounts.
     */
    body: IAttendanceSocialAccount.IRequest;
  };
  export type Body = IAttendanceSocialAccount.IRequest;
  export type Response = IPageIAttendanceSocialAccount;

  export const METADATA = {
    method: "PATCH",
    path: "/attendance/auth/socialAccounts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/auth/socialAccounts";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIAttendanceSocialAccount =>
    typia.random<IPageIAttendanceSocialAccount>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieves a single social account mapping record by its ID.
 *
 * Gets detailed information about a particular social login mapping, identified
 * by the unique UUID. Used for profile, security, or administrative views into
 * the social login linkage status, including auditing which external
 * provider/social_id is linked to which local account. Requires authentication
 * with proper access checks to ensure user or admin visibility. Includes link
 * timestamp and provider identity for audit/compliance use cases.
 *
 * @param props.connection
 * @param props.id UUID of attendance_social_account mapping to retrieve.
 * @path /attendance/auth/socialAccounts/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** UUID of attendance_social_account mapping to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceSocialAccount;

  export const METADATA = {
    method: "GET",
    path: "/attendance/auth/socialAccounts/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/auth/socialAccounts/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceSocialAccount => typia.random<IAttendanceSocialAccount>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Updates a mapped social login (social_account) by its ID.
 *
 * Allows modification of a mapped social login (attendance_social_account)
 * record by its ID. Can be used when a user wants to re-link a new provider
 * account, correct social_id, or update linkage following an external
 * deauthorization. Changes are tracked for audit. Authorization is required to
 * alter linkages, and operation is monitored for security purposes, often
 * restricted to owner or admin. Field constraints such as provider/social_id
 * unique pair must still be enforced.
 *
 * @param props.connection
 * @param props.id UUID of the social login mapping to update
 *   (attendance_social_account).
 * @param props.body Fields to update in the mapping (e.g., provider, social_id,
 *   auth_account_id).
 * @path /attendance/auth/socialAccounts/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /**
     * UUID of the social login mapping to update
     * (attendance_social_account).
     */
    id: string & tags.Format<"uuid">;

    /**
     * Fields to update in the mapping (e.g., provider, social_id,
     * auth_account_id).
     */
    body: IAttendanceSocialAccount.IUpdate;
  };
  export type Body = IAttendanceSocialAccount.IUpdate;
  export type Response = IAttendanceSocialAccount;

  export const METADATA = {
    method: "PUT",
    path: "/attendance/auth/socialAccounts/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/attendance/auth/socialAccounts/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceSocialAccount => typia.random<IAttendanceSocialAccount>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Deletes/unlinks a mapped social account by its ID.
 *
 * Deletes (unlinks) a mapped social account from the system by its UUID. Marks
 * the mapping as deleted and removes access via the given external provider.
 * Used when a user wants to remove a social login (for privacy, account
 * separation, or compliance). Enforces strict permissions (only owner/admin),
 * and always logs for audit/compliance. Cascade or orphan rules enforced at the
 * database/application layer to ensure account integrity. Any further logins
 * with the removed provider/social_id are blocked.
 *
 * @param props.connection
 * @param props.id UUID of the social login mapping to delete/unlink.
 * @path /attendance/auth/socialAccounts/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of the social login mapping to delete/unlink. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceSocialAccount;

  export const METADATA = {
    method: "DELETE",
    path: "/attendance/auth/socialAccounts/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/auth/socialAccounts/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceSocialAccount => typia.random<IAttendanceSocialAccount>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
