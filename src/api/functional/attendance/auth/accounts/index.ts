import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAttendanceAuthAccount } from "../../../../structures/IAttendanceAuthAccount";
import { IPageIAttendanceAuthAccount } from "../../../../structures/IPageIAttendanceAuthAccount";

/**
 * Create a new authentication account (attendance_auth_account table).
 *
 * Registers a new authentication account record in the attendance_auth_account
 * table. The request body specifies email, password (hashed), etc, adhering to
 * the local login policy and requirements for unique emails. This route is used
 * by onboarding flows for all user types, preparing their login credentials
 * (with further role assignments handled elsewhere). Errors are returned for
 * duplicate emails, weak password hashes, or invalid format. After creation,
 * the full account record is returned for use in session/token flows. This
 * endpoint is fundamental to account onboarding, and supports both local and,
 * with extension, social login onboarding. Strict audit logs are kept to track
 * all new account registrations.
 *
 * @param props.connection
 * @param props.body Authentication account creation info (email, password,
 *   etc).
 * @path /attendance/auth/accounts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Authentication account creation info (email, password, etc). */
    body: IAttendanceAuthAccount.ICreate;
  };
  export type Body = IAttendanceAuthAccount.ICreate;
  export type Response = IAttendanceAuthAccount;

  export const METADATA = {
    method: "POST",
    path: "/attendance/auth/accounts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/auth/accounts";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAuthAccount => typia.random<IAttendanceAuthAccount>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search authentication accounts (attendance_auth_account table).
 *
 * Returns a list of auth accounts filtered by search criteria or pagination
 * info, from the attendance_auth_account table. Typical use: admin reviews
 * accounts, links, and status for users of various roles. Only admins or
 * operators with the correct privileges may perform listing/search. Query
 * supports filtering by email, creation date, status, or other account
 * attributes. Results are paginated with page count/offset and sort fields.
 * This endpoint supports admin-side dashboards for operational review and
 * troubleshooting. Invalid filters or requests yield error responses. Bearer
 * authentication required.
 *
 * @param props.connection
 * @param props.body Search and pagination information for auth account list.
 * @path /attendance/auth/accounts
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search and pagination information for auth account list. */
    body: IAttendanceAuthAccount.IRequest;
  };
  export type Body = IAttendanceAuthAccount.IRequest;
  export type Response = IPageIAttendanceAuthAccount;

  export const METADATA = {
    method: "PATCH",
    path: "/attendance/auth/accounts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/auth/accounts";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIAttendanceAuthAccount =>
    typia.random<IPageIAttendanceAuthAccount>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get authentication account details by ID (attendance_auth_account table).
 *
 * Returns the full authentication account entity referenced by its unique ID
 * from the attendance_auth_account table. Admins or operators may use this
 * endpoint for account lookups, audits, user support, or troubleshooting. Only
 * authorized roles may access via bearer authentication. All atomic fields (id,
 * email, status, creation, last update, etc) are returned—no profile or role
 * attributes from other tables. This endpoint supports admin dashboard account
 * detail views and troubleshooting tools. Error responses are given for
 * non-existent IDs or access violations.
 *
 * @param props.connection
 * @param props.id Target authentication account's unique ID
 * @path /attendance/auth/accounts/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target authentication account's unique ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceAuthAccount;

  export const METADATA = {
    method: "GET",
    path: "/attendance/auth/accounts/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/auth/accounts/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAuthAccount => typia.random<IAttendanceAuthAccount>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Updates an existing authentication account in the attendance_auth_account
 * table.
 *
 * This API allows a client with proper authorization (such as an administrator
 * or the account owner) to update information of a specific authentication
 * account in the attendance_auth_account table. The endpoint ensures strict 3NF
 * compliance — it never allows inserting role or profile-specific data here,
 * only atomic fields pertaining to authentication logic such as email or
 * password hash. It supports use cases like email update, password reset, or
 * recovery following a social login link/unlink action. Requests must be
 * authenticated with a bearer token and are subject to auditing for security
 * compliance. Related critical actions (such as password changes) may be
 * separately logged in the audit log table (attendance_audit_log). Validation
 * includes ensuring new email is unique if provided, and that no hard delete
 * occurs (soft delete only via deleted_at).
 *
 * @param props.connection
 * @param props.id Authentication account identifier (UUID). Corresponds to
 *   attendance_auth_account.id
 * @param props.body Fields to update on the authentication account
 *   (email/password hash/soft delete marker).
 * @path /attendance/auth/accounts/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /**
     * Authentication account identifier (UUID). Corresponds to
     * attendance_auth_account.id
     */
    id: string & tags.Format<"uuid">;

    /**
     * Fields to update on the authentication account (email/password
     * hash/soft delete marker).
     */
    body: IAttendanceAuthAccount.IUpdate;
  };
  export type Body = IAttendanceAuthAccount.IUpdate;
  export type Response = IAttendanceAuthAccount;

  export const METADATA = {
    method: "PUT",
    path: "/attendance/auth/accounts/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/attendance/auth/accounts/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAuthAccount => typia.random<IAttendanceAuthAccount>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-deletes an authentication account by marking deleted_at.
 *
 * This API soft-deletes an authentication account by setting deleted_at on the
 * relevant attendance_auth_account row, disabling further authentication. It
 * supports user-initiated account deletion, admin offboarding, or regulatory
 * erasure requests, while ensuring compliance with security and audit
 * requirements by never hard-deleting records. Related actions should be
 * recorded in attendance_audit_log for regulatory traceability. Only fully
 * authorized actors (admin, owner) can call this endpoint, with strict checks
 * that role table dependencies are honored (parent/teacher/student/admin
 * linkage must be considered).
 *
 * @param props.connection
 * @param props.id Authentication account identifier to soft delete (UUID).
 *   Corresponds to attendance_auth_account.id
 * @path /attendance/auth/accounts/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /**
     * Authentication account identifier to soft delete (UUID). Corresponds
     * to attendance_auth_account.id
     */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceAuthAccount;

  export const METADATA = {
    method: "DELETE",
    path: "/attendance/auth/accounts/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/auth/accounts/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAuthAccount => typia.random<IAttendanceAuthAccount>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
