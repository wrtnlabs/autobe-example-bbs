import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAttendanceAdmin } from "../../../structures/IAttendanceAdmin";
import { IPageIAttendanceAdmin } from "../../../structures/IPageIAttendanceAdmin";

/**
 * Attendance_admin 관리자 신규 생성(등록) API.
 *
 * Attendance_admin(관리자) 신규 생성(등록) API입니다. 요청자는 반드시 충분한 권한(상위 관리자/관리자 인증)이 있어야
 * 하며, 입력값(name, email, school_id, auth_account_id 등) 중복/제약조건(유니크) 검증이 수행되어야
 * 합니다. 성공 시 생성된 attendance_admin 오브젝트가 반환되며, 추가 등록처리/승인 등은 별도 API에서 수행될 수
 * 있습니다.
 *
 * @param props.connection
 * @param props.body 관리자(감독관) 신규등록 요청 바디 오브젝트
 * @path /attendance/admins
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** 관리자(감독관) 신규등록 요청 바디 오브젝트 */
    body: IAttendanceAdmin.ICreate;
  };
  export type Body = IAttendanceAdmin.ICreate;
  export type Response = IAttendanceAdmin;

  export const METADATA = {
    method: "POST",
    path: "/attendance/admins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/admins";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAdmin => typia.random<IAttendanceAdmin>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Attendance_admin 관리자 리스트/검색 API.
 *
 * Attendance_admin(Admin/관리자)들의 리스트, 검색, 페이징 결과를 JSON 객체 배열 + pagination 메타로
 * 반환하는 API입니다. 페이징 및 필터는 요청 바디에서 받아야 하며, 인증/권한이 반드시 요구됩니다. 각 관리자 개체의 atomic
 * 필드(이름, 이메일, 소속 학교 등)와 반복/검색 대응 설계가 필수입니다.
 *
 * @param props.connection
 * @param props.body 관리자 리스트/검색/페이징 조건값 오브젝트
 * @path /attendance/admins
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** 관리자 리스트/검색/페이징 조건값 오브젝트 */
    body: IAttendanceAdmin.IRequest;
  };
  export type Body = IAttendanceAdmin.IRequest;
  export type Response = IPageIAttendanceAdmin;

  export const METADATA = {
    method: "PATCH",
    path: "/attendance/admins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/attendance/admins";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIAttendanceAdmin => typia.random<IPageIAttendanceAdmin>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Attendance_admin 테이블의 관리자 단일 상세 정보 반환 API.
 *
 * Attendance_admin(관리자) 단일 PK(id) 기준 상세정보 반환 API입니다. 실무적으로 관리자/상위 관리자/감사자/본인만
 * 접근할 수 있어야 하며, 권한체크, 개인정보노출 보호, 접근이력 감사가 구현되어야 합니다. 성공시 attendance_admin 단일
 * 오브젝트 구조 반환.
 *
 * @param props.connection
 * @param props.id 상세정보를 조회할 대상 관리자(Admin) UUID (PK)
 * @path /attendance/admins/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** 상세정보를 조회할 대상 관리자(Admin) UUID (PK) */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceAdmin;

  export const METADATA = {
    method: "GET",
    path: "/attendance/admins/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/admins/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAdmin => typia.random<IAttendanceAdmin>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Attendance_admin(관리자) 정보 수정(업데이트) API.
 *
 * 특정 attendance_admin(관리자)의 정보(PK = id 기준)를 JSON 오브젝트로 수정/갱신하는 API. 요청자는 충분한
 * 관리자권한/상위자격을 통해 Bearer 인증 후 사용 가능. 수정 후(전체/부분) attendance_admin 오브젝트 리턴. 변경이력
 * 및 감사로그 필수.
 *
 * @param props.connection
 * @param props.id 수정할 관리자(admin)의 UUID (PK)
 * @param props.body 수정할 관리자 정보(이메일, 이름, 소속 등) 오브젝트
 * @path /attendance/admins/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** 수정할 관리자(admin)의 UUID (PK) */
    id: string & tags.Format<"uuid">;

    /** 수정할 관리자 정보(이메일, 이름, 소속 등) 오브젝트 */
    body: IAttendanceAdmin.IUpdate;
  };
  export type Body = IAttendanceAdmin.IUpdate;
  export type Response = IAttendanceAdmin;

  export const METADATA = {
    method: "PUT",
    path: "/attendance/admins/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/attendance/admins/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAdmin => typia.random<IAttendanceAdmin>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Attendance_admin 관리자 삭제/권한말소 API.
 *
 * Attendance_admin(관리자) 삭제(퇴직/권한말소) API입니다. 관리자는 본인 또는 상위 관리자/최상위 감사권자가 호출할 수
 * 있으며, 소프트삭제 정책 권고(복구/감사목적). 성공시 삭제된 attendance_admin 오브젝트 또는 No Content 반환,
 * 실패시는 403/404등으로 응답.
 *
 * @param props.connection
 * @param props.id 삭제 대상 관리자(admin)의 UUID (PK)
 * @path /attendance/admins/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** 삭제 대상 관리자(admin)의 UUID (PK) */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IAttendanceAdmin;

  export const METADATA = {
    method: "DELETE",
    path: "/attendance/admins/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/attendance/admins/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IAttendanceAdmin => typia.random<IAttendanceAdmin>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
