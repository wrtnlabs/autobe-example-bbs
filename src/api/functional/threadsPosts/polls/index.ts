import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPoll } from "../../../structures/IPoll";
import { IPageIPoll } from "../../../structures/IPageIPoll";
import { IThreadsPostsPoll } from "../../../structures/IThreadsPostsPoll";

/**
 * Create a new poll with question, timing, and options, attached to a post, in
 * the 'polls' table.
 *
 * This 'post' operation creates a new poll record, associating it with an
 * existing post via post_id. Input must include poll question, timing
 * (start/end), and list of poll options (choice titles and order). Only the
 * original post creator or a moderator/admin is authorized per business rules.
 * Enforcement: a post can have at most one poll attached (per unique index in
 * schema). Returns complete poll with options. Related to PATCH (query/search),
 * GET (details), and operations for voting on a poll. On error (e.g., post
 * already has a poll, validation fail), returns detailed message.
 *
 * @param props.body Complete creation info for the poll—question, post,
 *   open/close dates, poll options list, etc.
 * @path /threadsPosts/polls
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Complete creation info for the poll—question, post, open/close dates,
     * poll options list, etc.
     */
    body: IPoll.ICreate;
  };
  export type Body = IPoll.ICreate;
  export type Response = IPoll;

  export const METADATA = {
    method: "POST",
    path: "/threadsPosts/polls",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/threadsPosts/polls";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPoll =>
    typia.random<IPoll>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Query or list polls in the 'polls' table with arbitrary search criteria using
 * a json request body, supporting paging/sorting.
 *
 * This 'patch' operation allows admin, moderator, or certain users to request a
 * filtered/paginated list of poll records. Filters can include status (open,
 * closed), by post/thread/topic, time, or more. Returns paginated result with
 * poll info, possibly with related entities (options, results, etc). Returns
 * only those records the user is authorized to view. Related to poll creation
 * (POST), inspection (GET), and management operations. Enables analytics, UI
 * list, and export.
 *
 * @param props.body Filter, sort, and pagination criteria for poll search
 *   (status, date, post, etc).
 * @path /threadsPosts/polls
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Filter, sort, and pagination criteria for poll search (status, date,
     * post, etc).
     */
    body: IPoll.IRequest;
  };
  export type Body = IPoll.IRequest;
  export type Response = IPageIPoll;

  export const METADATA = {
    method: "PATCH",
    path: "/threadsPosts/polls",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/threadsPosts/polls";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIPoll =>
    typia.random<IPageIPoll>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve all information about a specific poll from the 'polls' table by
 * unique ID.
 *
 * This 'get' operation fetches a poll record and all atomic properties from the
 * 'polls' table by unique ID. Includes: question, timing, status, related post,
 * and relationships to poll options and (if permitted) vote counts. Access may
 * be open or require login, depending on whether the poll is public or
 * restricted. Errors returned if not found or unauthorized. Related operations
 * are POST (creation), PATCH (search/list), and PUT (update, if supported for
 * admin). Use for poll display in post view or poll-specific UIs.
 *
 * @param props.id The unique identifier of the poll to retrieve.
 * @path /threadsPosts/polls/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** The unique identifier of the poll to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IPoll;

  export const METADATA = {
    method: "GET",
    path: "/threadsPosts/polls/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/threadsPosts/polls/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IPoll =>
    typia.random<IPoll>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a specific poll in the threadsPosts (polls table).
 *
 * The PUT /threadsPosts/polls/{id} endpoint enables modification of an existing
 * poll within the discussion board's threadsPosts subsystem. It references the
 * 'polls' Prisma model, which contains atomic fields such as question,
 * start_at, and end_at.
 *
 * Security: Only users with appropriate permissions (poll creator or
 * moderators) can perform this operation. Attempts to update with invalid or
 * past-close-date timestamps are rejected per business logic. The operation
 * validates referential integrity, ensuring the poll belongs to a valid post
 * and that date updates do not violate poll status constraints.
 *
 * Business logic: On editing, a history/audit log may be triggered (not stored
 * in the poll directly). The endpoint never creates new polls—it acts
 * exclusively on the identified poll by its id parameter. If the poll does not
 * exist, or is soft-deleted, the operation fails with appropriate error
 * messaging. Related endpoints include creation (POST /threadsPosts/polls),
 * retrieval (GET), and deletion (DELETE /threadsPosts/polls/{id}).
 *
 * Error handling ensures that attempts to alter immutable fields or perform
 * partially invalid updates result in descriptive error responses.
 *
 * @param props.id Unique identifier of the poll to update
 * @param props.body Fields to update for the poll (question, dates).
 * @path /threadsPosts/polls/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier of the poll to update */
    id: string & tags.Format<"uuid">;

    /** Fields to update for the poll (question, dates). */
    body: IThreadsPostsPoll.IUpdate;
  };
  export type Body = IThreadsPostsPoll.IUpdate;
  export type Response = IThreadsPostsPoll;

  export const METADATA = {
    method: "PUT",
    path: "/threadsPosts/polls/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/threadsPosts/polls/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IThreadsPostsPoll => typia.random<IThreadsPostsPoll>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a specific poll from the threadsPosts (polls table).
 *
 * DELETE /threadsPosts/polls/{id} allows a user or moderator to permanently
 * remove a poll, referencing the 'polls' Prisma schema table. The endpoint
 * ensures robust permission checks—only the poll's creator or moderators can
 * delete polls. Deletion typically cascades to associated poll_options and
 * poll_votes due to Prisma's relational modeling.
 *
 * Special care is taken to enforce audit logging: every deletion is reported in
 * the moderation logs for transparency and future appeals. Delets are generally
 * logical (soft-delete) unless otherwise specified by business policy,
 * preserving historical evidence as required by moderation rules.
 *
 * The operation will fail gracefully if the poll does not exist, already
 * deleted, or the user is unauthorized. Related endpoints include updating
 * (PUT), retrieval (GET), and creation (POST) of polls.
 *
 * @param props.id Unique identifier of the poll to delete
 * @path /threadsPosts/polls/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier of the poll to delete */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IThreadsPostsPoll;

  export const METADATA = {
    method: "DELETE",
    path: "/threadsPosts/polls/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/threadsPosts/polls/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IThreadsPostsPoll => typia.random<IThreadsPostsPoll>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
