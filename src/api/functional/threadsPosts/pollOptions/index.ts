import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IThreadsPostsPollOption } from "../../../structures/IThreadsPostsPollOption";
import { IPageIThreadsPostsPollOption } from "../../../structures/IPageIThreadsPostsPollOption";

/**
 * Create a new poll option (threadsPosts/poll_options table).
 *
 * POST /threadsPosts/pollOptions creates a new poll option within an existing
 * poll, referencing the 'poll_options' Prisma schema. The request body must
 * follow IThreadsPostsPollOption.ICreate, including poll_id (which poll this
 * option belongs to), option text, and sequence order. Upon validation, the
 * endpoint inserts a new record and returns the created poll option.
 *
 * Security: Only users who can edit the poll (such as poll creators or
 * moderators) may use this endpoint. Validation checks ensure unique sequence
 * within the poll and that the associated poll exists and is editable.
 *
 * Related operations cover searching (PATCH), retrieval (GET), updating (PUT),
 * and deletion (DELETE) of options for full poll management coverage.
 *
 * @param props.body Poll option creation data (poll_id, title, sequence).
 * @path /threadsPosts/pollOptions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Poll option creation data (poll_id, title, sequence). */
    body: IThreadsPostsPollOption.ICreate;
  };
  export type Body = IThreadsPostsPollOption.ICreate;
  export type Response = IThreadsPostsPollOption;

  export const METADATA = {
    method: "POST",
    path: "/threadsPosts/pollOptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/threadsPosts/pollOptions";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IThreadsPostsPollOption => typia.random<IThreadsPostsPollOption>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Search or filter poll options (threadsPosts/poll_options table).
 *
 * PATCH /threadsPosts/pollOptions enables advanced searching, filtering, and
 * pagination over poll options. It directly references the 'poll_options'
 * Prisma schema, allowing queries using parameters like poll_id, option text,
 * or sequence number. The request body follows the
 * IThreadsPostsPollOption.IRequest structure, supporting pagination (page,
 * pageSize), search, and sorting.
 *
 * Security: All registered users can search poll options, as this is a
 * read-only operation. Performance is optimized for large data sets by
 * paginating the response and supporting index-based queries.
 *
 * Validations ensure that provided filters correspond to allowed fields and
 * that page size limits are enforced to avoid heavy queries. This endpoint is
 * often used in user interfaces that list all options for a poll or support
 * admin review/actions.
 *
 * @param props.body Search, filtering, and pagination parameters for poll
 *   options.
 * @path /threadsPosts/pollOptions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search, filtering, and pagination parameters for poll options. */
    body: IThreadsPostsPollOption.IRequest;
  };
  export type Body = IThreadsPostsPollOption.IRequest;
  export type Response = IPageIThreadsPostsPollOption;

  export const METADATA = {
    method: "PATCH",
    path: "/threadsPosts/pollOptions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/threadsPosts/pollOptions";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIThreadsPostsPollOption =>
    typia.random<IPageIThreadsPostsPollOption>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a specific poll option by ID (threadsPosts/poll_options table).
 *
 * GET /threadsPosts/pollOptions/{id} returns a single poll option object
 * referenced by the 'poll_options' Prisma schema. All standard fields (id,
 * poll_id, title, sequence) are included. This operation enforces access
 * permissions—generally, any registered user may view poll options associated
 * with accessible polls.
 *
 * Validation ensures that the {id} provided is a valid UUID and that the poll
 * option exists. If not found, an error is returned. The endpoint does not
 * allow modification—read-only access. Related operations cover listing all
 * options (PATCH), creation (POST), updating (PUT), and deletion (DELETE).
 *
 * @param props.id Unique identifier of the poll option to retrieve
 * @path /threadsPosts/pollOptions/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier of the poll option to retrieve */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IThreadsPostsPollOption;

  export const METADATA = {
    method: "GET",
    path: "/threadsPosts/pollOptions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/threadsPosts/pollOptions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IThreadsPostsPollOption => typia.random<IThreadsPostsPollOption>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a specific poll option (threadsPosts/poll_options table).
 *
 * PUT /threadsPosts/pollOptions/{id} modifies an existing poll option, as
 * referenced in the 'poll_options' Prisma schema. The editable fields are title
 * (option text) and sequence (display order). Only users with the authority to
 * manage poll options (such as poll creators or moderators) may use this
 * endpoint.
 *
 * Validations: Ensures the sequence number remains unique within the target
 * poll, and the new data meets business rules. The operation is atomic,
 * updating only the specified option. If the poll option doesn't exist or the
 * user lacks permission, an error is returned. Related endpoints exist for
 * creation, listing, and deletion.
 *
 * @param props.id Unique identifier of the poll option to update
 * @param props.body Fields to update for the poll option (title, sequence).
 * @path /threadsPosts/pollOptions/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier of the poll option to update */
    id: string & tags.Format<"uuid">;

    /** Fields to update for the poll option (title, sequence). */
    body: IThreadsPostsPollOption.IUpdate;
  };
  export type Body = IThreadsPostsPollOption.IUpdate;
  export type Response = IThreadsPostsPollOption;

  export const METADATA = {
    method: "PUT",
    path: "/threadsPosts/pollOptions/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/threadsPosts/pollOptions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IThreadsPostsPollOption => typia.random<IThreadsPostsPollOption>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a specific poll option (threadsPosts/poll_options table).
 *
 * DELETE /threadsPosts/pollOptions/{id} removes a poll option record from the
 * 'poll_options' Prisma schema. Only poll owners or moderators have permission
 * to perform this action. Cascading effects are handled for any poll_votes
 * linked.
 *
 * Security: Each action is logged (moderation log or audit trail) for future
 * review. The operation checks for the existence of the poll option and
 * authorization before deleting. Soft deletion behavior may be implemented
 * based on business rules for recoverability/auditing.
 *
 * The endpoint fails gracefully where the poll option does not exist, has
 * already been deleted, or the user lacks permission.
 *
 * @param props.id Unique identifier of the poll option to delete
 * @path /threadsPosts/pollOptions/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier of the poll option to delete */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IThreadsPostsPollOption;

  export const METADATA = {
    method: "DELETE",
    path: "/threadsPosts/pollOptions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/threadsPosts/pollOptions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IThreadsPostsPollOption => typia.random<IThreadsPostsPollOption>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
