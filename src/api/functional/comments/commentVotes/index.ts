import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommentVote } from "../../../structures/ICommentVote";
import { IPageICommentVote } from "../../../structures/IPageICommentVote";

/**
 * Create a comment vote (upvote/downvote) for a specific comment (comment_votes
 * table).
 *
 * This API operation allows a registered user to cast an upvote or downvote on
 * a specific comment. The comment_votes table tracks each atomic vote action,
 * ensuring that a user may only vote once per comment (unique per user and
 * comment_id). When this endpoint is called, the system checks that the user is
 * authenticated and possesses the necessary permissions (not banned/suspended).
 * The API validates that the target comment exists and is enabled for voting.
 *
 * The request body must contain identifiers for the comment and user, along
 * with the direction of the vote (upvote or downvote). Upon successful
 * creation, a new comment_votes record is written, timestamped, and included in
 * reputation/aggregation logic elsewhere (not here). If a vote already exists
 * for this user-comment pair, an error is returned, and users are directed to
 * the update or delete endpoints for changes.
 *
 * Security is enforced through user authentication tokens and permission checks
 * (users cannot vote on their own comments if business rules dictate so). This
 * operation may trigger notifications or UI updates. The API is tightly coupled
 * with the comment_votes model and is part of essential functionality for
 * social engagement and ranking within threads.
 *
 * @param props.body Information for creating a new comment vote: must include
 *   comment_id, voter_id, and is_upvote.
 * @path /comments/commentVotes
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Information for creating a new comment vote: must include comment_id,
     * voter_id, and is_upvote.
     */
    body: ICommentVote.ICreate;
  };
  export type Body = ICommentVote.ICreate;
  export type Response = ICommentVote;

  export const METADATA = {
    method: "POST",
    path: "/comments/commentVotes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/comments/commentVotes";
  export const random = (g?: Partial<typia.IRandomGenerator>): ICommentVote =>
    typia.random<ICommentVote>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List/search comment votes (comment_votes table, PATCH).
 *
 * Allows authorized users (admins, moderators, or user themselves) to
 * search/filter/sort comment vote records. Query supports by user_id,
 * comment_id, upvote/downvote, and created_at intervals. Adheres carefully to
 * strict atomic 3NF per schema. Receives ICommentVote.IRequest for search
 * parameters (pagination, filters). Returns paginated result IPageICommentVote.
 * Related: GET for single vote detail, analytics endpoints. Enforces access
 * checks by backend.
 *
 * @param props.body Pagination and filters for comment vote search
 *   (ICommentVote.IRequest).
 * @path /comments/commentVotes
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Pagination and filters for comment vote search
     * (ICommentVote.IRequest).
     */
    body: ICommentVote.IRequest;
  };
  export type Body = ICommentVote.IRequest;
  export type Response = IPageICommentVote;

  export const METADATA = {
    method: "PATCH",
    path: "/comments/commentVotes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/comments/commentVotes";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageICommentVote => typia.random<IPageICommentVote>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get single comment vote record by ID (comment_votes table, GET).
 *
 * Obtains all information about a single comment_vote action: which comment, by
 * which voter, up or down flag, time, and related meta as per schema. Used for
 * moderation review, historical lookup, or user action trace. Backend may
 * restrict access to own-vote for regular users, broader for moderators/admins.
 * Returns ICommentVote data.
 *
 * @param props.id UUID of the comment vote to retrieve.
 * @path /comments/commentVotes/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** UUID of the comment vote to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ICommentVote;

  export const METADATA = {
    method: "GET",
    path: "/comments/commentVotes/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/comments/commentVotes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ICommentVote =>
    typia.random<ICommentVote>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing comment vote (upvote/downvote) by its ID (comment_votes
 * table).
 *
 * This endpoint allows the voting user to modify their previously cast upvote
 * or downvote on a comment. The comment_votes model records a one-to-one
 * mapping per (user, comment): thus, only the owning user may change their
 * vote's direction via this endpoint. The request body must provide the updated
 * vote value (is_upvote). The server checks the existence and ownership of the
 * original vote, plus authentication/authorization (cannot update others'
 * votes).
 *
 * If found and authorized, the vote record is updated, and a new timestamp is
 * stored for the modification. This endpoint enforces all business rulesâ€”such
 * as not allowing admins/moderators to override regular users' votes, and
 * preventing edits during suspensions or bans. Audit and moderation logs
 * reflect this action. The updated comment vote is returned on success. Errors
 * are produced for not found, ownership mismatch, or invalid transitions (such
 * as changing a deleted vote).
 *
 * @param props.id Target comment vote's unique ID.
 * @param props.body Updated information for the comment vote: only is_upvote
 *   can be changed.
 * @path /comments/commentVotes/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target comment vote's unique ID. */
    id: string & tags.Format<"uuid">;

    /**
     * Updated information for the comment vote: only is_upvote can be
     * changed.
     */
    body: ICommentVote.IUpdate;
  };
  export type Body = ICommentVote.IUpdate;
  export type Response = ICommentVote;

  export const METADATA = {
    method: "PUT",
    path: "/comments/commentVotes/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/comments/commentVotes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): ICommentVote =>
    typia.random<ICommentVote>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete a comment vote by its unique ID (comment_votes table).
 *
 * This API endpoint enables a user to retract (delete) their vote on a given
 * comment. This matches the business rule that only the user who cast the vote,
 * or an admin in moderation circumstances, may remove the comment_votes record.
 * Upon API call, the system confirms the vote exists, that the calling user is
 * authorized, and that the comment and user association matches the record.
 *
 * Once validated, the vote is deleted (physically or via soft-delete depending
 * on business rules/audit requirements), ensuring one user can have at most one
 * active vote per comment. Deletions are tracked in audit logs for moderation
 * and transparency. The deletion can impact reputation scoring or vote totals,
 * but those are managed elsewhere. If the vote does not exist, or authorization
 * fails, the API returns appropriate errors.
 *
 * @param props.id Target comment vote's unique ID.
 * @path /comments/commentVotes/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target comment vote's unique ID. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ICommentVote.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/comments/commentVotes/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/comments/commentVotes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ICommentVote.IDeleteResult => typia.random<ICommentVote.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
