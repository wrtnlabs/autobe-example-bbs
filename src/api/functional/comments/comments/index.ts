import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IComment } from "../../../structures/IComment";
import { IPageIComment } from "../../../structures/IPageIComment";

/**
 * Create a new comment/reply (comments table, POST).
 *
 * This endpoint allows an authenticated user to create a new comment for a
 * post, or as a reply to another comment (threading). The operation uses
 * atomic, strictly normalized fields including post_id, author_id, parent_id
 * (nullable), and the required comment content. Backend applies permission and
 * anti-abuse logic (e.g., rate limits, posting restrictions).
 *
 * Data validation follows the Prisma schema and business rules: content cannot
 * be empty, and references must exist (valid post_id, optional but valid
 * parent_id, etc.). Returned object contains all core properties and
 * references. Upon success, returns the full comment. Errors include invalid
 * input, auth failure, or attempts to reply to deleted/comment-locked
 * threads/comments.
 *
 * @param props.body Comment creation info (target post, parent comment,
 *   content, author).
 * @path /comments/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Comment creation info (target post, parent comment, content, author). */
    body: IComment.ICreate;
  };
  export type Body = IComment.ICreate;
  export type Response = IComment;

  export const METADATA = {
    method: "POST",
    path: "/comments/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/comments/comments";
  export const random = (g?: Partial<typia.IRandomGenerator>): IComment =>
    typia.random<IComment>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List and search comments (comments table, PATCH).
 *
 * This operation allows authenticated users to retrieve a list of comments from
 * the 'comments' table. The endpoint supports searching by various criteria
 * (e.g., post_id, author_id), pagination (offset/limit or page/size), and
 * sorting (e.g., by created_at, by most upvotes). All comments maintain
 * atomicity, threading reference, audit fields, and possible parent_id for
 * nested replies. The operation enforces permission checks in the backend
 * (e.g., filter out soft-deleted comments for regular users but allow
 * moderators to view all).
 *
 * Request body fields include page/limit, filter conditions, and sort mode. All
 * query behaviors are strongly based on the Prisma schema and requirements for
 * transparent, normalized retrieval. System logs queries for audit and system
 * performance monitoring.
 *
 * Related operations: - GET /comments/comments/{id} to fetch single comment
 * details, and POST /comments/comments to create a new comment.
 *
 * Error cases include: invalid parameters, unauthorized access, or query
 * errors. The request body must be shaped as per the 'IComment.IRequest'
 * definition from OpenAPI components.
 *
 * @param props.body Comment list retrieval/query parameters (search,
 *   pagination, filters).
 * @path /comments/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Comment list retrieval/query parameters (search, pagination,
     * filters).
     */
    body: IComment.IRequest;
  };
  export type Body = IComment.IRequest;
  export type Response = IPageIComment;

  export const METADATA = {
    method: "PATCH",
    path: "/comments/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/comments/comments";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIComment =>
    typia.random<IPageIComment>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get specific comment details by ID (comments table, GET).
 *
 * Fetches full details for an individual comment, identified by its UUID. The
 * result includes author info, parent_id for thread nesting, post association,
 * created_at timestamp, and deleted_at (if applicable). Backend can apply
 * access control depending on the user's role (e.g., show moderation fields for
 * admin, hide deleted_at for guests).
 *
 * Related endpoints: PATCH /comments/comments (list), POST /comments/comments
 * (create).
 *
 * Errors include: comment not found, permission denied, or invalid ID format.
 * ID must match UUID string as per schema.
 *
 * @param props.id Unique UUID of the comment to retrieve.
 * @path /comments/comments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique UUID of the comment to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IComment;

  export const METADATA = {
    method: "GET",
    path: "/comments/comments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/comments/comments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IComment =>
    typia.random<IComment>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a specific comment using PUT (comments table).
 *
 * Enables authorized users to update existing comment attributes. PUT replaces
 * the comment's content and/or parent reference atomically if permitted: for
 * example, editing the body text or modifying threaded structure (within
 * business constraints). Edits are recorded in the comment_edits table for full
 * auditability, as per moderation and evidence requirements. The implementation
 * may reject attempts to move a comment under an invalid parent, overwrite
 * locked/deleted comments, or if unauthorized.
 *
 * Related endpoints: PATCH for search, POST for create, GET for fetch. Errors:
 * permission denied, ID not found, or failed validation.
 *
 * @param props.id UUID of the comment to update.
 * @param props.body Properties for edit/replace of comment (IComment.IUpdate).
 * @path /comments/comments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** UUID of the comment to update. */
    id: string & tags.Format<"uuid">;

    /** Properties for edit/replace of comment (IComment.IUpdate). */
    body: IComment.IUpdate;
  };
  export type Body = IComment.IUpdate;
  export type Response = IComment;

  export const METADATA = {
    method: "PUT",
    path: "/comments/comments/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/comments/comments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IComment =>
    typia.random<IComment>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete a comment (comments table, DELETE).
 *
 * Allows an authorized user (author or moderator/admin) to perform a
 * soft-delete of the comment with the specified UUID. The row's deleted_at
 * field is set, but all data is retained for future audit or restoration, as
 * mandated by moderation/audit requirements. Request may be denied if comment
 * does not exist, caller is unauthorized, or other business rules (e.g. already
 * deleted, forbidden thread).
 *
 * Related operations: RESTORE or hard-delete patterns are not provided,
 * adhering to compliance policies. Errors: not found, access denied, or already
 * deleted.
 *
 * @param props.id UUID of the comment to soft-delete.
 * @path /comments/comments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of the comment to soft-delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IComment;

  export const METADATA = {
    method: "DELETE",
    path: "/comments/comments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/comments/comments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IComment =>
    typia.random<IComment>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
