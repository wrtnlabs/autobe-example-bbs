import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IComment } from "../../../structures/IComment";
import { IPageIComment } from "../../../structures/IPageIComment";

/**
 * Create a new comment (Posts domain, 'comments' table).
 *
 * This API lets a registered user create a new comment (either as a direct
 * reply to a post or as a nested reply to another comment). Necessary fields
 * include the content, target postId, and optionally a parentId (for
 * replies-to-replies).
 *
 * Input is validated for minimum/maximum length, appropriate content, and
 * ensuring the parent exists and belongs to the same post. The endpoint checks
 * author authentication and standard anti-abuse policies (e.g., rate limiting).
 * On success, it returns the created comment record with all metadata (author,
 * timestamp, etc.).
 *
 * Business logic from the 'comments' table (Posts domain) is implemented: only
 * registered users may comment; soft deletion rules apply. Related endpoints:
 * retrieval (GET /posts/comments/{id}), update (PUT /posts/comments/{id}), and
 * listing (PATCH /posts/comments).
 *
 * @param props.body New comment data, including content, postId, and optional
 *   parentId.
 * @path /posts/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** New comment data, including content, postId, and optional parentId. */
    body: IComment.ICreate;
  };
  export type Body = IComment.ICreate;
  export type Response = IComment;

  export const METADATA = {
    method: "POST",
    path: "/posts/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/posts/comments";
  export const random = (g?: Partial<typia.IRandomGenerator>): IComment =>
    typia.random<IComment>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve a filtered, paginated list of comments (Posts domain, 'comments'
 * table).
 *
 * This API retrieves a paged list of comments from the discussion board.
 * Typically, users or moderators use it to see all comments on a specific
 * thread, all comments by a particular user, or to moderate recent activity.
 *
 * The route supports filtering (e.g., by postId, userId, parentId), pagination
 * (offset/limit), full-text search on comment content, and sorting (e.g.,
 * newest first). Security considerations include only exposing non-deleted
 * comments by default, unless requested by a privileged moderator/admin.
 * Comment content is filtered to remove inappropriate language if the requester
 * has insufficient privileges.
 *
 * It references the 'comments' table (Posts domain). Query performance is
 * optimized via relevant indexes. Related APIs include: create (POST
 * /posts/comments), update (PUT /posts/comments/{id}), retrieve detail (GET
 * /posts/comments/{id}), and delete (DELETE /posts/comments/{id}).
 *
 * Input validation includes correct types for filters, max page size, and valid
 * sort orders. Error handling covers unauthorized access, malformed filters,
 * and nonexistent references.
 *
 * @param props.body Defines filtering, pagination, and sorting criteria for
 *   retrieving comments. Fields may include postId, userId, parentId, search,
 *   offset, limit, and sort.
 * @path /posts/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Defines filtering, pagination, and sorting criteria for retrieving
     * comments. Fields may include postId, userId, parentId, search,
     * offset, limit, and sort.
     */
    body: IComment.IRequest;
  };
  export type Body = IComment.IRequest;
  export type Response = IPageIComment;

  export const METADATA = {
    method: "PATCH",
    path: "/posts/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/posts/comments";
  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIComment =>
    typia.random<IPageIComment>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Fetch detailed information about a single comment (Posts domain, 'comments'
 * table).
 *
 * This API fetches the detail of a single comment in the discussion board by
 * its unique ID. Common scenarios include users viewing a nested reply,
 * moderators inspecting a reported comment, or when displaying a comment in
 * thread view.
 *
 * It returns full details such as content, author, timestamps, post reference,
 * parent comment reference, and vote tallies. The route references the
 * 'comments' table (Posts domain) and is optimized for quick retrieval. It will
 * not return comments marked as deleted unless accessed by a user with
 * sufficient privileges (e.g., moderator or admin).
 *
 * Error handling includes returning appropriate errors for nonexistent,
 * deleted, or unauthorized access. Related APIs: listing (PATCH
 * /posts/comments), update (PUT /posts/comments/{id}), creation (POST
 * /posts/comments), and deletion (DELETE /posts/comments/{id}).
 *
 * @param props.id Target comment's ID
 * @path /posts/comments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target comment's ID */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IComment;

  export const METADATA = {
    method: "GET",
    path: "/posts/comments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/posts/comments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IComment =>
    typia.random<IComment>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update an existing comment's content or deletion status (Posts domain,
 * 'comments' table).
 *
 * This API allows an authorized user (typically the comment's original author
 * or a moderator/admin) to update the content or status of a comment. Supported
 * fields for update include content (for editing), and soft deletion flag.
 *
 * Checks include author authentication, edit time-window (if enforced by
 * policy), and protection against editing after moderation/deletion. Input
 * validation ensures updated content meets platform standards, and references
 * are unaltered (cannot change post or parentId).
 *
 * The endpoint references the 'comments' table (Posts domain). On success,
 * returns the updated comment object. Error scenarios include not found,
 * unauthorized modification, or invalid updates. Related APIs: create (POST
 * /posts/comments), retrieve (GET /posts/comments/{id}), delete (DELETE
 * /posts/comments/{id}).
 *
 * @param props.id The target comment's ID to update
 * @param props.body Fields to update in the comment (content and/or soft
 *   delete).
 * @path /posts/comments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** The target comment's ID to update */
    id: string & tags.Format<"uuid">;

    /** Fields to update in the comment (content and/or soft delete). */
    body: IComment.IUpdate;
  };
  export type Body = IComment.IUpdate;
  export type Response = IComment;

  export const METADATA = {
    method: "PUT",
    path: "/posts/comments/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/posts/comments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IComment =>
    typia.random<IComment>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Soft-delete a comment (Posts domain, 'comments' table).
 *
 * This API performs a soft deletion (marks as deleted) of a comment identified
 * by its ID. Typical scenarios: the comment's author chooses to remove their
 * reply, or a moderator removes content that violates policy. The comment
 * remains in the database (for auditability), but becomes invisible to regular
 * users and excluded from normal listings.
 *
 * Authorization checks enforce only the author, moderator, or admin can perform
 * this. Related error handling includes not found, already deleted, and
 * unauthorized access. Audit logs are typically recorded. Related endpoints:
 * create (POST /posts/comments), update (PUT /posts/comments/{id}), retrieve
 * (GET /posts/comments/{id}), list (PATCH /posts/comments).
 *
 * @param props.id The comment's ID to delete
 * @path /posts/comments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** The comment's ID to delete */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IComment.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/posts/comments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/posts/comments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IComment.IDeleteResult => typia.random<IComment.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
