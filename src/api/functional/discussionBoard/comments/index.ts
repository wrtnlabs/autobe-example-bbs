import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardComment } from "../../../structures/IDiscussionBoardComment";
import { IPageIDiscussionBoardComment } from "../../../structures/IPageIDiscussionBoardComment";
import { IDeleteResult } from "../../../structures/IDeleteResult";

/**
 * Create a new post comment in the discussion_board_comment table.
 *
 * This endpoint allows the creation of a top-level comment (direct reply to a
 * post, not a reply to another comment) on a discussion post, capturing
 * content, author, and the parent post association as required in the Prisma
 * schema. Input must supply the full set of required fields. The API enforces
 * all validation rules (e.g., content not empty, post/post author must exist,
 * user authorized to comment). Error scenarios include 400 for invalid input,
 * 403 for insufficient privileges, 404 if target post does not exist, and 500
 * for server issues. The response includes the fully constructed comment
 * record, including relationships and timestamps. Comment creation may trigger
 * notifications for interested parties as per notification service.
 *
 * @param props.connection
 * @param props.body Comment creation fields: content, author, parent post, etc.
 * @path /discussionBoard/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Comment creation fields: content, author, parent post, etc. */
    body: IDiscussionBoardComment.ICreate;
  };
  export type Body = IDiscussionBoardComment.ICreate;
  export type Response = IDiscussionBoardComment;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/comments";
  export const random = (): IDiscussionBoardComment =>
    typia.random<IDiscussionBoardComment>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/search comments from discussion_board_comment with full filter support.
 *
 * This endpoint returns a paginated and filterable list of comments, each
 * representing a direct response to a post within a discussion thread. Comments
 * are linked to both the parent post and the author, as described in the
 * schema. The response includes rich metadata for UI, search, moderation, and
 * user profile purposes, including full support for text-based search,
 * author-based filtering, or parent-post selection.
 *
 * Request body parameters can specify filters like user_id, post_id, textual
 * content search (with trigrams), created/updated time intervals, and various
 * pagination/sorting options. Only comments not soft-deleted are shown unless
 * otherwise specified. Error cases include malformed requests, permissions, or
 * system errors. Accessible to any authenticated user for their own comments;
 * advanced cross-user search requires moderator/admin roles.
 *
 * @param props.connection
 * @param props.body Search/filter/pagination input for comments.
 * @path /discussionBoard/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search/filter/pagination input for comments. */
    body: IDiscussionBoardComment.IRequest;
  };
  export type Body = IDiscussionBoardComment.IRequest;
  export type Response = IPageIDiscussionBoardComment;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/comments";
  export const random = (): IPageIDiscussionBoardComment =>
    typia.random<IPageIDiscussionBoardComment>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get comment details by ID from discussion_board_comment.
 *
 * This endpoint returns all fields of a comment record by its unique
 * identifier. The Prisma schema comments highlight that each comment captures
 * atomic content and references the author, parent post, and supports full
 * audit history and edit/delete tracking. The operation supports all standard
 * error scenarios: not found (404), unauthorized (401), forbidden (403), and
 * server (500). Only authenticated users can access; viewing comment content is
 * generally public, but user-specific data may be restricted unless permissions
 * allow. Soft-deleted comments may be hidden to ordinary users unless a
 * moderation context is given. The result includes comment metadata, body,
 * author, timestamps, and any auditing linkages.
 *
 * @param props.connection
 * @param props.id UUID of the comment to retrieve.
 * @path /discussionBoard/comments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** UUID of the comment to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardComment;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/comments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/comments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardComment =>
    typia.random<IDiscussionBoardComment>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Edit/update comment content/details by ID in discussion_board_comment.
 *
 * This endpoint allows editing an existing comment by its ID, per schema
 * requirements that each comment may be edited (with updated_at tracking and
 * audit support). The endpoint first checks that the requestor is the comment
 * author, a moderator, or an admin. Updates are restricted to eligible fields
 * (e.g., content, last updated timestamp). Errors include 404 not found, 403
 * forbidden if not author/mod, or 400 for invalid input. A successful update
 * returns the complete new comment record. Old versions may be preserved for
 * audit if site moderation requires.
 *
 * @param props.connection
 * @param props.id UUID of the comment to edit.
 * @param props.body Editable fields for comments (e.g. content); schema driven.
 * @path /discussionBoard/comments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** UUID of the comment to edit. */
    id: string & tags.Format<"uuid">;

    /** Editable fields for comments (e.g. content); schema driven. */
    body: IDiscussionBoardComment.IUpdate;
  };
  export type Body = IDiscussionBoardComment.IUpdate;
  export type Response = IDiscussionBoardComment;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/comments/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/comments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardComment =>
    typia.random<IDiscussionBoardComment>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (soft) a comment by ID in discussion_board_comment (for audit
 * compliance).
 *
 * This endpoint soft-deletes a comment record by its ID, marking deleted_at in
 * the schema to preserve moderation, rollback, and audit trail requirements.
 * The operation is available to the author, site moderators, or admins as
 * permitted by forum policy. Non-authors cannot delete except as a moderator or
 * admin (permissions enforced). Deletion triggers notifications and audit
 * entries for compliance. Responses include success confirmation or errors for
 * not found (404), forbidden (403), or server failures (500). The deleted
 * record is not physically removed, but marked as deleted for audit and
 * compliance.
 *
 * @param props.connection
 * @param props.id UUID of comment to delete (soft).
 * @path /discussionBoard/comments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of comment to delete (soft). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/comments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/comments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDeleteResult => typia.random<IDeleteResult>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
