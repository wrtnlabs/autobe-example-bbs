import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardComment } from "../../../structures/IDiscussionBoardComment";
import { IPageIDiscussionBoardComment } from "../../../structures/IPageIDiscussionBoardComment";

/**
 * Create a comment in 'discussion_board_comments'.
 *
 * Accepts all client-supplied fields for new comment: post reference,
 * (optional) parent comment for nesting/threading, content, and creator.
 * Validation rules depend on text length, parent existence, and status of
 * post/thread. On success, creates comment and returns with full metadata.
 * Fails if not permitted (guest, banned), target unreachable, or validation
 * failed (F03/F04 compliance). Middleware ensures proper authentication and
 * business rule enforcement. Any moderation, reporting, or notification
 * workflows are triggered asynchronously.
 *
 * @param props.connection
 * @param props.body Info for new comment, including post reference, content,
 *   and optional parent comment.
 * @path /discussionBoard/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Info for new comment, including post reference, content, and optional
     * parent comment.
     */
    body: IDiscussionBoardComment.ICreate;
  };
  export type Body = IDiscussionBoardComment.ICreate;
  export type Response = IDiscussionBoardComment;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/comments";
  export const random = (): IDiscussionBoardComment =>
    typia.random<IDiscussionBoardComment>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/search comments from 'discussion_board_comments' with query.
 *
 * This endpoint implements flexible querying for comments, with request body
 * accepting filter fields (by post/thread, author/member, text search, date
 * range, etc.) and pagination/sorting. Returns list of comments adhering to
 * search and filter parameters per admin/policy. Output is paginated and
 * includes full comment record and navigation metadata. Permissions are
 * enforced to ensure that comments returned adhere to viewer's access rights
 * (e.g., visibility of deleted, hidden, or mod-only comments). Errors include
 * invalid inputs or system errors.
 *
 * @param props.connection
 * @param props.body Parameters for comment search, filter, and pagination.
 * @path /discussionBoard/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Parameters for comment search, filter, and pagination. */
    body: IDiscussionBoardComment.IRequest;
  };
  export type Body = IDiscussionBoardComment.IRequest;
  export type Response = IPageIDiscussionBoardComment;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/comments";
  export const random = (): IPageIDiscussionBoardComment =>
    typia.random<IPageIDiscussionBoardComment>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a comment from 'discussion_board_comments' by ID.
 *
 * Given a comment's unique identifier, this endpoint retrieves the comment with
 * all business and moderation fields (body, creator, parent reference, post
 * linkage, timestamps, and edit/deletion metadata). Used for rendering comment
 * detail views and facilitating mod review. Middleware must ensure access is
 * only permitted for eligible users (guests, members, mod, admin) and complies
 * with board visibility policies. Error responses arise from not found,
 * insufficient permissions, or accessing deleted content.
 *
 * @param props.connection
 * @param props.id ID of comment to retrieve (UUID).
 * @path /discussionBoard/comments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** ID of comment to retrieve (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardComment;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/comments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/comments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardComment =>
    typia.random<IDiscussionBoardComment>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a comment by its UUID (discussion_board_comments table).
 *
 * This API operation allows an authenticated member, moderator, or
 * administrator to update an existing comment. Reference is made to the
 * discussion_board_comments table, which includes attributes for edited status
 * and last modification timestamp. The comment to update is specified by its
 * unique UUID in the path. The request body must contain the new comment
 * content (body) and may optionally include updated edit flags. Only authorized
 * users (the comment's author, moderators, admins) may perform this operation.
 * This endpoint triggers an update to the is_edited column, records updated_at,
 * and supports audit compliance. If the comment is not found, or the actor
 * lacks permission, appropriate error responses are generated. This endpoint is
 * often used with comment retrieval and moderation APIs for complete lifecycle
 * management.
 *
 * @param props.connection
 * @param props.id The unique identifier (UUID) of the comment to update.
 * @param props.body The new content and edited status of the comment to be
 *   updated.
 * @path /discussionBoard/comments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** The unique identifier (UUID) of the comment to update. */
    id: string & tags.Format<"uuid">;

    /** The new content and edited status of the comment to be updated. */
    body: IDiscussionBoardComment.IUpdate;
  };
  export type Body = IDiscussionBoardComment.IUpdate;
  export type Response = IDiscussionBoardComment;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/comments/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/comments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardComment =>
    typia.random<IDiscussionBoardComment>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a comment by UUID (discussion_board_comments table).
 *
 * Allows authorized users (comment owner, moderator, or administrator) to
 * perform a soft deletion of a comment, marking it as deleted in the system (by
 * setting deleted_at). Key references in the discussion_board_comments table
 * include the id, deleted_at column, and possibly actor/audit logging. This
 * operation is essential for reversible moderation, content removal, and user
 * control over their contribution. If the comment is already deleted, a
 * not-modified or conflict error is returned; if unauthorized, a forbidden
 * error is triggered.
 *
 * @param props.connection
 * @param props.id Unique identifier (UUID) of the comment to be deleted.
 * @path /discussionBoard/comments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier (UUID) of the comment to be deleted. */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/comments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/comments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
