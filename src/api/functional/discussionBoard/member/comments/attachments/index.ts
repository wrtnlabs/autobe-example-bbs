import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIDiscussionBoardCommentAttachment } from "../../../../../structures/IPageIDiscussionBoardCommentAttachment";
import { IDiscussionBoardCommentAttachment } from "../../../../../structures/IDiscussionBoardCommentAttachment";

/**
 * List all attachments for a comment (discussion_board_comment_attachments).
 *
 * Return all attachment records for a specific comment, allowing members,
 * moderators, and admins to see/download/manage their own or others' files,
 * subject to permission checks. The result contains metadata (file name, URI,
 * uploaded_by, MIME type, timestamp) for each linked file, as defined by
 * discussion_board_comment_attachments. Supports user experience, moderation,
 * and audit flows.
 *
 * Security: Only comment owners, moderators, and admins can list attachments
 * for non-public comments. Attempts to access attachments for non-existent
 * comments, or by unauthorized users, are explicitly denied.
 *
 * @param props.connection
 * @param props.commentId Unique identifier (UUID) of the comment whose
 *   attachments to retrieve.
 * @path /discussionBoard/member/comments/:commentId/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier (UUID) of the comment whose attachments to
     * retrieve.
     */
    commentId: string & tags.Format<"uuid">;
  };
  export type Response = IPageIDiscussionBoardCommentAttachment;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/member/comments/:commentId/attachments",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/member/comments/${encodeURIComponent(props.commentId ?? "null")}/attachments`;
  export const random = (): IPageIDiscussionBoardCommentAttachment =>
    typia.random<IPageIDiscussionBoardCommentAttachment>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a new comment attachment record
 * (discussion_board_comment_attachments).
 *
 * Attach a new file to a comment, providing the file URL (external URI),
 * original file name, MIME type, and uploader's member ID. Only authenticated
 * members (comment owners) may create attachments, though staff may assist or
 * moderate as needed. The resulting record enables direct download, audit, and
 * moderation.
 *
 * Input is validated for file size/format/allowed types as per business rules
 * enforced at the application layer. Errors are returned for upload failures,
 * permission denials, or unsupported file types. Actions are logged for
 * compliance and reporting.
 *
 * @param props.connection
 * @param props.commentId Target comment's unique identifier (UUID) for
 *   attachment insertion.
 * @param props.body Details for the new file attachment (URL, file name, mime
 *   type, uploader).
 * @path /discussionBoard/member/comments/:commentId/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Target comment's unique identifier (UUID) for attachment insertion. */
    commentId: string & tags.Format<"uuid">;

    /**
     * Details for the new file attachment (URL, file name, mime type,
     * uploader).
     */
    body: IDiscussionBoardCommentAttachment.ICreate;
  };
  export type Body = IDiscussionBoardCommentAttachment.ICreate;
  export type Response = IDiscussionBoardCommentAttachment;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/member/comments/:commentId/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/comments/${encodeURIComponent(props.commentId ?? "null")}/attachments`;
  export const random = (): IDiscussionBoardCommentAttachment =>
    typia.random<IDiscussionBoardCommentAttachment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search/filter attachments for a comment
 * (discussion_board_comment_attachments).
 *
 * Retrieve a paginated and filtered list of attachment records for a specific
 * comment. Permitted filters include uploader_member_id, MIME type, file name,
 * and upload date range. Results are paginated and can be sorted as per
 * front-end requirements and business rules. Enables both user-facing browsing
 * and moderation/analytics workflows.
 *
 * Implementation honors all constraints and indexes from the Prisma schema's
 * discussion_board_comment_attachments table. Security requires that only the
 * comment author, admins, or moderators can use this search function. Error
 * handling includes missing comment, no matching attachments, and permission
 * denials.
 *
 * @param props.connection
 * @param props.commentId UUID of the comment to which attachments belong.
 * @param props.body Search and filter controls for attachment record listing
 *   (uploader, MIME type, file name, upload date, etc).
 * @path /discussionBoard/member/comments/:commentId/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** UUID of the comment to which attachments belong. */
    commentId: string & tags.Format<"uuid">;

    /**
     * Search and filter controls for attachment record listing (uploader,
     * MIME type, file name, upload date, etc).
     */
    body: IDiscussionBoardCommentAttachment.IRequest;
  };
  export type Body = IDiscussionBoardCommentAttachment.IRequest;
  export type Response = IPageIDiscussionBoardCommentAttachment;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/member/comments/:commentId/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/comments/${encodeURIComponent(props.commentId ?? "null")}/attachments`;
  export const random = (): IPageIDiscussionBoardCommentAttachment =>
    typia.random<IPageIDiscussionBoardCommentAttachment>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a specific comment attachment
 * (discussion_board_comment_attachments).
 *
 * Obtain detailed metadata for a specific attachment linked to a comment. Use
 * case includes user-initiated download, moderation display, or file inspection
 * for legal/audit purposes. Only the comment's author, related staff, or the
 * uploader can access attachment details. Attempts to retrieve attachments for
 * non-existent comments or files, or by unauthorized users, will return an
 * error.
 *
 * Maps to the discussion_board_comment_attachments table with a one-to-one
 * record match for given commentId and attachmentId.
 *
 * @param props.connection
 * @param props.commentId Parent comment's UUID identifier for attachment
 *   lookup.
 * @param props.attachmentId Unique identifier (UUID) of the attachment file to
 *   retrieve.
 * @path /discussionBoard/member/comments/:commentId/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Parent comment's UUID identifier for attachment lookup. */
    commentId: string & tags.Format<"uuid">;

    /** Unique identifier (UUID) of the attachment file to retrieve. */
    attachmentId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardCommentAttachment;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/member/comments/:commentId/attachments/:attachmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/member/comments/${encodeURIComponent(props.commentId ?? "null")}/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): IDiscussionBoardCommentAttachment =>
    typia.random<IDiscussionBoardCommentAttachment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Edit metadata for a comment attachment. Owner/staff only.
 *
 * Edit an attachment's metadata, such as file name, download URI, or MIME type.
 * Action is limited to the owner (uploader) or platform staff (admins,
 * moderators) for compliance, legal, or corrective workflows. All changes are
 * logged per audit requirements.
 *
 * Care is taken to maintain link validity (URI), file type compliance, and
 * correct ownership. Errors are returned for permission denial, non-existent
 * attachment, or invalid updates. Prerequisite: attachment must exist and
 * caller must have the correct privileges.
 *
 * @param props.connection
 * @param props.commentId UUID identifier (parent comment) for the attachment to
 *   modify.
 * @param props.attachmentId UUID identifier of the attachment being updated.
 * @param props.body Attachment metadata update payload (typically file
 *   name/uri/mime type only).
 * @path /discussionBoard/member/comments/:commentId/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID identifier (parent comment) for the attachment to modify. */
    commentId: string & tags.Format<"uuid">;

    /** UUID identifier of the attachment being updated. */
    attachmentId: string & tags.Format<"uuid">;

    /**
     * Attachment metadata update payload (typically file name/uri/mime type
     * only).
     */
    body: IDiscussionBoardCommentAttachment.IUpdate;
  };
  export type Body = IDiscussionBoardCommentAttachment.IUpdate;
  export type Response = IDiscussionBoardCommentAttachment;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/member/comments/:commentId/attachments/:attachmentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/comments/${encodeURIComponent(props.commentId ?? "null")}/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): IDiscussionBoardCommentAttachment =>
    typia.random<IDiscussionBoardCommentAttachment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a comment attachment record (hard delete; owner or staff only).
 *
 * Remove (hard-delete) a file attachment from a comment, allowed for the
 * original uploader, moderators, or admins. The file is removed from the
 * record, download is disabled, and associated logs are updated for
 * moderation/compliance. Error handling covers permission denials, missing
 * attachment, and failed deletions (e.g., referenced elsewhere).
 *
 * If the backend is configured, removal of the corresponding media from
 * external stores may also be triggered as part of the operation. The operation
 * abides by the normalization, logging, and audit requirements stated in the
 * schema and requirements.
 *
 * @param props.connection
 * @param props.commentId Parent comment's UUID (attachment association
 *   context).
 * @param props.attachmentId UUID of the specific attachment record to delete.
 * @path /discussionBoard/member/comments/:commentId/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Parent comment's UUID (attachment association context). */
    commentId: string & tags.Format<"uuid">;

    /** UUID of the specific attachment record to delete. */
    attachmentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/member/comments/:commentId/attachments/:attachmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/member/comments/${encodeURIComponent(props.commentId ?? "null")}/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
