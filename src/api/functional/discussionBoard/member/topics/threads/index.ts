import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardThreads } from "../../../../../structures/IDiscussionBoardThreads";

/**
 * Create a new thread under a specific topic (discussion_board_threads).
 *
 * Allows an authenticated member or higher to start a new thread in an existing
 * topic. Required input: thread title; optional: initial post body or metadata
 * (if supported by client workflows). Topic must exist and not be closed to
 * accept new threads.
 *
 * All thread creation records the creator member's ID, timestamp, and relevant
 * topic association in discussion_board_threads. Enforcement includes unique
 * title per topic and active, unlocked parent topic. Input validation occurs on
 * all updates.
 *
 * Authorization: Only members, moderators, and admins may create threads.
 * Errors returned for invalid parent or concurrency conflicts. Response
 * contains the completed thread object as confirmation and for navigation.
 *
 * @param props.connection
 * @param props.topicId UUID of the topic in which to create the thread.
 * @param props.body Field values for new thread: title (required), optional
 *   extended metadata if present.
 * @path /discussionBoard/member/topics/:topicId/threads
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** UUID of the topic in which to create the thread. */
    topicId: string & tags.Format<"uuid">;

    /**
     * Field values for new thread: title (required), optional extended
     * metadata if present.
     */
    body: IDiscussionBoardThreads.ICreate;
  };
  export type Body = IDiscussionBoardThreads.ICreate;
  export type Response = IDiscussionBoardThreads;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/member/topics/:topicId/threads",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/topics/${encodeURIComponent(props.topicId ?? "null")}/threads`;
  export const random = (): IDiscussionBoardThreads =>
    typia.random<IDiscussionBoardThreads>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("topicId")(() => typia.assert(props.topicId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a thread under a topic (discussion_board_threads).
 *
 * Updates the fields of an existing thread under a specific topic, as
 * identified by the UUIDs for topic and thread. Permitted edits include the
 * thread title and any additional metadata supported by the DTO. Only creators,
 * moderators, or admins with proper privileges may perform updates.
 *
 * Field validation includes unique thread title per topic. The operation audits
 * each change (as per requirements for traceability and rollback if needed). If
 * invalid reference, forbidden update, or constraint violation occurs, a clear
 * error is returned.
 *
 * Authorizations: Updaters must own the thread or hold moderator/admin
 * privileges over the topic. On success, updated thread object is returned.
 *
 * @param props.connection
 * @param props.topicId UUID of the topic to which the thread belongs.
 * @param props.threadId UUID of the thread to update.
 * @param props.body Field values to update on the thread: title and/or allowed
 *   metadata fields.
 * @path /discussionBoard/member/topics/:topicId/threads/:threadId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the topic to which the thread belongs. */
    topicId: string & tags.Format<"uuid">;

    /** UUID of the thread to update. */
    threadId: string & tags.Format<"uuid">;

    /**
     * Field values to update on the thread: title and/or allowed metadata
     * fields.
     */
    body: IDiscussionBoardThreads.IUpdate;
  };
  export type Body = IDiscussionBoardThreads.IUpdate;
  export type Response = IDiscussionBoardThreads;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/member/topics/:topicId/threads/:threadId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/member/topics/${encodeURIComponent(props.topicId ?? "null")}/threads/${encodeURIComponent(props.threadId ?? "null")}`;
  export const random = (): IDiscussionBoardThreads =>
    typia.random<IDiscussionBoardThreads>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("topicId")(() => typia.assert(props.topicId));
      assert.param("threadId")(() => typia.assert(props.threadId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
