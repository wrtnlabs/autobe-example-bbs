import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIDiscussionBoardCategory } from "../../../structures/IPageIDiscussionBoardCategory";
import { IDiscussionBoardCategory } from "../../../structures/IDiscussionBoardCategory";

/**
 * List and paginate all discussion board categories from the database.
 *
 * Retrieves a paginated list of all discussion board categories from the
 * discussion_board_categories schema. The response includes the full list of
 * categories, each with metadata such as name, description, parent category
 * linkage, active status, and timestamps.
 *
 * This endpoint is public and designed for both logged-in and guest users. It
 * enables navigation of the discussion board structure and supports UIs that
 * visualize topic hierarchies. Security is not enforced because category
 * browsing is a non-sensitive operation, and no personal user data is exposed.
 *
 * Behaviorally, it reflects the latest active/inactive category statuses and
 * parent-child relations. If categories are nested (using parent_id), responses
 * should preserve hierarchical context, but always as a flat list. For
 * bulk/batch operations or advanced filtering, use the corresponding PATCH
 * endpoint.
 *
 * Failure scenarios include database connectivity errors or malformed
 * pagination queries, which should produce user-friendly error responses.
 *
 * @param props.connection
 * @path /discussionBoard/categories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIDiscussionBoardCategory;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/categories",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/categories";
  export const random = (): IPageIDiscussionBoardCategory =>
    typia.random<IPageIDiscussionBoardCategory>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Advanced search, filtering, and sorting of discussion board categories with
 * pagination.
 *
 * Performs advanced filtering, searching, and sorting over the
 * discussion_board_categories entries, supporting UI scenarios where users or
 * admins require search, sort, or filter beyond simple listing.
 *
 * The endpoint accepts structured request parameters for filtering category
 * name (with partial matching), selection by active/inactive status, date range
 * queries, and parent_id-based hierarchical filtering. Sorting options may
 * include created_at, updated_at, or name. Pagination is enforced to prevent
 * overwhelming responses.
 *
 * This endpoint is critical for administration UIs, analytics tools, or
 * advanced browsing for large category sets. Security is open, as categories
 * are non-sensitive, but filtering may be more useful for admin roles. Misuse
 * may be mitigated by rate limiting or authentication in future deployments.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination criteria for querying
 *   categories.
 * @path /discussionBoard/categories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Search, filter, and pagination criteria for querying categories. */
    body: IDiscussionBoardCategory.IRequest;
  };
  export type Body = IDiscussionBoardCategory.IRequest;
  export type Response = IPageIDiscussionBoardCategory;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/categories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/categories";
  export const random = (): IPageIDiscussionBoardCategory =>
    typia.random<IPageIDiscussionBoardCategory>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details for a single discussion board category by its ID.
 *
 * Fetches full details of a single category using its unique ID from the
 * discussion_board_categories table. The returned object contains category
 * name, description, parent_id, is_active, and all system metadata.
 *
 * Use this to power category detail dialogs, edit interfaces, and navigational
 * breadcrumbs. Security: since category data contains no sensitive or
 * user-specific information, this endpoint is public. Ownership or
 * administrative privileges are not required for category lookup.
 *
 * Handles not-found or invalid ID errors gracefully, returning a 404 or
 * informative error object. Categories with parent_id set point to other
 * categories, enabling client-side construction of category trees.
 *
 * @param props.connection
 * @param props.categoryId Unique identifier for the target discussion board
 *   category.
 * @path /discussionBoard/categories/:categoryId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the target discussion board category. */
    categoryId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardCategory;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/categories/:categoryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/categories/${encodeURIComponent(props.categoryId ?? "null")}`;
  export const random = (): IDiscussionBoardCategory =>
    typia.random<IDiscussionBoardCategory>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("categoryId")(() => typia.assert(props.categoryId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
