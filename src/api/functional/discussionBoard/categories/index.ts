import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardCategory } from "../../../structures/IDiscussionBoardCategory";
import { IPageIDiscussionBoardCategory } from "../../../structures/IPageIDiscussionBoardCategory";

/**
 * Create a category in discussion_board_categories.
 *
 * Adds a new category for organizational or navigation purposes, supporting
 * top-level content classification for threads and posts as described in
 * business requirements. Request includes new category data â€” required name
 * plus optional description. Ownership, audit trail, and business
 * constraints/uniqueness enforced. Successful creation returns category
 * details. Error handling includes duplicate name and validation errors.
 * Creation typically restricted by policy to administrators or moderators, with
 * audit logging for compliance and management.
 *
 * @param props.connection
 * @param props.body Category creation information (name, description).
 * @path /discussionBoard/categories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Category creation information (name, description). */
    body: IDiscussionBoardCategory.ICreate;
  };
  export type Body = IDiscussionBoardCategory.ICreate;
  export type Response = IDiscussionBoardCategory;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/categories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/categories";
  export const random = (): IDiscussionBoardCategory =>
    typia.random<IDiscussionBoardCategory>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/search categories in discussion_board_categories.
 *
 * Obtains a paginated, filterable list of categories (top-level content
 * classifications) to display in menus, advanced search, and content creation
 * workflows. Supports full-text search, creation/update range filters, and
 * intended for both public and admin users, with permissions enforced for
 * sensitive fields/actions. Returns summaries suitable for listings or
 * selectors, satisfying search/discoverability and admin taxonomy
 * requirements.
 *
 * @param props.connection
 * @param props.body Search/filter conditions and pagination for categories.
 * @path /discussionBoard/categories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search/filter conditions and pagination for categories. */
    body: IDiscussionBoardCategory.IRequest;
  };
  export type Body = IDiscussionBoardCategory.IRequest;
  export type Response = IPageIDiscussionBoardCategory;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/categories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/categories";
  export const random = (): IPageIDiscussionBoardCategory =>
    typia.random<IPageIDiscussionBoardCategory>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details for a category in discussion_board_categories.
 *
 * Retrieves all available metadata for a specific category entity, such as
 * name, description, timestamps, and status. Used for admin interfaces,
 * category detail popups in end-user UX, or automated validation tools.
 * Not-found errors result when the category does not exist or is marked
 * deleted. Audit logging supports traceability; operation is read-only and
 * unrestricted in typical implementations.
 *
 * @param props.connection
 * @param props.id ID of category to fetch.
 * @path /discussionBoard/categories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** ID of category to fetch. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardCategory;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/categories/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/categories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardCategory =>
    typia.random<IDiscussionBoardCategory>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific discussion board category (discussion_board_categories).
 *
 * This API operation enables the update of a single discussion board category
 * identified by its unique ID. The endpoint relies on the
 * `discussion_board_categories` table, which stores the site's organizational
 * taxonomy, supporting forum browsing, search filtering, and topic grouping.
 *
 * Updates allowed include the category name, description, and possibly
 * soft-delete restoration. The request body follows the `.IUpdate` pattern and
 * may be restricted to administrators or moderators for security reasons.
 * Validation rules enforce name uniqueness (within site context), and update
 * time is automatically stamped. If the specified category does not exist or a
 * naming conflict arises, appropriate error handling is triggered.
 *
 * This endpoint fits into a typical CRUD suite for categories. It should be
 * used after category creation (`POST /discussionBoard/categories`) or
 * retrieval (`GET /discussionBoard/categories/{id}`) in an administrative
 * interface.
 *
 * @param props.connection
 * @param props.id Unique identifier of the category to update.
 * @param props.body Category update payload following .IUpdate pattern.
 * @path /discussionBoard/categories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier of the category to update. */
    id: string & tags.Format<"uuid">;

    /** Category update payload following .IUpdate pattern. */
    body: IDiscussionBoardCategory.IUpdate;
  };
  export type Body = IDiscussionBoardCategory.IUpdate;
  export type Response = IDiscussionBoardCategory;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/categories/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/categories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardCategory =>
    typia.random<IDiscussionBoardCategory>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (soft-delete) a specific discussion board category
 * (discussion_board_categories).
 *
 * This API operation facilitates the deletion (soft-delete) of an existing
 * discussion board category. The endpoint interacts directly with the
 * `discussion_board_categories` table, enabling system administrators or
 * moderators to mark a category as deleted by setting the `deleted_at`
 * timestamp.
 *
 * This soft-delete pattern preserves historical data, allowing the operation to
 * be reversible by system administrators. It ensures that user-generated
 * content under this category is not removed but referenced as belonging to a
 * deleted category, which may affect user navigation and administrative tasks.
 * System logs and audit trails are updated as required by compliance.
 *
 * If a category does not exist or is already deleted, appropriate error
 * messaging is enforced. This endpoint is used alongside category creation and
 * update operations for comprehensive lifecycle management.
 *
 * @param props.connection
 * @param props.id UUID of the category to delete.
 * @path /discussionBoard/categories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of the category to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardCategory;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/categories/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/categories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardCategory =>
    typia.random<IDiscussionBoardCategory>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
