import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardForumCategory } from "../../../structures/IDiscussionBoardForumCategory";
import { IPageDiscussionBoardForumCategory } from "../../../structures/IPageDiscussionBoardForumCategory";

/**
 * Create a forum category in discussion_board_forum_category (admin/moderator
 * only).
 *
 * This operation inserts a new forum category into
 * discussion_board_forum_category, creating a new root navigational entity for
 * discussions. Input must validate against
 * IDiscussionBoardForumCategory.ICreate request schema, including unique name
 * and optional description (enforced by business logic in the service layer).
 * Upon success, returns the full created forum category record. Related
 * endpoints include forum category update, delete, read and listing. The
 * operation is usually restricted to admins and high-ranking moderators to
 * avoid change collisions.
 *
 * @param props.connection
 * @param props.body Payload to create a new forum category
 * @path /discussionBoard/forumCategories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Payload to create a new forum category */
    body: IDiscussionBoardForumCategory.ICreate;
  };
  export type Body = IDiscussionBoardForumCategory.ICreate;
  export type Response = IDiscussionBoardForumCategory;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/forumCategories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/forumCategories";
  export const random = (): IDiscussionBoardForumCategory =>
    typia.random<IDiscussionBoardForumCategory>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/Filter forum categories in discussion_board_forum_category
 * (navigation/analytic).
 *
 * Returns a pageable and optionally filtered collection of forum category
 * records for the discussion board, supporting advanced UI navigation and
 * analytics tools. Filters may be applied to category name, creation/update
 * timestamps, and descriptions. Typically used by board UI, administrative
 * dashboards, or search/autocomplete. Related endpoints handle individual
 * category CRUD or category snapshot listings. Access may be open, or
 * restricted to certain user roles depending on business policy. Pagination and
 * search are integral for large boards. Response returns data in
 * IPageDiscussionBoardForumCategory format.
 *
 * @param props.connection
 * @param props.body Pagination and filter/search criteria for forum categories
 * @path /discussionBoard/forumCategories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Pagination and filter/search criteria for forum categories */
    body: IDiscussionBoardForumCategory.IRequest;
  };
  export type Body = IDiscussionBoardForumCategory.IRequest;
  export type Response = IPageDiscussionBoardForumCategory;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/forumCategories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/forumCategories";
  export const random = (): IPageDiscussionBoardForumCategory =>
    typia.random<IPageDiscussionBoardForumCategory>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single forum category record from discussion_board_forum_category.
 *
 * Retrieves the full record of a forum category specified by UUID, including
 * its name, description, creation/update dates, and other metadata. Interface
 * supports category information panels, editing interfaces, or deep category
 * search (either for navigation or analytic purposes). Related endpoints
 * support creation, update, delete, and snapshot/history operations. Errors are
 * clearly defined for not found or forbidden access cases.
 *
 * @param props.connection
 * @param props.id The forum category's unique identifier (UUID)
 * @path /discussionBoard/forumCategories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** The forum category's unique identifier (UUID) */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardForumCategory;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/forumCategories/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/forumCategories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardForumCategory =>
    typia.random<IDiscussionBoardForumCategory>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a forum category record in discussion_board_forum_category
 * (admin/moderator).
 *
 * This endpoint enables privileged users (admins/moderators) to update an
 * existing forum category's data, such as its name or description, based on
 * unique category UUID. Sends updated data via the request body conforming to
 * IDiscussionBoardForumCategory.IUpdate. Part of CRUD suite for category
 * management; related endpoints handle creation, retrieval, deletion, and
 * historical snapshotting. Business logic ensures unique name constraint and
 * may restrict changing categories with dependent subcategories to avoid
 * referential breaks. Returns the updated record upon success.
 *
 * @param props.connection
 * @param props.id Forum category unique identifier (UUID)
 * @param props.body Updated data for forum category
 * @path /discussionBoard/forumCategories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Forum category unique identifier (UUID) */
    id: string & tags.Format<"uuid">;

    /** Updated data for forum category */
    body: IDiscussionBoardForumCategory.IUpdate;
  };
  export type Body = IDiscussionBoardForumCategory.IUpdate;
  export type Response = IDiscussionBoardForumCategory;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/forumCategories/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/forumCategories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardForumCategory =>
    typia.random<IDiscussionBoardForumCategory>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a forum category from discussion_board_forum_category (admin/mod only,
 * referential checks).
 *
 * Removes a forum category entity from the discussion_board_forum_category
 * table by UUID. Deletion rules ensure that dependent subcategories are either
 * migrated, deleted, or the action is blocked according to platform policy.
 * Operation is logged for audit. Related endpoints cover category creation,
 * update, listing, and recovery of deleted categories if supported. API returns
 * errors for not found, insufficient permission, or business logic constraint
 * violations. Action is reserved for admins/moderators only.
 *
 * @param props.connection
 * @param props.id Target forum category unique identifier (UUID)
 * @path /discussionBoard/forumCategories/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target forum category unique identifier (UUID) */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/forumCategories/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/forumCategories/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
