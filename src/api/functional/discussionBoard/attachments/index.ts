import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardAttachment } from "../../../structures/IDiscussionBoardAttachment";
import { IPageIDiscussionBoardAttachment } from "../../../structures/IPageIDiscussionBoardAttachment";

/**
 * Upload new file attachment for discussion board
 * (discussion_board_attachments).
 *
 * Allows authenticated members to upload (register) a new attachment,
 * specifying either a parent post or comment, the file name, URI, content type,
 * content hash, and uploader information. Records metadata to the
 * discussion_board_attachments table to support attachment management, display,
 * and audit. Returns the created attachment object. Deduplication and file
 * validation business logic must be enforced on upload (e.g., unique
 * content_hash).
 *
 * @param props.connection
 * @param props.body Attachment metadata including parent (post/comment), file
 *   description, and content hash.
 * @path /discussionBoard/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Attachment metadata including parent (post/comment), file
     * description, and content hash.
     */
    body: IDiscussionBoardAttachment.ICreate;
  };
  export type Body = IDiscussionBoardAttachment.ICreate;
  export type Response = IDiscussionBoardAttachment;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/attachments";
  export const random = (): IDiscussionBoardAttachment =>
    typia.random<IDiscussionBoardAttachment>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/search discussion board attachments (discussion_board_attachments).
 *
 * Returns a paginated list of attachment metadata stored in the
 * discussion_board_attachments table. Supports advanced searching and filtering
 * over fields like file_name, content_type, uploader member, upload time, and
 * deletion status. This endpoint is crucial for both end-users browsing
 * attached content and moderators reviewing for policy compliance or abuse. The
 * PATCH method provides flexibility for complex search parameters in the
 * request body. Endpoint supports role-based access filtering and secured
 * content delivery URI (file_uri, not direct file blob).
 *
 * @param props.connection
 * @param props.body Search and filter criteria for attachment listing
 *   (file_name, date, uploader, status, etc).
 * @path /discussionBoard/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Search and filter criteria for attachment listing (file_name, date,
     * uploader, status, etc).
     */
    body: IDiscussionBoardAttachment.IRequest;
  };
  export type Body = IDiscussionBoardAttachment.IRequest;
  export type Response = IPageIDiscussionBoardAttachment;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/attachments";
  export const random = (): IPageIDiscussionBoardAttachment =>
    typia.random<IPageIDiscussionBoardAttachment>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single attachment by UUID (discussion_board_attachments).
 *
 * Retrieves a single attachment's full metadata by attachment UUID, as stored
 * in the discussion_board_attachments table. Data returned includes file name,
 * URI, content type, associated post/comment, uploader, timestamps, and
 * deletion status. Access is governed by attachment ownership or
 * moderation/admin privileges. If an attachment is soft-deleted or restricted,
 * the result may be filtered or access-denied.
 *
 * @param props.connection
 * @param props.id The unique identifier (UUID) of the attachment to retrieve.
 * @path /discussionBoard/attachments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** The unique identifier (UUID) of the attachment to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardAttachment;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/attachments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/attachments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardAttachment =>
    typia.random<IDiscussionBoardAttachment>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Edit/update attachment metadata (discussion_board_attachments).
 *
 * Updates key attributes of an existing attachment entry by UUID. Attributes
 * updated may include file name, content type, uri, and/or logical parent
 * (post/comment). Appropriate for members adjusting file descriptions, or
 * mods/admins resolving content issues. Modifies only metadata (never file
 * data), and enforces access control, deduplication, and audit updates
 * (updated_at).
 *
 * @param props.connection
 * @param props.id UUID of the attachment record to update.
 * @param props.body Updated attachment metadata fields.
 * @path /discussionBoard/attachments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** UUID of the attachment record to update. */
    id: string & tags.Format<"uuid">;

    /** Updated attachment metadata fields. */
    body: IDiscussionBoardAttachment.IUpdate;
  };
  export type Body = IDiscussionBoardAttachment.IUpdate;
  export type Response = IDiscussionBoardAttachment;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/attachments/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/attachments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardAttachment =>
    typia.random<IDiscussionBoardAttachment>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete an attachment by UUID (discussion_board_attachments).
 *
 * Marks an existing attachment record as deleted (soft delete) using its UUID.
 * Sets deleted_at without physically removing data, per audit/integrity
 * requirements. Action allowed for file owners, moderators, and admins with
 * proper permission checks. Moderation/abuse cases may require separate review
 * flows. Deleted files are not served for download unless restored.
 * Already-deleted records yield conflict response.
 *
 * @param props.connection
 * @param props.id UUID for the attachment to delete.
 * @path /discussionBoard/attachments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID for the attachment to delete. */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/attachments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/attachments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
