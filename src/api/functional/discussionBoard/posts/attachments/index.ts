import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardPostAttachment } from "../../../../structures/IDiscussionBoardPostAttachment";
import { IPageIDiscussionBoardPostAttachment } from "../../../../structures/IPageIDiscussionBoardPostAttachment";

/**
 * List all attachments for a single post (discussion_board_post_attachments).
 *
 * Fetches a complete list of attachments related to a specific discussion board
 * post. The discussion_board_post_attachments table captures every file
 * uploaded alongside a post, ensuring every file is traceable by uploader, MIME
 * type, and timestamp. All items returned pertain solely to the specified
 * postId, preserving tight referential integrity as enforced by the Prisma
 * schema.
 *
 * No authentication is required but authorization controls at the application
 * level should ensure that posts in restricted categories or topics are not
 * exposed to unauthorized users. Guest users may view attachments so long as
 * the post itself is public. Error handling ensures that invalid postId values
 * or attempts to access non-existent posts result in a suitable error message
 * and empty response.
 *
 * This API operation is typically used with post detail views, download UI, or
 * to power moderation dashboards for files.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post whose attachments are being
 *   requested.
 * @path /discussionBoard/posts/:postId/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the post whose attachments are being requested. */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardPostAttachment.ISummary;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/posts/:postId/attachments",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/posts/${encodeURIComponent(props.postId ?? "null")}/attachments`;
  export const random = (): IDiscussionBoardPostAttachment.ISummary =>
    typia.random<IDiscussionBoardPostAttachment.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search/filter attachments on a post with advanced query/post filters
 * (discussion_board_post_attachments).
 *
 * Enables efficient searching, filtering, and sorting of attachment records for
 * a designated post. Requesters can use rich filters—such as filtering by MIME
 * type, file uploader, upload date range, or partial matches on
 * filenames—permitted by the system's attributes on
 * discussion_board_post_attachments.
 *
 * A comprehensive request body allows specification of pagination settings and
 * desired sort order, making it suitable for large posts with many attachments.
 * Authorization is similar to the simple GET: guests can search attachments for
 * public posts, but resource-sensitive validation may restrict search
 * capabilities depending on board or post privacy level. The operation responds
 * with a paginated array of simplified attachment records, accompanied by
 * pagination metadata.
 *
 * Integrates naturally with advanced UI, moderation panels, or admin tools
 * inspecting files uploaded to a given post.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post whose attachments are being
 *   searched.
 * @param props.body Search criteria for filtering/sorting post attachments.
 * @path /discussionBoard/posts/:postId/attachments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Unique identifier of the post whose attachments are being searched. */
    postId: string & tags.Format<"uuid">;

    /** Search criteria for filtering/sorting post attachments. */
    body: IDiscussionBoardPostAttachment.IRequest;
  };
  export type Body = IDiscussionBoardPostAttachment.IRequest;
  export type Response = IPageIDiscussionBoardPostAttachment.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/posts/:postId/attachments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/posts/${encodeURIComponent(props.postId ?? "null")}/attachments`;
  export const random = (): IPageIDiscussionBoardPostAttachment.ISummary =>
    typia.random<IPageIDiscussionBoardPostAttachment.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get single attachment metadata and reference by post and attachment IDs
 * (discussion_board_post_attachments).
 *
 * Fetches detailed information about a single attachment file belonging to a
 * particular post. Uses both the post and attachment IDs to guarantee exact
 * record lookup, enforcing referential integrity as defined by the Prisma
 * schema (postId → discussion_board_posts.id, attachmentId →
 * discussion_board_post_attachments.id).
 *
 * Returns all metadata, including file URI, original name, mime type, uploader,
 * and upload timestamp, enabling both download workflows and file preview logic
 * in clients. Errors such as missing post, non-existent attachment, or orphaned
 * references are handled gracefully with clear error codes.
 *
 * The endpoint is accessed by any user with viewing rights to the post. For
 * sensitive content, permission checks on the parent post or category should
 * apply in middleware.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post that owns the attachment.
 * @param props.attachmentId Unique identifier of the attachment to retrieve.
 * @path /discussionBoard/posts/:postId/attachments/:attachmentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the post that owns the attachment. */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the attachment to retrieve. */
    attachmentId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardPostAttachment;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/posts/:postId/attachments/:attachmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/posts/${encodeURIComponent(props.postId ?? "null")}/attachments/${encodeURIComponent(props.attachmentId ?? "null")}`;
  export const random = (): IDiscussionBoardPostAttachment =>
    typia.random<IDiscussionBoardPostAttachment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("attachmentId")(() => typia.assert(props.attachmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
