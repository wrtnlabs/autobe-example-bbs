import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardConfiguration } from "../../../structures/IDiscussionBoardConfiguration";
import { IPageIDiscussionBoardConfiguration } from "../../../structures/IPageIDiscussionBoardConfiguration";

/**
 * Create a new discussion_board_configuration (admin-only, global settings).
 *
 * This endpoint receives a configuration creation request consisting of a
 * unique key, value, and optional descriptive text. On success, it will persist
 * the record and return the created entity with audit data
 * (created_at/updated_at). Enforced business logic includes checking for
 * duplicate keys and only permitting valid key/value pairs as specified by
 * system safeguard rules. Fulfills requirements for dynamic, runtime
 * configuration tuning without code deployments, as needed in administrative
 * operations and feature toggling workflows.
 *
 * @param props.connection
 * @param props.body Configuration key-value creation request body, including
 *   all required fields for a new configuration record.
 * @path /discussionBoard/configurations
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Configuration key-value creation request body, including all required
     * fields for a new configuration record.
     */
    body: IDiscussionBoardConfiguration.ICreate;
  };
  export type Body = IDiscussionBoardConfiguration.ICreate;
  export type Response = IDiscussionBoardConfiguration;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/configurations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/configurations";
  export const random = (): IDiscussionBoardConfiguration =>
    typia.random<IDiscussionBoardConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a list of discussion_board_configurations records for platform
 * settings management audit/tracking.
 *
 * This endpoint returns a filtered list of configuration key-value pairs when
 * provided with search/filter parameters such as key, value, or description. It
 * is only accessible to administrators, enforcing role-based access as
 * described in the specification. The configurations table supports audit trail
 * requirements by including created_at and updated_at metadata, allowing system
 * operators to track changes and review the existing configuration state
 * without modification rights. Pagination parameters serve non-functional
 * requirements for UI responsiveness and compliance with privacy principles by
 * avoiding data overload in large deployments. Related endpoints include GET
 * for detail retrieval and POST/PUT/DELETE for modification operations.
 *
 * @param props.connection
 * @param props.body Request parameters for configuration listing/searching
 *   (pagination, filters, etc.).
 * @path /discussionBoard/configurations
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Request parameters for configuration listing/searching (pagination,
     * filters, etc.).
     */
    body: IDiscussionBoardConfiguration.IRequest;
  };
  export type Body = IDiscussionBoardConfiguration.IRequest;
  export type Response = IPageIDiscussionBoardConfiguration;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/configurations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/configurations";
  export const random = (): IPageIDiscussionBoardConfiguration =>
    typia.random<IPageIDiscussionBoardConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific discussion_board_configuration record by UUID (admin-only
 * detail view).
 *
 * This endpoint returns the complete key, value, description, and audit
 * metadata for a specified configuration row, identified by its UUID in the
 * path parameter. It enforces role-based access (administrator only). The
 * configuration value is returned as stored (could be JSON or string), along
 * with audit trail dates to support change tracking and compliance review. This
 * endpoint is typically accessed when an admin clicks a configuration item in a
 * management UI for review or editing.
 *
 * @param props.connection
 * @param props.id Configuration record UUID (primary key to
 *   discussion_board_configurations.id).
 * @path /discussionBoard/configurations/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /**
     * Configuration record UUID (primary key to
     * discussion_board_configurations.id).
     */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardConfiguration;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/configurations/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/configurations/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardConfiguration =>
    typia.random<IDiscussionBoardConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing discussion_board_configuration by UUID (admin-only).
 *
 * Receives a configuration update request for the specified record, allowing
 * changes to the key, value, and description. On success, it updates the
 * corresponding fields and audit timestamps (updated_at) and returns the
 * modified configuration state. API enforces all business logic: only unique
 * keys, proper value formats, and full audit trail retention. This operation
 * directly supports administrative change management, rollback scenarios, and
 * audit logging.
 *
 * @param props.connection
 * @param props.id UUID of the configuration row to update (primary key to
 *   discussion_board_configurations.id).
 * @param props.body Full update data for the configuration row (key, value,
 *   description).
 * @path /discussionBoard/configurations/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /**
     * UUID of the configuration row to update (primary key to
     * discussion_board_configurations.id).
     */
    id: string & tags.Format<"uuid">;

    /** Full update data for the configuration row (key, value, description). */
    body: IDiscussionBoardConfiguration.IUpdate;
  };
  export type Body = IDiscussionBoardConfiguration.IUpdate;
  export type Response = IDiscussionBoardConfiguration;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/configurations/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/configurations/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardConfiguration =>
    typia.random<IDiscussionBoardConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a discussion_board_configuration (admin-only, by UUID, soft delete).
 *
 * Marks the specified configuration row as deleted (soft delete by setting
 * deleted_at timestamp) while preserving all audit data for future restoration
 * or compliance review. Triggers required system audit mechanisms and records
 * the deletion event for traceability. This endpoint is vital for system
 * tuning, decommissioning features, or cleaning up old configuration keys
 * according to IT governance rules.
 *
 * @param props.connection
 * @param props.id UUID of the configuration row to be deleted (primary key to
 *   discussion_board_configurations.id).
 * @path /discussionBoard/configurations/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /**
     * UUID of the configuration row to be deleted (primary key to
     * discussion_board_configurations.id).
     */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardConfiguration;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/configurations/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/configurations/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardConfiguration =>
    typia.random<IDiscussionBoardConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
