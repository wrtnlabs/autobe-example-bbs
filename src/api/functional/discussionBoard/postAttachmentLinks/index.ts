import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardPostAttachmentLink } from "../../../structures/IDiscussionBoardPostAttachmentLink";
import { IPageIDiscussionBoardPostAttachmentLink } from "../../../structures/IPageIDiscussionBoardPostAttachmentLink";

/**
 * Create new post-attachment link (discussion_board_post_attachment_link).
 *
 * The POST /discussionBoard/postAttachmentLinks endpoint creates a new link
 * between an existing post and a file attachment, setting the display order,
 * enabled/disabled status, and recording creation metadata. This operation
 * allows users (with valid permission, e.g., post author/admin) to attach files
 * to posts in a specific sequence, and ensures that no duplicate or invalid
 * linkages are created.
 *
 * Input validation includes: verifying that the referenced post_id and
 * attachment_id exist and belong to the permitted user, that the
 * attachment_order value is unique within the post, and all accompanying
 * metadata (created_at, disabled) is correctly initialized.
 *
 * Authorization restricts creation privileges to valid owners or moderators
 * with content rights. Related endpoints: PATCH (search/list), GET (single),
 * PUT (update), DELETE (remove). Error handling covers 400 (invalid request),
 * 403 (permission denied), and 409 (conflicting order or duplicate link).
 *
 * @param props.connection
 * @param props.body Creation info for a new post-attachment link (post_id,
 *   attachment_id, attachment_order, etc).
 * @path /discussionBoard/postAttachmentLinks
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /**
     * Creation info for a new post-attachment link (post_id, attachment_id,
     * attachment_order, etc).
     */
    body: IDiscussionBoardPostAttachmentLink.ICreate;
  };
  export type Body = IDiscussionBoardPostAttachmentLink.ICreate;
  export type Response = IDiscussionBoardPostAttachmentLink;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/postAttachmentLinks",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/postAttachmentLinks";
  export const random = (): IDiscussionBoardPostAttachmentLink =>
    typia.random<IDiscussionBoardPostAttachmentLink>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/query post-attachment links (discussion_board_post_attachment_link) with
 * search and pagination support.
 *
 * The PATCH /discussionBoard/postAttachmentLinks endpoint queries the
 * post-attachment linking table, enabling advanced retrieval and search
 * features for listing all or filtered links between posts and attached files.
 * This endpoint is critical for reconstructing file presentation orders,
 * auditing file associations, and performing bulk attachment management.
 *
 * Security considerations enforce that only authenticated users (and, if
 * needed, only those with admin or post owner privileges) can query post
 * attachment links.
 *
 * Business rules may include paginating lists of results, supporting text
 * search by post title/file names, and filtering by attachment status
 * (enabled/disabled). Relationships to users mean that the returned data will
 * often include join info such as file meta, user identity, and possible
 * soft-deletion status.
 *
 * Related endpoints are GET (for single records), POST (creation), PUT
 * (update), and DELETE (deletion). Requests that include complex search,
 * filtering, or sorting must use this PATCH endpoint for consistency with other
 * list-based resources. Error handling includes 404 (no results), 403
 * (unauthorized), and 400 (invalid search parameters).
 *
 * @param props.connection
 * @param props.body Request body for searching, filtering, and paginating
 *   post-attachment links.
 * @path /discussionBoard/postAttachmentLinks
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * Request body for searching, filtering, and paginating post-attachment
     * links.
     */
    body: IDiscussionBoardPostAttachmentLink.IRequest;
  };
  export type Body = IDiscussionBoardPostAttachmentLink.IRequest;
  export type Response = IPageIDiscussionBoardPostAttachmentLink;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/postAttachmentLinks",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/postAttachmentLinks";
  export const random = (): IPageIDiscussionBoardPostAttachmentLink =>
    typia.random<IPageIDiscussionBoardPostAttachmentLink>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single post-attachment link
 * (discussion_board_post_attachment_link) by unique ID.
 *
 * The GET /discussionBoard/postAttachmentLinks/{id} endpoint accesses a
 * specific post file attachment link by its unique identifier, returning the
 * complete set of linking information between a post and an attachment file.
 * This endpoint is used by the UI for displaying file attachments in detailed
 * view, debugging attachment relationships, or for users (with permissions) to
 * retrieve information about single file associations.
 *
 * Security/authorization is enforced so that only the owner, admin, or users
 * with specific privileges can access the endpoint. The relation to user, post,
 * and attachment details is included through joins if business logic requires
 * it.
 *
 * Expected errors include 404 (not found), 403 (unauthorized), or 410
 * (gone/soft deleted). Related endpoints are PATCH (list), POST (create), PUT
 * (update), and DELETE (remove attachment link).
 *
 * Business logic ensures that only valid, non-removed records are returned
 * unless a special "show deleted" flag is enabled for admins.
 *
 * @param props.connection
 * @param props.id ID of the post-attachment link (UUID).
 * @path /discussionBoard/postAttachmentLinks/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** ID of the post-attachment link (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardPostAttachmentLink;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/postAttachmentLinks/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/postAttachmentLinks/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardPostAttachmentLink =>
    typia.random<IDiscussionBoardPostAttachmentLink>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a post-attachment link (discussion_board_post_attachment_link) by ID.
 *
 * The PUT /discussionBoard/postAttachmentLinks/{id} endpoint provides full
 * update functionality for a specific post-attachment link, modifying fields
 * such as attachment order, the associated post or file (where allowed), and
 * the current enabled/disabled status.
 *
 * Authorization ensures only post owners or admins can modify links; validation
 * confirms update does not create order conflicts within the post or violate
 * file ownership requirements.
 *
 * All changes are audited (updated_at fields set) and invalid update attempts
 * result in 400/403/404 errors as appropriate.
 *
 * This operation is closely tied to PATCH (list/query), GET (single detail),
 * POST (create), and DELETE (remove) endpoints.
 *
 * @param props.connection
 * @param props.id ID of the post-attachment link (UUID).
 * @param props.body Full update parameters for the post-attachment link
 *   (attachment_order, status, etc).
 * @path /discussionBoard/postAttachmentLinks/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** ID of the post-attachment link (UUID). */
    id: string & tags.Format<"uuid">;

    /**
     * Full update parameters for the post-attachment link
     * (attachment_order, status, etc).
     */
    body: IDiscussionBoardPostAttachmentLink.IUpdate;
  };
  export type Body = IDiscussionBoardPostAttachmentLink.IUpdate;
  export type Response = IDiscussionBoardPostAttachmentLink;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/postAttachmentLinks/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/postAttachmentLinks/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardPostAttachmentLink =>
    typia.random<IDiscussionBoardPostAttachmentLink>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (soft or hard) a post-attachment link
 * (discussion_board_post_attachment_link) by ID.
 *
 * The DELETE /discussionBoard/postAttachmentLinks/{id} endpoint soft-deletes
 * (or permanently removes, if authorized) the post-attachment link for a
 * particular file from a post. This operation is essential for removing
 * obsolete, broken, or unauthorized attachment associations. Only owners,
 * administrators, or moderators can remove links; deletion is soft by default
 * with actual record flagged as deleted (deleted_at populated), but hard delete
 * is allowed for escalated admin operations.
 *
 * Security checks ensure the caller has permission to modify post/file
 * associations. The business rule prohibits deletion if the link is already not
 * active. Related endpoints: PATCH (list/search), GET (detail), POST (create),
 * PUT (update). All deletions are audit-logged and subject to review. Error
 * responses include 403 (unauthorized), 404 (not found), 409 (already deleted
 * or in use).
 *
 * @param props.connection
 * @param props.id ID of the post-attachment link (UUID).
 * @path /discussionBoard/postAttachmentLinks/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** ID of the post-attachment link (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardPostAttachmentLink.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/postAttachmentLinks/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/postAttachmentLinks/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardPostAttachmentLink.IDeleteResult =>
    typia.random<IDiscussionBoardPostAttachmentLink.IDeleteResult>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
