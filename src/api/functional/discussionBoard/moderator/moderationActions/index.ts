import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIDiscussionBoardModerationAction } from "../../../../structures/IPageIDiscussionBoardModerationAction";
import { IDiscussionBoardModerationAction } from "../../../../structures/IDiscussionBoardModerationAction";

/**
 * Paginated list of moderation actions for audit and transparency.
 *
 * Fetches a paginated, chronological or filtered list of moderation actions
 * performed on posts and comments. Leveraging the
 * discussion_board_moderation_actions schema, each item includes key fields
 * such as actor type, target entity, and action details. Includes links to
 * related report IDs if applicable.
 *
 * Access is typically restricted to moderation personnel or admins. Sensitive
 * information, such as internal notes, should be handled with care in the
 * frontend.
 *
 * Errors may include unauthorized requests or exceeding result limits. Related
 * endpoints include GET/PATCH for detailed or filtered queries throughout the
 * moderation pipeline.
 *
 * @param props.connection
 * @path /discussionBoard/moderator/moderationActions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIDiscussionBoardModerationAction.ISummary;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/moderator/moderationActions",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/moderator/moderationActions";
  export const random = (): IPageIDiscussionBoardModerationAction.ISummary =>
    typia.random<IPageIDiscussionBoardModerationAction.ISummary>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Create and log a new moderation action record for auditing and compliance.
 *
 * Allows authorized users (moderators or admins) to record a moderation action
 * as part of resolving a report, editing/removing content, or issuing warnings.
 * All required Foreign Keys (actor, content) must be valid and present in the
 * request. Additional information such as evidence, action notes, and
 * timestamps are stored atomically for audit and reporting.
 *
 * Attempts to create actions without proper references or permissions are
 * blocked by strict validation. Moderation actions are a core compliance
 * requirement; downstream integrations may notify affected parties or trigger
 * system events.
 *
 * @param props.connection
 * @param props.body New moderation action data, including references to actors
 *   and targets as applicable.
 * @path /discussionBoard/moderator/moderationActions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * New moderation action data, including references to actors and
     * targets as applicable.
     */
    body: IDiscussionBoardModerationAction.ICreate;
  };
  export type Body = IDiscussionBoardModerationAction.ICreate;
  export type Response = IDiscussionBoardModerationAction;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/moderator/moderationActions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/moderator/moderationActions";
  export const random = (): IDiscussionBoardModerationAction =>
    typia.random<IDiscussionBoardModerationAction>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Filtered, advanced search for moderation actions with pagination.
 *
 * Permits the admin or moderator to search for moderation actions using complex
 * filters. The request body describes filterable properties, pagination, and
 * sorting. Optimized for use in dashboards/analytics and supports time-window
 * audits or targeted workflow queries.
 *
 * Permissioned for roles with moderation authority. Malformed or unauthorized
 * requests are rejected with clear error details. Results are typically linked
 * to underlying report, post, or comment entities for contextual inspection.
 *
 * The response contains summaries of actions keyed by unique moderation action
 * UUIDs.
 *
 * @param props.connection
 * @param props.body Complex search filters and pagination for moderation
 *   actions.
 * @path /discussionBoard/moderator/moderationActions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Complex search filters and pagination for moderation actions. */
    body: IDiscussionBoardModerationAction.IRequest;
  };
  export type Body = IDiscussionBoardModerationAction.IRequest;
  export type Response = IPageIDiscussionBoardModerationAction.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/moderator/moderationActions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/moderator/moderationActions";
  export const random = (): IPageIDiscussionBoardModerationAction.ISummary =>
    typia.random<IPageIDiscussionBoardModerationAction.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch all details for an identified moderation action by ID.
 *
 * Provides a full record of a specific moderation action with all metadata from
 * the underlying moderation_action entity, such as involved actor(s), affected
 * content (post/comment), linked report, action type, and timestamps.
 *
 * Permissioned for moderators and admins only due to sensitivity of audit data.
 * Invalid or unauthorized requests result in descriptive error messages, with
 * no data leak of sensitive details.
 *
 * Commonly used for audit trails or to review the handling of individual
 * reports or content moderation incidents.
 *
 * @param props.connection
 * @param props.moderationActionId UUID of the moderation action to retrieve.
 * @path /discussionBoard/moderator/moderationActions/:moderationActionId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the moderation action to retrieve. */
    moderationActionId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardModerationAction;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/moderator/moderationActions/:moderationActionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/moderator/moderationActions/${encodeURIComponent(props.moderationActionId ?? "null")}`;
  export const random = (): IDiscussionBoardModerationAction =>
    typia.random<IDiscussionBoardModerationAction>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderationActionId")(() =>
        typia.assert(props.moderationActionId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update or annotate a specific moderation action record.
 *
 * Enables authorized actors to update the attributes of a recorded moderation
 * action, such as correcting action details, changing associations, or updating
 * evidence or notes. Strictly validates data against modifiable schema fields.
 * Updated timestamps recorded for all changes as per audit and compliance
 * specs.
 *
 * Only moderation-authorized roles may access this endpoint; privilege checks
 * are enforced. Error scenarios include attempting to update immutable,
 * missing, or non-existent records.
 *
 * Frequently paired with GET endpoints to review and update moderation logs as
 * part of compliance cycles.
 *
 * @param props.connection
 * @param props.moderationActionId UUID of the moderation action to update.
 * @param props.body Fields and references permitted for update to a moderation
 *   action.
 * @path /discussionBoard/moderator/moderationActions/:moderationActionId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the moderation action to update. */
    moderationActionId: string & tags.Format<"uuid">;

    /** Fields and references permitted for update to a moderation action. */
    body: IDiscussionBoardModerationAction.IUpdate;
  };
  export type Body = IDiscussionBoardModerationAction.IUpdate;
  export type Response = IDiscussionBoardModerationAction;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/moderator/moderationActions/:moderationActionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/moderator/moderationActions/${encodeURIComponent(props.moderationActionId ?? "null")}`;
  export const random = (): IDiscussionBoardModerationAction =>
    typia.random<IDiscussionBoardModerationAction>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderationActionId")(() =>
        typia.assert(props.moderationActionId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
