import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIDiscussionBoardActivityLog } from "../../../../structures/IPageIDiscussionBoardActivityLog";
import { IDiscussionBoardActivityLog } from "../../../../structures/IDiscussionBoardActivityLog";

/**
 * List activity logs (discussion_board_activity_logs table).
 *
 * Retrieve a paginated list of activity logs from the
 * discussion_board_activity_logs table. Logs track actions by all actors
 * (members, moderators, admins, guests), including activity type (views, posts,
 * moderation, etc.), target entity, and context information like IP address or
 * user agent.
 *
 * Filtering/sorting may be restricted to high-privilege roles (admin,
 * moderator). Used by analytics dashboards, moderation audit, and compliance
 * systems. Pagination and basic filtering are supported. Related: PATCH
 * /activityLogs for advanced search, GET /activityLogs/{activityLogId} for
 * single record view.
 *
 * @param props.connection
 * @path /discussionBoard/moderator/activityLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIDiscussionBoardActivityLog;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/moderator/activityLogs",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/moderator/activityLogs";
  export const random = (): IPageIDiscussionBoardActivityLog =>
    typia.random<IPageIDiscussionBoardActivityLog>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Create a new activity log entry (discussion_board_activity_logs).
 *
 * Create a new system activity log entry, typically related to security,
 * moderation actions, audit trail events, or high-value analytics. Only
 * high-privilege actors (admin, moderator, automated systems) can log activity
 * events. All mandatory fields from the activity log schema (actor, action,
 * target(s), timestamp) must be supplied and are validated.
 *
 * Audit log creation is a compliance requirement for moderator/admin actions
 * and is supported by background jobs or system triggers. Related endpoints
 * include GET/PATCH for retrieval and analytics.
 *
 * @param props.connection
 * @param props.body Full specification of the activity event to log
 * @path /discussionBoard/moderator/activityLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Full specification of the activity event to log */
    body: IDiscussionBoardActivityLog.ICreate;
  };
  export type Body = IDiscussionBoardActivityLog.ICreate;
  export type Response = IDiscussionBoardActivityLog;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/moderator/activityLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/moderator/activityLogs";
  export const random = (): IDiscussionBoardActivityLog =>
    typia.random<IDiscussionBoardActivityLog>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search/filter activity logs with advanced parameters
 * (discussion_board_activity_logs).
 *
 * Perform a robust, filtered query of the system's activity logs for analytics
 * or compliance needs. Enables searching by time interval, actor role/type,
 * action type, entity involved, or by user agent/IP. Supports extensive audit
 * trails for site admins and moderators as required by analytics and workflow
 * reporting.
 *
 * Authorization protects access to high-sensitivity activity data. Results can
 * be sorted/paged as required by dashboard or investigation features. Use with
 * GET (single fetch) or PATCH (batch/filtered query) as needed.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination settings for activity logs
 * @path /discussionBoard/moderator/activityLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Search, filter, and pagination settings for activity logs */
    body: IDiscussionBoardActivityLog.IRequest;
  };
  export type Body = IDiscussionBoardActivityLog.IRequest;
  export type Response = IPageIDiscussionBoardActivityLog;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/moderator/activityLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/moderator/activityLogs";
  export const random = (): IPageIDiscussionBoardActivityLog =>
    typia.random<IPageIDiscussionBoardActivityLog>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details for one activity log entry by ID
 * (discussion_board_activity_logs).
 *
 * Fetch the full details for one activity log entry given a unique
 * activityLogId. Returns all properties from the discussion_board_activity_logs
 * table, including actor info, target entities, time, action type, meta fields,
 * user agent, IP, and any extensible JSON metadata.
 *
 * Access is governed by role-based controls; only admins and moderators can
 * access full log data. Used for incident analysis, compliance audits, and
 * dashboard drilldowns. Related: PATCH for batch query; DELETE for log removal
 * (if implemented), GET for lists.
 *
 * @param props.connection
 * @param props.activityLogId Unique identifier of the activity log entry to
 *   fetch
 * @path /discussionBoard/moderator/activityLogs/:activityLogId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the activity log entry to fetch */
    activityLogId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardActivityLog;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/moderator/activityLogs/:activityLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/moderator/activityLogs/${encodeURIComponent(props.activityLogId ?? "null")}`;
  export const random = (): IDiscussionBoardActivityLog =>
    typia.random<IDiscussionBoardActivityLog>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("activityLogId")(() => typia.assert(props.activityLogId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an activity log entry by ID (discussion_board_activity_logs).
 *
 * Update one or more attributes of an activity log record. Supported fields
 * include metadata updates, user agent/IP clarifications, or changing typed
 * details. Critical for compliance error correction, after-the-fact data
 * additions, or to resolve disputes. All updates require admin or moderator
 * access; every change is separately logged and authorized.
 *
 * Coordinate with GET for single view, POST for explicit log creation, or PATCH
 * for batch reporting. Unauthorized or improperly validated updates are denied
 * and fully audited.
 *
 * @param props.connection
 * @param props.activityLogId Unique identifier of the activity log entry to
 *   update
 * @param props.body Specification of activity log fields to update
 * @path /discussionBoard/moderator/activityLogs/:activityLogId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the activity log entry to update */
    activityLogId: string & tags.Format<"uuid">;

    /** Specification of activity log fields to update */
    body: IDiscussionBoardActivityLog.IUpdate;
  };
  export type Body = IDiscussionBoardActivityLog.IUpdate;
  export type Response = IDiscussionBoardActivityLog;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/moderator/activityLogs/:activityLogId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/moderator/activityLogs/${encodeURIComponent(props.activityLogId ?? "null")}`;
  export const random = (): IDiscussionBoardActivityLog =>
    typia.random<IDiscussionBoardActivityLog>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("activityLogId")(() => typia.assert(props.activityLogId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete an activity log entry by ID (discussion_board_activity_logs).
 *
 * Delete an existing activity log entry entirely from the
 * discussion_board_activity_logs table. With no soft-delete column in the
 * schema, this is a hard delete, suitable for legal, compliance, or
 * audit-clearing operations. Deletion is strictly limited to admin or moderator
 * roles, and every erase is separately logged for compliance.
 *
 * Operation must block unauthorized deletions and handle not found or
 * already-deleted errors clearly. Use with GET/PATCH for fetching entries
 * before erase, and coordinate with wider retention/data management workflows.
 *
 * @param props.connection
 * @param props.activityLogId Unique identifier for log entry to remove
 * @path /discussionBoard/moderator/activityLogs/:activityLogId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for log entry to remove */
    activityLogId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/moderator/activityLogs/:activityLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/moderator/activityLogs/${encodeURIComponent(props.activityLogId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("activityLogId")(() => typia.assert(props.activityLogId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
