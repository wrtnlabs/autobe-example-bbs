import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardRoleAssignment } from "../../../structures/IDiscussionBoardRoleAssignment";
import { IPageIDiscussionBoardRoleAssignment } from "../../../structures/IPageIDiscussionBoardRoleAssignment";

/**
 * Creates a new role assignment for a user (discussion_board_role_assignment
 * table).
 *
 * This API endpoint creates a new role assignment for a user, as defined in the
 * discussion_board_role_assignment Prisma schema table. The endpoint supports
 * administrators in assigning a new role to a user, with strict enforcement
 * that each assignment is atomic and records both the assignment timestamp and,
 * optionally, a future revocation timestamp. This operation is critical for
 * upholding the role-based access control described in the requirements
 * analysis, allowing for fine-grained and auditable management of member,
 * moderator, admin, or guest privileges.
 *
 * The request body must include the user_id of the target, the role_type to be
 * assigned (valid roles: member, moderator, admin, guest), and the assigned_at
 * timestamp. The endpoint should validate that the role assignment does not
 * duplicate an active role for the same user and that role revocation rules are
 * followed. Proper handling of business errors and permission checks must be
 * enforced.
 *
 * Related endpoints include updating (PUT), deleting (DELETE), and listing
 * (PATCH) role assignments. Only users with the appropriate administrator
 * privileges can use this endpoint. Errors may occur if the user does not
 * exist, the role already exists for this user and period, or the assignment
 * data is invalid.
 *
 * @param props.connection
 * @param props.body Information required to create a role assignment for a
 *   user.
 * @path /discussionBoard/roleAssignments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Information required to create a role assignment for a user. */
    body: IDiscussionBoardRoleAssignment.ICreate;
  };
  export type Body = IDiscussionBoardRoleAssignment.ICreate;
  export type Response = IDiscussionBoardRoleAssignment;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/roleAssignments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/roleAssignments";
  export const random = (): IDiscussionBoardRoleAssignment =>
    typia.random<IDiscussionBoardRoleAssignment>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/query role assignments (discussion_board_role_assignment) with filters
 * and pagination.
 *
 * The PATCH /discussionBoard/roleAssignments endpoint retrieves lists of user
 * role assignments ('discussion_board_role_assignment' table), supporting
 * filters by user id, role type, assignment/revocation dates, etc. Results are
 * paginated and sortable for efficient admin and moderator workflows.
 *
 * Used for auditing role histories, monitoring moderation and admin
 * assignments, and as part of escalated privilege operations. Prior
 * authorization is required.
 *
 * Input validation covers pagination and filter structure. Errors are returned
 * for malformed input or unauthorized access. Paginated output details role
 * assignments, with user and role references as applicable. Close link with
 * endpoints for user record management and role-specific metadata (admin,
 * moderator).
 *
 * @param props.connection
 * @param props.body Role assignment filter and pagination request.
 * @path /discussionBoard/roleAssignments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Role assignment filter and pagination request. */
    body: IDiscussionBoardRoleAssignment.IRequest;
  };
  export type Body = IDiscussionBoardRoleAssignment.IRequest;
  export type Response = IPageIDiscussionBoardRoleAssignment;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/roleAssignments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/roleAssignments";
  export const random = (): IPageIDiscussionBoardRoleAssignment =>
    typia.random<IPageIDiscussionBoardRoleAssignment>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Read a single role assignment (discussion_board_role_assignment) by id.
 *
 * The GET /discussionBoard/roleAssignments/{id} endpoint retrieves a single
 * role assignment entity from the discussion_board_role_assignment table for
 * the specified UUID.
 *
 * It returns full assignment details, including user id, role_type, assignment
 * date, and revocation date, supporting platform and user audit use cases. It
 * is employed by administrative interfaces, audit dashboards, or moderator
 * privilege review features.
 *
 * Path parameter must be a valid UUID. Errors occur for not-found or
 * unauthorized requests. The endpoint links to role assignment operations and
 * user core CRUD endpoints.
 *
 * @param props.connection
 * @param props.id UUID of the role assignment entity to fetch.
 * @path /discussionBoard/roleAssignments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** UUID of the role assignment entity to fetch. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardRoleAssignment;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/roleAssignments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/roleAssignments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardRoleAssignment =>
    typia.random<IDiscussionBoardRoleAssignment>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Updates an existing role assignment by ID (discussion_board_role_assignment
 * table).
 *
 * This API endpoint updates an existing role assignment specified by its ID, as
 * defined in the discussion_board_role_assignment table. The operation lets
 * administrators change the role type (e.g., from 'member' to 'moderator'), set
 * or alter the revoke date, or update audit metadata. Every change is logged
 * and subject to strict permission checks, ensuring alignment with the system's
 * audit trail requirements and security best practices.
 *
 * The request body must provide the necessary update fields, including
 * role_type and revoked_at if modifying revocation date. Previous assignment
 * and revocation timestamps are not changed retroactively. Related endpoints
 * include assignment creation (POST), removal (DELETE), and audit listing
 * (PATCH). Only users with administrator privileges are allowed to perform this
 * update. Errors include: role assignment not found, invalid modification to
 * past assignments, or permission denial.
 *
 * @param props.connection
 * @param props.id The ID of the role assignment to update.
 * @param props.body Fields to update in the role assignment (e.g., role_type,
 *   revoked_at).
 * @path /discussionBoard/roleAssignments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** The ID of the role assignment to update. */
    id: string & tags.Format<"uuid">;

    /**
     * Fields to update in the role assignment (e.g., role_type,
     * revoked_at).
     */
    body: IDiscussionBoardRoleAssignment.IUpdate;
  };
  export type Body = IDiscussionBoardRoleAssignment.IUpdate;
  export type Response = IDiscussionBoardRoleAssignment;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/roleAssignments/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/roleAssignments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardRoleAssignment =>
    typia.random<IDiscussionBoardRoleAssignment>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Deletes a specific role assignment by ID (discussion_board_role_assignment
 * table).
 *
 * This endpoint deletes a specific role assignment identified by ID from the
 * discussion_board_role_assignment table. The operation revokes the associated
 * privileges and is a core part of the compliance process outlined in the
 * requirements analysis. Only administrator-level users are allowed to invoke
 * this endpoint, and all deletions should be logged for audit purpose.
 *
 * The path parameter 'id' must be a valid UUID corresponding to the assignment
 * to be deleted. Role assignment records tied to unrevoked or critical
 * permissions may require additional business validation before deletion. If
 * the operation is successful, the role is removed, and an audit log is
 * generated. Related endpoints: role assignment creation (POST), update (PUT),
 * and listing (PATCH). Error states: assignment not found, permission denied,
 * or business logic violation.
 *
 * @param props.connection
 * @param props.id The ID of the role assignment to delete.
 * @path /discussionBoard/roleAssignments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** The ID of the role assignment to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardRoleAssignment;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/roleAssignments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/roleAssignments/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardRoleAssignment =>
    typia.random<IDiscussionBoardRoleAssignment>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
