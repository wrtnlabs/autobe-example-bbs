import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardSection } from "../../../structures/IDiscussionBoardSection";
import { IPageIDiscussionBoardSection } from "../../../structures/IPageIDiscussionBoardSection";

/**
 * Create a new section (discussion_board_sections).
 *
 * Creates a new section within an existing discussion board channel. This
 * operation enables the logical organization of threads and posts by
 * establishing a new category/subdivision under a parent channel (e.g.,
 * 'Legislation' under 'Politics'). The API validates that the specified parent
 * channel exists, that the code is unique within the channel, and that the name
 * and metadata follow board conventions. Only authorized roles with section
 * creation privileges (such as admins) can invoke this. The endpoint refers to
 * the strict 3NF-compliant schema with only atomic fields for the section
 * entity. On success, it returns the created section's complete data, including
 * audit timestamps. Validation errors (such as code duplication or missing
 * fields) are handled with informative error responses.
 *
 * @param props.connection
 * @param props.body Section creation payload (discussion_board_sections).
 * @path /discussionBoard/sections
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Section creation payload (discussion_board_sections). */
    body: IDiscussionBoardSection.ICreate;
  };
  export type Body = IDiscussionBoardSection.ICreate;
  export type Response = IDiscussionBoardSection;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/sections",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/sections";
  export const random = (): IDiscussionBoardSection =>
    typia.random<IDiscussionBoardSection>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List and filter discussion_board_sections (forum/category listing,
 * paginated).
 *
 * Returns a list of discussion_board_sections, each including section code,
 * name, description, and audit fields. This endpoint supports filtering on
 * name, code, parent channel, and description. Pagination options implement
 * non-functional requirements on performance and usability. Used in admin
 * dashboards, user discoverability flows, and for performance-optimized search.
 * Supports both admin role (full info) and public/member modes (limited info).
 *
 * @param props.connection
 * @param props.body List/filter/search parameters for retrieving
 *   discussion_board_sections.
 * @path /discussionBoard/sections
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * List/filter/search parameters for retrieving
     * discussion_board_sections.
     */
    body: IDiscussionBoardSection.IRequest;
  };
  export type Body = IDiscussionBoardSection.IRequest;
  export type Response = IPageIDiscussionBoardSection;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/sections",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/sections";
  export const random = (): IPageIDiscussionBoardSection =>
    typia.random<IPageIDiscussionBoardSection>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific discussion_board_section (forum or section) by UUID, with
 * detail fields.
 *
 * Returns all metadata and audit fields for the specified section (id, code,
 * name, parent channel, description, timestamps, soft-delete). Used for admin
 * detail view, forum page linking, and UI analytics. May be public or
 * restricted depending on forum's privacy settings (default: accessible to all
 * users except soft-deleted sections).
 *
 * @param props.connection
 * @param props.id UUID for the section/forum row to retrieve
 *   (discussion_board_sections.id).
 * @path /discussionBoard/sections/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /**
     * UUID for the section/forum row to retrieve
     * (discussion_board_sections.id).
     */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardSection;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/sections/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/sections/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardSection =>
    typia.random<IDiscussionBoardSection>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a section by ID (discussion_board_sections).
 *
 * Updates an existing section in the discussion board, allowing administrators
 * to modify the name, description, or code (if permitted by business logic) of
 * a section under a parent channel. The operation performs validation on
 * uniqueness (section code within channel) and parent channel integrity. It
 * logs update events via audit timestamps, and can optionally support partial
 * updates if the schema is designed. This operation references the 3NF
 * discussion_board_sections entity. Only authorized roles (administrators) can
 * perform updates, and the operation validates access rights prior to
 * modification.
 *
 * @param props.connection
 * @param props.id UUID of the section to update.
 * @param props.body Section update payload (discussion_board_sections).
 * @path /discussionBoard/sections/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** UUID of the section to update. */
    id: string & tags.Format<"uuid">;

    /** Section update payload (discussion_board_sections). */
    body: IDiscussionBoardSection.IUpdate;
  };
  export type Body = IDiscussionBoardSection.IUpdate;
  export type Response = IDiscussionBoardSection;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/sections/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/sections/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardSection =>
    typia.random<IDiscussionBoardSection>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a section by ID (discussion_board_sections).
 *
 * Soft deletes a section from the discussion board by setting its deleted_at
 * timestamp. This supports moderation/admin workflows for reversible content
 * management, rather than hard-deleting rows. The API checks for section
 * existence and may verify that no threads remain assigned to this section, as
 * per business logic. Only users with the administrator role may invoke this
 * operation. The endpoint ensures audit trail integrity with corresponding
 * timestamp updates and can be extended for restore/undelete operations.
 *
 * @param props.connection
 * @param props.id UUID of the section to delete.
 * @path /discussionBoard/sections/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of the section to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardSection;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/sections/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/sections/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardSection =>
    typia.random<IDiscussionBoardSection>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
