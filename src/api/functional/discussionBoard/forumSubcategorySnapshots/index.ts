import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardForumSubcategorySnapshot } from "../../../structures/IDiscussionBoardForumSubcategorySnapshot";
import { IPageIDiscussionBoardForumSubcategorySnapshot } from "../../../structures/IPageIDiscussionBoardForumSubcategorySnapshot";
import { IDeleteResult } from "../../../structures/IDeleteResult";

/**
 * Create forum subcategory snapshot in
 * discussion_board_forum_subcategory_snapshot.
 *
 * This endpoint allows moderators or admins to create a new forum subcategory
 * snapshot. It is typically invoked during administrative edits to forum
 * subcategory metadata (name, description), to preserve a copy of the
 * subcategory's state before or after a change for full audit compliance. The
 * Prisma schema requires that snapshots include references to the source
 * subcategory and the user responsible for the change, along with the
 * name/description values.
 *
 * Access is restricted to staff-level users with moderator or admin roles, with
 * write authority. The request body must be a complete snapshot as per the form
 * fields described in the schema. Validations are performed for data integrity,
 * and errors include missing fields (400), forbidden access (403), and internal
 * errors (500). The response returns the newly created snapshot record,
 * confirming its persistent record in the audit log.
 *
 * @param props.connection
 * @param props.body Snapshot creation input containing all fields per schema.
 * @path /discussionBoard/forumSubcategorySnapshots
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Snapshot creation input containing all fields per schema. */
    body: IDiscussionBoardForumSubcategorySnapshot.ICreate;
  };
  export type Body = IDiscussionBoardForumSubcategorySnapshot.ICreate;
  export type Response = IDiscussionBoardForumSubcategorySnapshot;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/forumSubcategorySnapshots",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/forumSubcategorySnapshots";
  export const random = (): IDiscussionBoardForumSubcategorySnapshot =>
    typia.random<IDiscussionBoardForumSubcategorySnapshot>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/filter forum subcategory snapshots from
 * discussion_board_forum_subcategory_snapshot.
 *
 * This endpoint provides a list of all forum subcategory snapshots, each
 * representing a historical version of a subcategory. These records support
 * audit trails, moderation compliance, and potential restoration of previous
 * subcategory states as described in the Prisma schema. Only moderators or
 * admins should access this endpoint.
 *
 * The endpoint accepts a request body to specify search, filtering, pagination,
 * and sorting options. It allows narrow queries by forum_subcategory_id,
 * created_by_id, or time range, and supports sorting the results by snapshot
 * creation date or subcategory association. The response is a paginated
 * structure containing basic snapshot metadata and navigation details.
 * Soft-deleted snapshots are typically excluded from results unless a special
 * flag is specified.
 *
 * Error responses include improper permissions (403), malformed query
 * parameters (400), or internal server errors (500). Requests should be
 * authenticated with an appropriate staff-level (moderator/admin) token.
 *
 * @param props.connection
 * @param props.body Search/filter/pagination input for retrieving subcategory
 *   snapshots.
 * @path /discussionBoard/forumSubcategorySnapshots
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search/filter/pagination input for retrieving subcategory snapshots. */
    body: IDiscussionBoardForumSubcategorySnapshot.IRequest;
  };
  export type Body = IDiscussionBoardForumSubcategorySnapshot.IRequest;
  export type Response = IPageIDiscussionBoardForumSubcategorySnapshot;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/forumSubcategorySnapshots",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/forumSubcategorySnapshots";
  export const random = (): IPageIDiscussionBoardForumSubcategorySnapshot =>
    typia.random<IPageIDiscussionBoardForumSubcategorySnapshot>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get forum subcategory snapshot detail by ID from
 * discussion_board_forum_subcategory_snapshot.
 *
 * This endpoint returns the full details of a forum subcategory snapshot based
 * on its unique ID. It is typically used by moderators or administrators
 * reviewing moderation actions, performing audits, or preparing a rollback to
 * an earlier forum subcategory state. The Prisma schema comments highlight that
 * snapshots are immutable, 1:N related to the subcategory and to the user who
 * made the change, and store atomic fields only.
 *
 * Access is restricted to users with moderator or admin roles (authorization
 * required). A correct UUID ID is required as a path parameter. Errors include
 * not found (404), unauthorized/forbidden (401/403), and server issues (500).
 * The response includes all snapshot record fields and relationships per
 * schema, with full audit details.
 *
 * @param props.connection
 * @param props.id Unique identifier (UUID) of the forum subcategory snapshot to
 *   retrieve.
 * @path /discussionBoard/forumSubcategorySnapshots/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /**
     * Unique identifier (UUID) of the forum subcategory snapshot to
     * retrieve.
     */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardForumSubcategorySnapshot;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/forumSubcategorySnapshots/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/forumSubcategorySnapshots/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardForumSubcategorySnapshot =>
    typia.random<IDiscussionBoardForumSubcategorySnapshot>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update forum subcategory snapshot (exceptional cases) in
 * discussion_board_forum_subcategory_snapshot.
 *
 * This endpoint allows for updates to a forum subcategory snapshot, identified
 * by ID. The Prisma schema's comments detail the expectation that snapshots are
 * typically immutable, so this should only be used in rare cases where
 * corrections are legally required or for fixing major audit discrepancies (for
 * example, to correct abusive content that must not be published, or to
 * annotate a snapshot for legal hold). Use of this endpoint is heavily
 * restricted—only moderators/admins with the highest authority should have
 * access.
 *
 * Requires the unique snapshot ID as a path parameter. The request body must
 * specify only allowed fields as permitted by business rules (e.g.,
 * correction_reason, update_meta). Attempting to change historical fields in
 * ways that break audit trails should be strictly forbidden by both application
 * and review logic. Error conditions include not found (404), forbidden (403),
 * and validation errors (400).
 *
 * Every modification is itself auditable, and reasons for change should be
 * logged. The response returns the updated snapshot record as an assurance of
 * the change. Usage should be closely monitored.
 *
 * @param props.connection
 * @param props.id Unique identifier (UUID) of the forum subcategory snapshot to
 *   update.
 * @param props.body Fields allowed to update in snapshot correction context.
 * @path /discussionBoard/forumSubcategorySnapshots/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier (UUID) of the forum subcategory snapshot to update. */
    id: string & tags.Format<"uuid">;

    /** Fields allowed to update in snapshot correction context. */
    body: IDiscussionBoardForumSubcategorySnapshot.IUpdate;
  };
  export type Body = IDiscussionBoardForumSubcategorySnapshot.IUpdate;
  export type Response = IDiscussionBoardForumSubcategorySnapshot;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/forumSubcategorySnapshots/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/forumSubcategorySnapshots/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardForumSubcategorySnapshot =>
    typia.random<IDiscussionBoardForumSubcategorySnapshot>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete forum subcategory snapshot by ID from
 * discussion_board_forum_subcategory_snapshot.
 *
 * This endpoint deletes a forum subcategory snapshot record, identified by ID.
 * According to the Prisma schema, such deletion should be rare and highly
 * restricted, as snapshots form part of the system's compliance and audit
 * trail. Use this operation only where law, platform policy, or legal rulings
 * compel removal (such as GDPR or explicit court orders). All deletion actions
 * must be logged, authorized at the highest admin level, and the action itself
 * should create an immutable record elsewhere for traceability.
 *
 * A valid UUID ID is required in the path parameter. Errors include not found
 * (404), forbidden (403), and server errors (500). The response confirms the
 * deletion or returns appropriate failure details. This operation is not
 * reversible and should be subject to platform warnings and double-confirmation
 * workflows.
 *
 * @param props.connection
 * @param props.id UUID of the forum subcategory snapshot to delete.
 * @path /discussionBoard/forumSubcategorySnapshots/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of the forum subcategory snapshot to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/forumSubcategorySnapshots/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/forumSubcategorySnapshots/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDeleteResult => typia.random<IDeleteResult>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
