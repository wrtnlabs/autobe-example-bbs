import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardThread } from "../../../structures/IDiscussionBoardThread";
import { IPageDiscussionBoardThread } from "../../../structures/IPageDiscussionBoardThread";

/**
 * Create a new discussion thread (discussion_board_thread).
 *
 * This POST operation initiates topic creation by accepting thread definition
 * data (see 'IDiscussionBoardThread.ICreate'), creating a new record in the
 * discussion_board_thread table. Required fields include title, subcategory
 * reference, and author identification (authenticated user). The endpoint
 * ensures unique thread titles within a subcategory and applies business
 * validation for content, permissions, and state. On successful creation,
 * response returns the normalized thread record for immediate navigation or
 * display. Handles duplicate, unauthorized, or invalid requests with clear
 * error feedback.
 *
 * @param props.connection
 * @param props.body Thread creation data.
 * @path /discussionBoard/threads
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Thread creation data. */
    body: IDiscussionBoardThread.ICreate;
  };
  export type Body = IDiscussionBoardThread.ICreate;
  export type Response = IDiscussionBoardThread;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/threads",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/threads";
  export const random = (): IDiscussionBoardThread =>
    typia.random<IDiscussionBoardThread>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/search discussion threads (discussion_board_thread) with filters and
 * paging.
 *
 * This PATCH operation enables complex listing, searching, and filtering of
 * threads (forum topics) using the discussion_board_thread table, in accordance
 * with requirements for scalable forum organization. The request body
 * references 'IDiscussionBoardThread.IRequest' and may include filters by
 * subcategory, author, creation date, keywords, or sorting options. The
 * endpoint enforces access controls and returns relevant threads in a paged
 * response ('IPageDiscussionBoardThread'), including pagination metadata (page
 * size, number, etc.). Atomic field selection and normalized relationships
 * ensure high performance and consistent output. Ergonomic for both user
 * discovery experiences and admin dashboards. Handles empty result sets and
 * validation errors responsibly.
 *
 * @param props.connection
 * @param props.body Filters, paging, and sorting info for thread search
 * @path /discussionBoard/threads
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Filters, paging, and sorting info for thread search */
    body: IDiscussionBoardThread.IRequest;
  };
  export type Body = IDiscussionBoardThread.IRequest;
  export type Response = IPageDiscussionBoardThread;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/threads",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/threads";
  export const random = (): IPageDiscussionBoardThread =>
    typia.random<IPageDiscussionBoardThread>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific discussion thread (discussion_board_thread) by ID.
 *
 * This GET operation fetches all details of a selected discussion thread,
 * resolving relationships to posts and subcategory as needed. Backend logic
 * relies on the 'discussion_board_thread' table, using the thread's UUID (id)
 * for referential integrity and lookup. The endpoint incorporates standard
 * permission checks, surfacing 404/403 errors for non-existent or restricted
 * threads. Returned data is detailed, mapped to the latest normalized
 * structure, and suitable for both display and in-depth moderation analysis
 * (e.g., historical state, audit). Handles soft-deleted and hidden state per
 * system rules.
 *
 * @param props.connection
 * @param props.id UUID of the thread to retrieve.
 * @path /discussionBoard/threads/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** UUID of the thread to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardThread;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/threads/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/threads/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardThread =>
    typia.random<IDiscussionBoardThread>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a discussion thread (discussion_board_thread) by ID.
 *
 * This PUT operation allows thread metadata to be edited, enabling users or
 * moderators to update title, move threads to new subcategories, or enforce
 * moderation actions per platform policy. The target is selected via path
 * parameter 'id', with new values provided in 'IDiscussionBoardThread.IUpdate'
 * format in the request body. Data integrity is maintained under Prisma
 * relationships and normalized requirements. Audit timestamps are refreshed
 * upon update, and all changes reflect immediately in read-side projections.
 * Returns updated thread or error information if constraints or permissions
 * block the action.
 *
 * @param props.connection
 * @param props.id UUID of the thread to update.
 * @param props.body Updated thread data.
 * @path /discussionBoard/threads/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** UUID of the thread to update. */
    id: string & tags.Format<"uuid">;

    /** Updated thread data. */
    body: IDiscussionBoardThread.IUpdate;
  };
  export type Body = IDiscussionBoardThread.IUpdate;
  export type Response = IDiscussionBoardThread;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/threads/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/threads/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardThread =>
    typia.random<IDiscussionBoardThread>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a discussion thread (discussion_board_thread) by ID.
 *
 * This DELETE operation soft-deletes a thread entity by updating the
 * 'deleted_at' timestamp in accordance with forum moderation policy. The
 * endpoint enforces business rules for authorship and moderator/admin
 * permissions, drawing thread records from the discussion_board_thread table
 * using a validated UUID. The response returns a confirmation or the deleted
 * record, suit for audit logging and user notification. Handles edge cases
 * (thread not found, access denied, dependent resources) responsibly, in line
 * with best practices for 3NF data integrity and role-based access security.
 *
 * @param props.connection
 * @param props.id UUID of the thread to delete.
 * @path /discussionBoard/threads/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of the thread to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardThread;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/threads/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/threads/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardThread =>
    typia.random<IDiscussionBoardThread>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
