import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardGuest } from "../../../structures/IDiscussionBoardGuest";
import { IPageDiscussionBoardGuest } from "../../../structures/IPageDiscussionBoardGuest";

/**
 * Create a guest record in discussion_board_guest (anonymous session tracking).
 *
 * This operation inserts a new row into the discussion_board_guest table,
 * representing a new unauthenticated user accessing the platform. The caller
 * supplies a session_token (optionally), and the API captures access timestamps
 * and identifiers. Guest records are used for analytic/audit purposes and may
 * be referenced if the guest later registers or is flagged for unusual
 * activity. Associated endpoints allow later read, update, or deletion. All
 * input is validated as per IDiscussionBoardGuest.ICreate request schema.
 *
 * @param props.connection
 * @param props.body Data for new guest user creation (session token, etc.)
 * @path /discussionBoard/guests
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Data for new guest user creation (session token, etc.) */
    body: IDiscussionBoardGuest.ICreate;
  };
  export type Body = IDiscussionBoardGuest.ICreate;
  export type Response = IDiscussionBoardGuest;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/guests",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/guests";
  export const random = (): IDiscussionBoardGuest =>
    typia.random<IDiscussionBoardGuest>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/filter guest users from discussion_board_guest (admin/system
 * maintenance).
 *
 * This operation retrieves a pageable, sortable, and filterable list of guest
 * records from the discussion_board_guest entity, enabling administrative or
 * analytical access to guest user data. The returned data may include
 * session_token, first_seen_at, last_seen_at, and possibly derived activity
 * metrics. Filtering may be supported on session_token, date ranges, or
 * activity window. This endpoint is most often used for system analytics, abuse
 * tracking, or to facilitate cleanup of legacy guest records. Authentication
 * and strong permission controls required. Pagination and sorting parameters
 * must be included in the request body as specified in
 * IDiscussionBoardGuest.IRequest. Related endpoints include guest record
 * creation and deletion.
 *
 * @param props.connection
 * @param props.body Filtering, pagination, sorting for guest record list
 *   retrieval
 * @path /discussionBoard/guests
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Filtering, pagination, sorting for guest record list retrieval */
    body: IDiscussionBoardGuest.IRequest;
  };
  export type Body = IDiscussionBoardGuest.IRequest;
  export type Response = IPageDiscussionBoardGuest;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/guests",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/guests";
  export const random = (): IPageDiscussionBoardGuest =>
    typia.random<IPageDiscussionBoardGuest>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch a single guest user's information from discussion_board_guest
 * (audit/analytics).
 *
 * This API fetches a complete guest user record from discussion_board_guest
 * based on its unique identifier. Data returned includes session_token,
 * timestamps for first and last activity, and may include derived context such
 * as recent interaction details. The operation supports audit and analytics use
 * cases, but not typical application-facing workflows (as guests aren't
 * authenticated users). Related operations include listing, updating, or
 * deleting guest records.
 *
 * @param props.connection
 * @param props.id Target guest's unique identifier (UUID)
 * @path /discussionBoard/guests/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Target guest's unique identifier (UUID) */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardGuest;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/guests/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/guests/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardGuest =>
    typia.random<IDiscussionBoardGuest>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific guest user record in discussion_board_guest (system only).
 *
 * The endpoint enables authorized actors to update data for a specific guest
 * session record, identified by its unique UUID, in discussion_board_guest.
 * Permitted changes may include session_token, last_seen_at, or other analytic
 * fields. The operation does not convert the guest into a registered user, nor
 * affect platform state for other users. Changes are validated and updates are
 * logged for audit compliance as defined by platform policy. Associated
 * endpoints include guest creation, retrieval, and deletion.
 *
 * @param props.connection
 * @param props.id Guest user unique identifier (UUID)
 * @param props.body Fields to update for the guest user record
 * @path /discussionBoard/guests/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Guest user unique identifier (UUID) */
    id: string & tags.Format<"uuid">;

    /** Fields to update for the guest user record */
    body: IDiscussionBoardGuest.IUpdate;
  };
  export type Body = IDiscussionBoardGuest.IUpdate;
  export type Response = IDiscussionBoardGuest;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/guests/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/guests/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardGuest =>
    typia.random<IDiscussionBoardGuest>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a guest user record from discussion_board_guest (system clean-up).
 *
 * This endpoint allows system actors to remove a single guest user record from
 * discussion_board_guest, identified by its UUID. Commonly used for
 * housekeeping, privacy, or retention-limiting after analytic periods expire.
 * Related operations include read, list, and update. Record existence,
 * authorization, and audit trails are strictly enforced. Errors for not found
 * or insufficient permission are clearly defined.
 *
 * @param props.connection
 * @param props.id Target guest user's unique identifier (UUID)
 * @path /discussionBoard/guests/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Target guest user's unique identifier (UUID) */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/guests/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/guests/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
