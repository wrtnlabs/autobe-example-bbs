import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIDiscussionBoardModerator } from "../../../../structures/IPageIDiscussionBoardModerator";
import { IDiscussionBoardModerator } from "../../../../structures/IDiscussionBoardModerator";

/**
 * List all discussion board moderators from the 'discussion_board_moderators'
 * table.
 *
 * Fetch a list of all discussion board moderators from the database. This
 * operation corresponds to the 'discussion_board_moderators' table, which
 * stores each moderator's role assignment, user identifier, grant and revoke
 * timestamps.
 *
 * The endpoint provides a simple, non-paginated list of all moderators,
 * regardless of assignment status. Use cases include admin dashboards, role
 * audits, or moderator management interfaces. Readers should be aware that only
 * admins or users with elevated privileges should have access to the full list,
 * as it may reveal role-grant history not meant for general users.
 *
 * For compliance, the endpoint response includes only properties present in the
 * underlying schema. No historical or computed values beyond what exists in the
 * table are returned. This endpoint may be extended in future versions to
 * support filters or pagination, especially as the moderator population grows.
 *
 * @param props.connection
 * @path /discussionBoard/admin/moderators
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIDiscussionBoardModerator;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/admin/moderators",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/admin/moderators";
  export const random = (): IPageIDiscussionBoardModerator =>
    typia.random<IPageIDiscussionBoardModerator>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Create a new discussion board moderator record (assign moderation role).
 *
 * Add a new role assignment in 'discussion_board_moderators' to make a user a
 * board moderator. The operation requires a valid user identifier to be
 * supplied along with possible grant timestamp, in accordance with the schema's
 * required properties.
 *
 * Permission to invoke this API is restricted to admins only, as only they may
 * assign moderator privilege. Upon successful creation, the complete new
 * moderator record is returned, showing the assigned privilege, user mapping,
 * and audit timestamps.
 *
 * If the user already has moderator status, this should result in a duplicate
 * error per the unique constraint in the schema. Other possible errors include
 * invalid input or unauthorized access. The operation does not modify
 * downstream user data, only board-specific moderator mapping.
 *
 * @param props.connection
 * @param props.body Moderator creation details including user_identifier and
 *   grant time.
 * @path /discussionBoard/admin/moderators
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Moderator creation details including user_identifier and grant time. */
    body: IDiscussionBoardModerator.ICreate;
  };
  export type Body = IDiscussionBoardModerator.ICreate;
  export type Response = IDiscussionBoardModerator;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/admin/moderators",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/admin/moderators";
  export const random = (): IDiscussionBoardModerator =>
    typia.random<IDiscussionBoardModerator>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and paginate discussion board moderators with advanced filters.
 *
 * Return a paginated and filterable list of moderator records based on advanced
 * criteria defined in the request body. The underlying model is
 * 'discussion_board_moderators', storing all role assignments with user
 * identifiers, grant, and revoke timestamps.
 *
 * This endpoint supports searching by user identifiers, active status,
 * grant/revoke time windows, and more. Paging and sort options are included in
 * the request structure for large-scale or compliance-critical installations.
 * Only admins may invoke this due to the sensitivity of role data.
 *
 * If errors occur, such as invalid filters or unauthorized access, standard
 * error messages are returned following API error conventions. For field
 * definitions and search semantics, the response structure mirrors the table
 * schema and supplements with pagination metadata.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination parameters for moderator
 *   index.
 * @path /discussionBoard/admin/moderators
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Search, filter, and pagination parameters for moderator index. */
    body: IDiscussionBoardModerator.IRequest;
  };
  export type Body = IDiscussionBoardModerator.IRequest;
  export type Response = IPageIDiscussionBoardModerator;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/admin/moderators",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/admin/moderators";
  export const random = (): IPageIDiscussionBoardModerator =>
    typia.random<IPageIDiscussionBoardModerator>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch a specific discussion board moderator by ID.
 *
 * Get detailed information about a single moderator by primary key from the
 * 'discussion_board_moderators' schema table. Use this to audit role history,
 * manage moderator status, or resolve privilege-related questions.
 *
 * The operation returns the moderator's user identifier, grant/revoke times,
 * and all related properties as defined in the schema. Access is restricted to
 * admin users due to sensitivity of moderator details and their audit
 * importance.
 *
 * Error handling includes standard not found (if the ID does not exist) and
 * forbidden (if the caller lacks privilege). The parameter must match exactly
 * the moderator record UUID type.
 *
 * @param props.connection
 * @param props.moderatorId The UUID of the moderator to retrieve.
 * @path /discussionBoard/admin/moderators/:moderatorId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The UUID of the moderator to retrieve. */
    moderatorId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardModerator;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/admin/moderators/:moderatorId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/moderators/${encodeURIComponent(props.moderatorId ?? "null")}`;
  export const random = (): IDiscussionBoardModerator =>
    typia.random<IDiscussionBoardModerator>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderatorId")(() => typia.assert(props.moderatorId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update moderator details, such as revocation or field changes.
 *
 * Change an existing moderator assignment identified by moderatorId in
 * 'discussion_board_moderators'. Typical uses include revoking privileges
 * (setting revoked_at) or updating audit-related fields. All updates must
 * adhere strictly to schema rules; only admins may use this endpoint.
 *
 * A valid UUID for the moderator ID and update fields in request body are
 * required. On success, returns the updated moderator record; errors include
 * non-existent ID, validation failure, or lack of permission. Proper audit
 * logging for role changes should be expected downstream. Fields not present in
 * the request remain unchanged unless schema dictates otherwise.
 *
 * @param props.connection
 * @param props.moderatorId The UUID of the moderator to update.
 * @param props.body Fields to update on the moderator record.
 * @path /discussionBoard/admin/moderators/:moderatorId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The UUID of the moderator to update. */
    moderatorId: string & tags.Format<"uuid">;

    /** Fields to update on the moderator record. */
    body: IDiscussionBoardModerator.IUpdate;
  };
  export type Body = IDiscussionBoardModerator.IUpdate;
  export type Response = IDiscussionBoardModerator;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/admin/moderators/:moderatorId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/admin/moderators/${encodeURIComponent(props.moderatorId ?? "null")}`;
  export const random = (): IDiscussionBoardModerator =>
    typia.random<IDiscussionBoardModerator>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderatorId")(() => typia.assert(props.moderatorId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove moderator privilege by deleting assignment record.
 *
 * Permanently delete or remove a moderator assignment by moderatorId from
 * 'discussion_board_moderators'. This function should be accessed only by
 * administrators. Removing the record eliminates the user's ability to moderate
 * and removes audit trail of assignment for that role; however, you may wish to
 * consider soft disable by updating 'revoked_at' before erasure depending on
 * business lifecycle practices.
 *
 * If a referenced record is not found, a standard not-found error is returned.
 * Successful operation does not return a body. Caution: this action cannot be
 * undone and removes moderator mapping from the system entirely.
 *
 * @param props.connection
 * @param props.moderatorId The UUID of the moderator to remove.
 * @path /discussionBoard/admin/moderators/:moderatorId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The UUID of the moderator to remove. */
    moderatorId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/admin/moderators/:moderatorId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/moderators/${encodeURIComponent(props.moderatorId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderatorId")(() => typia.assert(props.moderatorId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
