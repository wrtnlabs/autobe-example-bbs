import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIDiscussionBoardGuest } from "../../../../structures/IPageIDiscussionBoardGuest";
import { IDiscussionBoardGuest } from "../../../../structures/IDiscussionBoardGuest";

/**
 * Retrieve entire list of discussion board guest sessions.
 *
 * Fetch a complete list of tracked guest users. The guests are unauthenticated
 * users whose visit and session are recorded for basic analytics and onboarding
 * logic. Each guest record includes a unique session_identifier, the first time
 * they were seen, and the last activity timestamp.
 *
 * This endpoint returns all guest sessions, providing insight into anonymous
 * user behavior. Security-wise, since no personal or sensitive data is stored,
 * access can be relatively open; however, avoid exposing guest-level analytics
 * to public endpoints without proper aggregation or anonymization.
 *
 * Data returned matches the discussion_board_guests model per the Actors
 * schema, ensuring strict normalization and separation from registered members.
 * The list can be used for platform reporting and system optimization tasks.
 *
 * @param props.connection
 * @path /discussionBoard/admin/guests
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIDiscussionBoardGuest;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/admin/guests",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/admin/guests";
  export const random = (): IPageIDiscussionBoardGuest =>
    typia.random<IPageIDiscussionBoardGuest>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Search and filter guest sessions with advanced criteria.
 *
 * Search and filter guest user sessions using detailed criteria. This endpoint
 * enables the querying of guest activity based on parameters such as
 * session_identifier, first_seen/last_seen date ranges, and other analytics
 * requirements. Pagination and sorting options allow for efficient analysis of
 * large datasets.
 *
 * Only administrators and system operators should be able to run detailed
 * analytics on guest session information, as misuse could expose traffic
 * patterns or system metrics considered sensitive. No personal identifiers are
 * stored for guests, aligning with the privacy requirement.
 *
 * Refer to the discussion_board_guests table for all field definitions; all
 * guest analytics or dashboard features must call this endpoint when presenting
 * filtered or paginated results.
 *
 * @param props.connection
 * @param props.body Filter, pagination, and search parameters for analytical
 *   guest session retrieval.
 * @path /discussionBoard/admin/guests
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /**
     * Filter, pagination, and search parameters for analytical guest
     * session retrieval.
     */
    body: IDiscussionBoardGuest.IRequest;
  };
  export type Body = IDiscussionBoardGuest.IRequest;
  export type Response = IPageIDiscussionBoardGuest;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/admin/guests",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/admin/guests";
  export const random = (): IPageIDiscussionBoardGuest =>
    typia.random<IPageIDiscussionBoardGuest>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve full details of a specific guest session by its ID.
 *
 * Fetch the full set of properties for a unique guest session, as captured by
 * the system. This includes session_identifier, first and last seen timestamps,
 * and other analytics attributes for that session.
 *
 * This endpoint is typically used by admin tools or analytics dashboards for
 * session tracing and diagnosis. Since guests are unauthenticated visitors,
 * their tracked ID does not carry personal data but should be accessed securely
 * to avoid exposing structural system information.
 *
 * Returns the guest record as defined in the Actors Prisma schema, useful for
 * compliance analytics, audit, or troubleshooting individual onboarding
 * journeys.
 *
 * @param props.connection
 * @param props.guestId Unique identifier (UUID) of the target guest session.
 * @path /discussionBoard/admin/guests/:guestId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the target guest session. */
    guestId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardGuest;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/admin/guests/:guestId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/guests/${encodeURIComponent(props.guestId ?? "null")}`;
  export const random = (): IDiscussionBoardGuest =>
    typia.random<IDiscussionBoardGuest>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("guestId")(() => typia.assert(props.guestId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a tracked guest's session info.
 *
 * Modify the data for an existing guest user session. The most common update is
 * changing the last_seen_at field to reflect an ongoing visit, but any non-PK
 * attribute from the schema can be updated through this endpoint.
 *
 * This endpoint enforces administrative privileges as guest records should not
 * be arbitrarily modified by external callers; only system code or
 * high-privilege users should update session activity. Returns the updated
 * guest entity as described by the Actors schema.
 *
 * All field changes are auditable, as required for analytics compliance.
 *
 * @param props.connection
 * @param props.guestId UUID of the guest session to update.
 * @param props.body Fields to update for the guest session (usually
 *   last_seen_at).
 * @path /discussionBoard/admin/guests/:guestId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the guest session to update. */
    guestId: string & tags.Format<"uuid">;

    /** Fields to update for the guest session (usually last_seen_at). */
    body: IDiscussionBoardGuest.IUpdate;
  };
  export type Body = IDiscussionBoardGuest.IUpdate;
  export type Response = IDiscussionBoardGuest;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/admin/guests/:guestId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/admin/guests/${encodeURIComponent(props.guestId ?? "null")}`;
  export const random = (): IDiscussionBoardGuest =>
    typia.random<IDiscussionBoardGuest>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("guestId")(() => typia.assert(props.guestId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (hard) the specified guest tracking entity by ID.
 *
 * Remove the specified guest session from the tracking system. This is a hard
 * delete; once the record is removed, session analytics relating to this
 * visitor may no longer be available. Use this only for data cleanup (e.g., to
 * purge corrupted/old analytics data) or to comply with system retention
 * rules.
 *
 * This operation is strictly limited to admin usage, as guest session logs are
 * important for platform security and analytics compliance. Deletion of guest
 * info should be fully auditable.
 *
 * There is no corresponding soft-delete field in the schema, so this is
 * destructive and final.
 *
 * @param props.connection
 * @param props.guestId UUID of the guest session to delete.
 * @path /discussionBoard/admin/guests/:guestId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the guest session to delete. */
    guestId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/admin/guests/:guestId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/guests/${encodeURIComponent(props.guestId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("guestId")(() => typia.assert(props.guestId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
