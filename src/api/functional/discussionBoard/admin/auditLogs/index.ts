import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageIDiscussionBoardAuditLog } from "../../../../structures/IPageIDiscussionBoardAuditLog";
import { IDiscussionBoardAuditLog } from "../../../../structures/IDiscussionBoardAuditLog";

/**
 * Get all audit log records for the board (discussion_board_audit_logs table).
 *
 * Fetch a complete list of all audit log records from the
 * discussion_board_audit_logs table. Returns detailed data including actor,
 * target, action_type, action_detail, and timestamp. Authorization is strictly
 * enforced ('admin' only).
 *
 * Audit logs are essential for compliance, troubleshooting, and transparency.
 * Any suspicious activity is traceable here. The endpoint should support secure
 * access with error reporting for unauthorized or failed requests. Empty result
 * if no logs exist.
 *
 * Pairs with the patch/search endpoint for advanced log review.
 *
 * @param props.connection
 * @path /discussionBoard/admin/auditLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(connection: IConnection): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
      );
}
export namespace index {
  export type Response = IPageIDiscussionBoardAuditLog;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/admin/auditLogs",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/admin/auditLogs";
  export const random = (): IPageIDiscussionBoardAuditLog =>
    typia.random<IPageIDiscussionBoardAuditLog>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Create a new audit log entry (discussion_board_audit_logs table).
 *
 * Insert a new event record to the audit logs table for the discussion board.
 * The request body must match schema with valid
 * actor/target/action_type/action_detail. Timestamps are assigned by the
 * system. Use is generally restricted to administrative tools or service-layer
 * hooks for audit record insertion. Error reporting includes validation and
 * metadata requirements.
 *
 * Available only to 'admin' role. On success returns the new record, on error
 * explains the violation.
 *
 * Complements log review/edit endpoints for compliance.
 *
 * @param props.connection
 * @param props.body Event metadata and details for new audit log record,
 *   matching schema exactly.
 * @path /discussionBoard/admin/auditLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Event metadata and details for new audit log record, matching schema
     * exactly.
     */
    body: IDiscussionBoardAuditLog.ICreate;
  };
  export type Body = IDiscussionBoardAuditLog.ICreate;
  export type Response = IDiscussionBoardAuditLog;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/admin/auditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/admin/auditLogs";
  export const random = (): IDiscussionBoardAuditLog =>
    typia.random<IDiscussionBoardAuditLog>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search/filter audit log records for the board (discussion_board_audit_logs
 * table) with advanced query.
 *
 * Search and filter audit logs for the board via PATCH body, supporting
 * criteria like actor or action_type, date range, or free-text search on detail
 * fields. Leverages indices on action_type and created_at for scalability.
 * Returns paginated results for UI consumption.
 *
 * Restricted to 'admin' authorization. All accesses are logged, and audit
 * trails are enforced for review or forensic needs. Errors are returned for
 * invalid queries or excessive requests.
 *
 * This pairs with the standard get/list for complete log management.
 *
 * @param props.connection
 * @param props.body Search criteria for querying and pagination of audit logs.
 * @path /discussionBoard/admin/auditLogs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /** Search criteria for querying and pagination of audit logs. */
    body: IDiscussionBoardAuditLog.IRequest;
  };
  export type Body = IDiscussionBoardAuditLog.IRequest;
  export type Response = IPageIDiscussionBoardAuditLog;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/admin/auditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/admin/auditLogs";
  export const random = (): IPageIDiscussionBoardAuditLog =>
    typia.random<IPageIDiscussionBoardAuditLog>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific audit log record by ID (discussion_board_audit_logs table).
 *
 * Fetch a specific audit log record by its id (UUID), reading all core columns
 * as described in the Prisma schema. Provides administrators with detailed
 * insight into individual board event historyâ€”essential for compliance/audit
 * investigations.
 *
 * Strictly requires 'admin' authorization. If the ID is not found, returns
 * error. Responds with no additional calculation or related object data.
 *
 * This operation is commonly paired with the log list/search and update
 * endpoints for full log review and adjustment.
 *
 * @param props.connection
 * @param props.auditLogId Unique UUID identifier for the desired audit log
 *   record.
 * @path /discussionBoard/admin/auditLogs/:auditLogId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique UUID identifier for the desired audit log record. */
    auditLogId: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardAuditLog;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/admin/auditLogs/:auditLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/auditLogs/${encodeURIComponent(props.auditLogId ?? "null")}`;
  export const random = (): IDiscussionBoardAuditLog =>
    typia.random<IDiscussionBoardAuditLog>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("auditLogId")(() => typia.assert(props.auditLogId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific audit log record by ID (discussion_board_audit_logs table).
 *
 * Edit the fields of a specific audit log event in the
 * discussion_board_audit_logs table, identified by UUID. Accepts update data
 * matching the schema (modifying action_type, detail, or actor/target links if
 * needed). All changes are fully validated and historical changes should
 * trigger additional audit events for traceability.
 *
 * Endpoint is restricted to administrators. Errors return for invalid update or
 * conflict. Success returns the new full log object for confirmation.
 *
 * Complements listing, creation, and deletion for complete auditing.
 *
 * @param props.connection
 * @param props.auditLogId Unique UUID identifier of the audit log record to
 *   update.
 * @param props.body Fields/data for log update. Must match schema; partial or
 *   full field updates allowed per business rules.
 * @path /discussionBoard/admin/auditLogs/:auditLogId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique UUID identifier of the audit log record to update. */
    auditLogId: string & tags.Format<"uuid">;

    /**
     * Fields/data for log update. Must match schema; partial or full field
     * updates allowed per business rules.
     */
    body: IDiscussionBoardAuditLog.IUpdate;
  };
  export type Body = IDiscussionBoardAuditLog.IUpdate;
  export type Response = IDiscussionBoardAuditLog;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/admin/auditLogs/:auditLogId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/admin/auditLogs/${encodeURIComponent(props.auditLogId ?? "null")}`;
  export const random = (): IDiscussionBoardAuditLog =>
    typia.random<IDiscussionBoardAuditLog>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("auditLogId")(() => typia.assert(props.auditLogId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (hard delete) an audit log record by ID (discussion_board_audit_logs
 * table).
 *
 * Permanently remove an audit log entry from the audit log table by UUID id.
 * Since deleted_at is not present, the log is removed completely and not
 * recoverable. Use only for error correction or as required by compliance.
 * Access is strictly for admins only.
 *
 * All deletions are themselves logged. Return is empty on success; otherwise,
 * error reported.
 *
 * Useful only with create, get, update, and search endpoints for log table
 * management.
 *
 * @param props.connection
 * @param props.auditLogId UUID identifier of the audit log record to
 *   permanently delete.
 * @path /discussionBoard/admin/auditLogs/:auditLogId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID identifier of the audit log record to permanently delete. */
    auditLogId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/admin/auditLogs/:auditLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/admin/auditLogs/${encodeURIComponent(props.auditLogId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("auditLogId")(() => typia.assert(props.auditLogId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
