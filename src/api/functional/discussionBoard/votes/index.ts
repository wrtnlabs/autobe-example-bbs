import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardVote } from "../../../structures/IDiscussionBoardVote";
import { IPageIDiscussionBoardVote } from "../../../structures/IPageIDiscussionBoardVote";

/**
 * Create a new vote in discussion_board_votes.
 *
 * Creates a new vote entry, representing a member's vote (of a valid type such
 * as upvote or downvote) on a thread, post, or comment. The request body must
 * specify the vote type, the target resource (thread, post, or comment), and
 * the identity of the voter (inferred from session but also recorded in the
 * database for audit). Restricts duplicate votes per type and item, validates
 * target objects' status, and records accurate timestamps for compliance and
 * analytics. If a duplicate vote exists, an error describing the uniqueness
 * constraint will be returned. This endpoint helps drive engagement, content
 * ranking, and community moderation via voting.
 *
 * @param props.connection
 * @param props.body New vote details (vote type, target, voter).
 * @path /discussionBoard/votes
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** New vote details (vote type, target, voter). */
    body: IDiscussionBoardVote.ICreate;
  };
  export type Body = IDiscussionBoardVote.ICreate;
  export type Response = IDiscussionBoardVote;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/votes";
  export const random = (): IDiscussionBoardVote =>
    typia.random<IDiscussionBoardVote>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/search votes (discussion_board_votes table) with filters.
 *
 * This endpoint returns a filtered, paginated list of votes, supporting complex
 * queries on voter, target (thread/post/comment), vote type, and date ranges.
 * Only available to mods/admins for compliance, user request tracebacks, or
 * audit. Members may access their own history via specialized endpoints (not
 * this one). Supports multi-field filters and cursor/offset pagination.
 * Validation checks for valid query parameters, permissions. On success,
 * returns paginated vote records with linked objects. Errors: 403
 * (unauthorized), 400 (bad query), 500 (internal/server). Used in system
 * analytics and vote traceability/business intelligence use cases.
 *
 * @param props.connection
 * @param props.body Query criteria and pagination info for searching votes.
 * @path /discussionBoard/votes
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Query criteria and pagination info for searching votes. */
    body: IDiscussionBoardVote.IRequest;
  };
  export type Body = IDiscussionBoardVote.IRequest;
  export type Response = IPageIDiscussionBoardVote;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/votes";
  export const random = (): IPageIDiscussionBoardVote =>
    typia.random<IPageIDiscussionBoardVote>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a detailed vote record from discussion_board_votes.
 *
 * This endpoint fetches all information for a specific vote entity, which
 * represents a user's vote (of a certain type, e.g., upvote/downvote) on a
 * thread, post, or comment, as described in Prisma discussion_board_votes. It
 * is used to retrieve comprehensive details for auditing, analytics, and vote
 * display purposes, including references to the voter, content type, and vote
 * type. Permission checks ensure that only authorized users (the voter, admins,
 * and, in some cases, moderators) can access detailed voting records,
 * fulfilling privacy and security requirements noted in the requirements
 * analysis. Not-found errors occur if the vote record is deleted or does not
 * exist. This is a read-only operation linked to audit and analytics workflows,
 * and it forms part of voting system transparency and compliance.
 *
 * @param props.connection
 * @param props.id The ID of the vote to retrieve.
 * @path /discussionBoard/votes/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** The ID of the vote to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardVote;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/votes/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/votes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardVote =>
    typia.random<IDiscussionBoardVote>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a vote in discussion_board_votes.
 *
 * Updates an existing vote (e.g., user changing their vote from upvote to
 * downvote) for a specific resource (thread/post/comment). Only the voter or an
 * administrator may update, and transitions are validated to ensure compliance
 * with one-vote-per-type-per-item rules. Maintains strict audit trail per
 * security requirements. On success, returns the updated vote record. Business
 * rules prevent changing the vote target â€” only the vote type and derived
 * properties can change. Used for transparent and fair voting procedures.
 *
 * @param props.connection
 * @param props.id The ID of the vote to update.
 * @param props.body Update information for the vote.
 * @path /discussionBoard/votes/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** The ID of the vote to update. */
    id: string & tags.Format<"uuid">;

    /** Update information for the vote. */
    body: IDiscussionBoardVote.IUpdate;
  };
  export type Body = IDiscussionBoardVote.IUpdate;
  export type Response = IDiscussionBoardVote;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/votes/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/votes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardVote =>
    typia.random<IDiscussionBoardVote>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a vote from discussion_board_votes.
 *
 * Deletes a given vote, representing a user's retraction of their previous
 * upvote/downvote or vote on a content item. Only permitted for the voter or
 * administrators. Ensures comprehensive audit (soft deletion with timestamp),
 * and returns a success status or error if the vote cannot be found or is not
 * permitted to be deleted. Fulfills reversibility and transparency requirements
 * as described in the business and non-functional requirements, contributing to
 * fair voting mechanisms.
 *
 * @param props.connection
 * @param props.id ID of the vote to be deleted.
 * @path /discussionBoard/votes/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** ID of the vote to be deleted. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardVote;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/votes/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/votes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardVote =>
    typia.random<IDiscussionBoardVote>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
