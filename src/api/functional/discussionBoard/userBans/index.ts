import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardUserBan } from "../../../structures/IDiscussionBoardUserBan";
import { IPageIDiscussionBoardUserBan } from "../../../structures/IPageIDiscussionBoardUserBan";

/**
 * Create a new user ban record in the discussion_board_user_ban table.
 *
 * This endpoint allows moderators or admins to ban a user by creating a new
 * record in the user ban log. Requires input of subject user, moderator, the
 * rationale, and optionally a link to the moderation action log. This supports
 * escalation from warnings to bans in the moderation workflow, and triggers
 * relevant user notifications. All inserts are auditable and integrated with
 * transparency requirements. Related endpoints include querying, updating, and
 * deleting user bans, as well as other moderation log operations.
 *
 * @param props.connection
 * @param props.body Information for creating a new user ban record.
 * @path /discussionBoard/userBans
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Information for creating a new user ban record. */
    body: IDiscussionBoardUserBan.ICreate;
  };
  export type Body = IDiscussionBoardUserBan.ICreate;
  export type Response = IDiscussionBoardUserBan;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/userBans",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/userBans";
  export const random = (): IDiscussionBoardUserBan =>
    typia.random<IDiscussionBoardUserBan>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and list user ban records in the discussion_board_user_ban table.
 *
 * This API operation enables listing and searching all user ban records with
 * flexible queries: filter by subject user, moderator, reason, date, or status.
 * Pagination parameters included for efficient display in dashboards or
 * moderation panels. Results include all relevant ban details. Only users with
 * moderator or admin roles may access this endpoint to support moderation
 * transparency, operational management, and appeals processes. Associated
 * endpoints include detailed single record retrieval, creation, updating, and
 * deletion for bans.
 *
 * @param props.connection
 * @param props.body Filter and pagination parameters for user ban records
 *   (optional).
 * @path /discussionBoard/userBans
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Filter and pagination parameters for user ban records (optional). */
    body: IDiscussionBoardUserBan.IRequest;
  };
  export type Body = IDiscussionBoardUserBan.IRequest;
  export type Response = IPageIDiscussionBoardUserBan;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/userBans",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/userBans";
  export const random = (): IPageIDiscussionBoardUserBan =>
    typia.random<IPageIDiscussionBoardUserBan>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get specific user ban record from discussion_board_user_ban table by ID.
 *
 * This endpoint fetches a single user ban record based on its unique ID.
 * Returns full details including the banned user, reason, dates, and associated
 * moderator. Coordinated with moderation audit logs and used in workflows such
 * as appeals or ban reviews. Only authorized moderation staff can retrieve
 * sensitive ban data. Errors are handled for non-existent or revoked bans,
 * ensuring clear feedback for management and transparent handling as outlined
 * in moderation documentation.
 *
 * @param props.connection
 * @param props.id User ban record's unique identifier (UUID).
 * @path /discussionBoard/userBans/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** User ban record's unique identifier (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardUserBan;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/userBans/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/userBans/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardUserBan =>
    typia.random<IDiscussionBoardUserBan>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific user ban record in the discussion_board_user_ban table by
 * ID.
 *
 * This operation edits core details of a user ban, supporting amendments based
 * on new information, successful appeals, or moderator input correction. All
 * updates are logged and validated for consistency. Implementation must enforce
 * privilege boundaries and trigger audit log updates. Related endpoints include
 * creation, retrieval, listing, and deletion of bans, as well as moderation
 * action and warning logs.
 *
 * @param props.connection
 * @param props.id User ban record's unique identifier (UUID).
 * @param props.body Information for updating the user ban record (reason,
 *   dates, moderator, etc).
 * @path /discussionBoard/userBans/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** User ban record's unique identifier (UUID). */
    id: string & tags.Format<"uuid">;

    /**
     * Information for updating the user ban record (reason, dates,
     * moderator, etc).
     */
    body: IDiscussionBoardUserBan.IUpdate;
  };
  export type Body = IDiscussionBoardUserBan.IUpdate;
  export type Response = IDiscussionBoardUserBan;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/userBans/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/userBans/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardUserBan =>
    typia.random<IDiscussionBoardUserBan>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (soft delete) a specific user ban record by ID.
 *
 * This endpoint performs a soft delete of a user ban record, referenced by its
 * unique ID. Deletions are always soft (field set, not physical removal) to
 * preserve auditability and reversibility. Deletion permission is restricted to
 * proper staff. Associated with moderation documentation on appeals process and
 * outcome transparency. Related endpoints include create, search, update, and
 * single record retrieval for user bans, as well as related moderation logs.
 *
 * @param props.connection
 * @param props.id User ban record's unique identifier (UUID).
 * @path /discussionBoard/userBans/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** User ban record's unique identifier (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardUserBan;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/userBans/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/userBans/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardUserBan =>
    typia.random<IDiscussionBoardUserBan>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
