import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardThreadTag } from "../../../structures/IDiscussionBoardThreadTag";
import { IPageIDiscussionBoardThreadTag } from "../../../structures/IPageIDiscussionBoardThreadTag";

/**
 * Create a new discussion_board_thread_tag (thread categorization label).
 *
 * Creates a new thread tag providing a unique name and optional description.
 * This is used for categorizing and filtering threads, supporting board
 * organization and content discovery. Validation checks include uniqueness (tag
 * name) and possibly semantic validation via business logic. Audit and
 * moderation policies may apply to tag creation. Related endpoints: patch (for
 * tag search/list), put (for update), delete (for disabling), get (for
 * retrieval by ID). Underlying table: discussion_board_thread_tag.
 *
 * @param props.connection
 * @param props.body Information required to create a new thread tag.
 * @path /discussionBoard/threadTags
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Information required to create a new thread tag. */
    body: IDiscussionBoardThreadTag.ICreate;
  };
  export type Body = IDiscussionBoardThreadTag.ICreate;
  export type Response = IDiscussionBoardThreadTag;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/threadTags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/threadTags";
  export const random = (): IDiscussionBoardThreadTag =>
    typia.random<IDiscussionBoardThreadTag>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/search discussion_board_thread_tag records (tags used for thread
 * categorization).
 *
 * Fetches a paginated, optionally filtered list of all thread tags. This
 * includes support for fulltext searching on name or description, sorting, and
 * control over result pagination. Useful for suggesting tags, tag management,
 * analytics, or query UIs with advanced tag filtering. The endpoint handles
 * list retrieval, combining query request data (like search term, limit,
 * cursor) with sorting directives. Underlying table is
 * discussion_board_thread_tag. Related endpoints: single tag get, tag
 * creation/update/delete.
 *
 * @param props.connection
 * @param props.body Filtering, searching, and pagination options for thread tag
 *   listing.
 * @path /discussionBoard/threadTags
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Filtering, searching, and pagination options for thread tag listing. */
    body: IDiscussionBoardThreadTag.IRequest;
  };
  export type Body = IDiscussionBoardThreadTag.IRequest;
  export type Response = IPageIDiscussionBoardThreadTag;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/threadTags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/threadTags";
  export const random = (): IPageIDiscussionBoardThreadTag =>
    typia.random<IPageIDiscussionBoardThreadTag>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch details for a single discussion_board_thread_tag by ID.
 *
 * Retrieves all metadata of a single thread tag given its UUID. This includes
 * its name, description, creation and update timestamps, and soft-delete
 * status. Only surface visible tags as appropriate (not deleted), unless user
 * is admin. Used for management or UI display. Underlying entity:
 * discussion_board_thread_tag. Related endpoints: patch (for list/search), post
 * (for creation), put (for update), delete (for archive), etc.
 *
 * @param props.connection
 * @param props.id Unique identifier of the thread tag to fetch (UUID).
 * @path /discussionBoard/threadTags/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier of the thread tag to fetch (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardThreadTag;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/threadTags/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/threadTags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardThreadTag =>
    typia.random<IDiscussionBoardThreadTag>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a discussion_board_thread_tag record by ID.
 *
 * Updates the metadata of an existing thread tag identified by UUID. Permits
 * changes to properties like name (unique check), description, or status. The
 * request must contain only updatable attributes. Validation includes
 * referential integrity checks (if tag is in use), audit trail of changes, and
 * moderation review if needed. Affects the discussion_board_thread_tag table.
 * Related: get (view), patch (list/search), post (create), delete
 * (disable/archive).
 *
 * @param props.connection
 * @param props.id Unique identifier of the thread tag to update (UUID).
 * @param props.body Fields and metadata for updating the tag.
 * @path /discussionBoard/threadTags/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique identifier of the thread tag to update (UUID). */
    id: string & tags.Format<"uuid">;

    /** Fields and metadata for updating the tag. */
    body: IDiscussionBoardThreadTag.IUpdate;
  };
  export type Body = IDiscussionBoardThreadTag.IUpdate;
  export type Response = IDiscussionBoardThreadTag;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/threadTags/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/threadTags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardThreadTag =>
    typia.random<IDiscussionBoardThreadTag>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete (archive) a discussion_board_thread_tag record by ID.
 *
 * Soft-deletes a thread tag, hiding it from user-visible lists and tag clouds,
 * but retaining it for audit, rollback, and moderation. Attempts to delete tags
 * still attached to active threads should raise errors or require
 * confirmation/migration pathways. Validates that the requesting user is
 * authorized (admin/moderator) and that the tag is not otherwise protected. The
 * record is not physically deleted. Underlying table:
 * discussion_board_thread_tag. Related endpoints: patch (search/list), post
 * (create), get (retrieve), put (update).
 *
 * @param props.connection
 * @param props.id Unique identifier of the thread tag to delete (UUID).
 * @path /discussionBoard/threadTags/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique identifier of the thread tag to delete (UUID). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardThreadTag;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/threadTags/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/threadTags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardThreadTag =>
    typia.random<IDiscussionBoardThreadTag>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
