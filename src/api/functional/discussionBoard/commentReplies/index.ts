import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardCommentReply } from "../../../structures/IDiscussionBoardCommentReply";
import { IPageIDiscussionBoardCommentReply } from "../../../structures/IPageIDiscussionBoardCommentReply";

/**
 * Create a new comment reply (discussion_board_comment_reply table).
 *
 * This API enables a registered user to create a new threaded reply to an
 * existing comment, fulfilling the inline and nested discussion requirements
 * for political/economic conversations. The endpoint ensures that each reply is
 * atomic and references its parent comment and author per the
 * discussion_board_comment_reply schema. Reply content must be text and not
 * null.
 *
 * Relations: The reply is linked to a comment via parent_comment_id and owned
 * by a user. Moderation policies apply, including tracking who authored the
 * reply and possible future moderation actions (edit, delete, report). On
 * creation, notifications may be triggered for the original comment author
 * according to project rules. Validation includes confirming the comment
 * exists, the user is valid, and content is not empty or inappropriate
 * (filtered per moderation policies).
 *
 * Security: Only authenticated, active users can create replies, and anti-spam
 * controls may apply. Subsequent usages include displaying threaded
 * conversations and supporting content moderation review. Errors may include
 * forbidden access, invalid parent comment, or content validation failure.
 *
 * @param props.connection
 * @param props.body Information required to create a new comment reply.
 * @path /discussionBoard/commentReplies
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Information required to create a new comment reply. */
    body: IDiscussionBoardCommentReply.ICreate;
  };
  export type Body = IDiscussionBoardCommentReply.ICreate;
  export type Response = IDiscussionBoardCommentReply;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/commentReplies",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/commentReplies";
  export const random = (): IDiscussionBoardCommentReply =>
    typia.random<IDiscussionBoardCommentReply>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/search comment-replies from discussion_board_comment_reply with
 * filtering and pagination.
 *
 * This endpoint lists or searches comment-replies, which are thread-level
 * second-level responses, extending the base comment-reply logic in the schema.
 * Filter/search fields can include comment author, parent comment, content
 * search (gin_trgm), and temporal windows (created/updated). Pagination is
 * applied for efficient large-set view. Non-authorized users may not see
 * deleted/hidden replies. Most common usage is for presenting nested or
 * threaded views under each post comment or for moderator audit. Error
 * scenarios include 400 for malformed filter, 401/403 for permission errors,
 * and 500 for internal failures. Soft-deleted replies are generally hidden from
 * normal listing but may be requested with moderator privileges.
 *
 * @param props.connection
 * @param props.body Container for comment-reply search/filter/paging criteria.
 * @path /discussionBoard/commentReplies
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Container for comment-reply search/filter/paging criteria. */
    body: IDiscussionBoardCommentReply.IRequest;
  };
  export type Body = IDiscussionBoardCommentReply.IRequest;
  export type Response = IPageIDiscussionBoardCommentReply;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/commentReplies",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/commentReplies";
  export const random = (): IPageIDiscussionBoardCommentReply =>
    typia.random<IPageIDiscussionBoardCommentReply>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get comment-reply detail by ID from discussion_board_comment_reply.
 *
 * This endpoint returns the full details of a specific comment-reply, resolving
 * the discussion_board_comment_reply record and related entities (parent
 * comment, author, etc.) as described in the schema. Useful in threaded
 * display, moderation tools, and user profile activity pages. Soft-deleted
 * replies are generally suppressed except for moderator views or author
 * self-access. Standard errors: 404 for not found, 403 for unauthorized access,
 * 500 for server problems. Permissions enforced by user role. Successful result
 * includes all fields and metadata from schema with full audit trail.
 *
 * @param props.connection
 * @param props.id Unique UUID of the comment-reply to fetch.
 * @path /discussionBoard/commentReplies/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique UUID of the comment-reply to fetch. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardCommentReply;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/commentReplies/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/commentReplies/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardCommentReply =>
    typia.random<IDiscussionBoardCommentReply>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing comment reply (discussion_board_comment_reply table).
 *
 * This API updates the content of a specific comment reply, referenced by its
 * ID, within the discussion_board_comment_reply table. Modifications may be
 * made by the original author or a moderator, following business and moderation
 * rules. All modifications are tracked with an updated_at timestamp for audit
 * and rollback.
 *
 * Only the reply's content or status may be changed; the parent_comment_id and
 * user_id must not be reassignable post-creation for integrity. Moderation
 * workflows can trigger additional notifications to users or audit records.
 * Authorization requires that the caller is the author or a permitted
 * moderator. Error responses include forbidden modification, missing reply ID,
 * or invalid content updates.
 *
 * @param props.connection
 * @param props.id Target comment reply's ID to update.
 * @param props.body Edited reply details (content, status, timestamp).
 * @path /discussionBoard/commentReplies/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target comment reply's ID to update. */
    id: string & tags.Format<"uuid">;

    /** Edited reply details (content, status, timestamp). */
    body: IDiscussionBoardCommentReply.IUpdate;
  };
  export type Body = IDiscussionBoardCommentReply.IUpdate;
  export type Response = IDiscussionBoardCommentReply;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/commentReplies/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/commentReplies/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardCommentReply =>
    typia.random<IDiscussionBoardCommentReply>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a comment reply (discussion_board_comment_reply table).
 *
 * This API soft-deletes a comment reply by its unique ID, in conformance with
 * discussion_board_comment_reply schema and moderation policies. Soft deletion
 * marks the reply with a deleted_at timestamp for audit and recovery, but does
 * not irreversibly remove the data, supporting moderation and dispute
 * workflows.
 *
 * Only reply authors or users with moderator privileges may perform this
 * operation. The system maintains an audit trail for each deletion, potentially
 * notifies stakeholders, and restricts permanent removal to admin-level
 * processes if required by policy. Errors include not-found, forbidden access,
 * or already-deleted status.
 *
 * @param props.connection
 * @param props.id ID of the comment reply to delete.
 * @path /discussionBoard/commentReplies/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** ID of the comment reply to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardCommentReply;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/commentReplies/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/commentReplies/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardCommentReply =>
    typia.random<IDiscussionBoardCommentReply>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
