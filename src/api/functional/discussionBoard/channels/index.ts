import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardChannel } from "../../../structures/IDiscussionBoardChannel";
import { IPageIDiscussionBoardChannel } from "../../../structures/IPageIDiscussionBoardChannel";

/**
 * Create a new discussion_board_channel (admin-only, add channel/division).
 *
 * Receives channel creation data including unique code, name, and optional
 * description. Must ensure channel code uniqueness per business logic, follow
 * naming and audit requirements, and emit complete audit trail. Used by
 * administrators when provisioning new major forum divisions or onboarding new
 * topic areas. This operation strictly restricted to admin role.
 *
 * @param props.connection
 * @param props.body Channel creation request with code/name/optional
 *   description.
 * @path /discussionBoard/channels
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Channel creation request with code/name/optional description. */
    body: IDiscussionBoardChannel.ICreate;
  };
  export type Body = IDiscussionBoardChannel.ICreate;
  export type Response = IDiscussionBoardChannel;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/channels",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/channels";
  export const random = (): IDiscussionBoardChannel =>
    typia.random<IDiscussionBoardChannel>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a paginated, filterable list of discussion_board_channels
 * (channels/top-level boards).
 *
 * Returns a paginated, searchable list of discussion_board_channels (each
 * representing a top-level division under which sections/forums are organized).
 * Serves both public and admin-facing interfaces for accessing channel
 * metadata. Supports filtering by name, code, and description. For admins,
 * enriches config management and topic partitioning; for public, allows
 * navigation and discovery. Pagination parameters meet non-functional
 * requirements for performance and usability.
 *
 * @param props.connection
 * @param props.body Pagination, search/filter parameters for retrieving channel
 *   list.
 * @path /discussionBoard/channels
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Pagination, search/filter parameters for retrieving channel list. */
    body: IDiscussionBoardChannel.IRequest;
  };
  export type Body = IDiscussionBoardChannel.IRequest;
  export type Response = IPageIDiscussionBoardChannel;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/channels",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/channels";
  export const random = (): IPageIDiscussionBoardChannel =>
    typia.random<IPageIDiscussionBoardChannel>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific discussion_board_channel (by id) with all metadata
 * fields.
 *
 * Returns all primary fields of a discussion_board_channel (code, name,
 * description, created/updated/deleted_at). No write/moderation rights are
 * requiredâ€”access policy determined by board privacy policy. This endpoint is
 * critical for UI deep links, admin management panels, and featured content
 * sections where single channel info is needed.
 *
 * @param props.connection
 * @param props.id UUID of the channel to retrieve
 *   (discussion_board_channels.id).
 * @path /discussionBoard/channels/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** UUID of the channel to retrieve (discussion_board_channels.id). */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardChannel;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/channels/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/channels/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardChannel =>
    typia.random<IDiscussionBoardChannel>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update the specified channel's information by UUID (admin-only, full update).
 *
 * Receives new values for code, name, and description; applies to the specified
 * channel by id. On success, returns the updated row including all audit
 * fields. Business logic ensures only unique codes, valid descriptions, and
 * audit-compliant metadata are accepted. Operation triggers audit logs for
 * platform management. Admin access only.
 *
 * @param props.connection
 * @param props.id UUID for the channel row to update
 *   (discussion_board_channels.id).
 * @param props.body Full channel update request (code, name, description).
 * @path /discussionBoard/channels/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** UUID for the channel row to update (discussion_board_channels.id). */
    id: string & tags.Format<"uuid">;

    /** Full channel update request (code, name, description). */
    body: IDiscussionBoardChannel.IUpdate;
  };
  export type Body = IDiscussionBoardChannel.IUpdate;
  export type Response = IDiscussionBoardChannel;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/channels/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/channels/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardChannel =>
    typia.random<IDiscussionBoardChannel>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a discussion_board_channel by id (admin-only, reversible
 * removal).
 *
 * Marks the specified channel as deleted (deleted_at timestamp populated),
 * preserving all historical and audit data for compliance. Operation is
 * auditable and can be undone via admin interface. For use in deprecating or
 * archiving major forum divisions.
 *
 * @param props.connection
 * @param props.id UUID of the channel row to soft-delete
 *   (discussion_board_channels.id).
 * @path /discussionBoard/channels/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /**
     * UUID of the channel row to soft-delete
     * (discussion_board_channels.id).
     */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardChannel;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/channels/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/channels/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardChannel =>
    typia.random<IDiscussionBoardChannel>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
