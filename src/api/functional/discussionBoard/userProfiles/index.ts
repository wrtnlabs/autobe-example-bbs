import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardUserProfile } from "../../../structures/IDiscussionBoardUserProfile";
import { IPageIDiscussionBoardUserProfile } from "../../../structures/IPageIDiscussionBoardUserProfile";
import { IOperationStatus } from "../../../structures/IOperationStatus";

/**
 * Create a new profile (discussion_board_user_profile) entity.
 *
 * The POST /discussionBoard/userProfiles endpoint allows creation of a user
 * profile record in the discussion_board_user_profile table, for use after a
 * user is registered or when admins initialize a new account profile.
 *
 * Business use cases include profile setup, enrichment by admins, or update by
 * the account owner after registration. The endpoint enforces only one profile
 * per user (uniqueness via user_id), and all data is validated for constraints
 * and business rules (length, proper URIs for images, etc.).
 *
 * Success returns the created profile object, minus sensitive info if any.
 * Related endpoints handle core user account, and role assignments.
 *
 * @param props.connection
 * @param props.body Profile creation data (display name, bio, etc.).
 * @path /discussionBoard/userProfiles
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Profile creation data (display name, bio, etc.). */
    body: IDiscussionBoardUserProfile.ICreate;
  };
  export type Body = IDiscussionBoardUserProfile.ICreate;
  export type Response = IDiscussionBoardUserProfile;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/userProfiles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/userProfiles";
  export const random = (): IDiscussionBoardUserProfile =>
    typia.random<IDiscussionBoardUserProfile>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Paginated, filtered profile search from discussion_board_user_profile table.
 *
 * The PATCH /discussionBoard/userProfiles endpoint supplies paginated,
 * searchable lists of user profile records (from
 * discussion_board_user_profile), supporting search/filter by display_name,
 * bio, and other profile fields. Results are paged, with support for complex
 * queries for moderation and admin views.
 *
 * This endpoint references the 'discussion_board_user_profile' Prisma table,
 * with business logic to support privacy policies (e.g., admin access to all
 * records, users to their own). Use cases cover profile analytics, batch
 * inspection, and dynamic display of profiles in leaderboards or discovery
 * flows.
 *
 * Request validation covers pagination metadata and filter structure
 * validation. Error handling for malformed requests or permissions issues.
 * Response is a standard paginated payload. This endpoint links to profile
 * detail, update, and user table endpoints as well.
 *
 * @param props.connection
 * @param props.body Profile search and pagination payload.
 * @path /discussionBoard/userProfiles
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Profile search and pagination payload. */
    body: IDiscussionBoardUserProfile.IRequest;
  };
  export type Body = IDiscussionBoardUserProfile.IRequest;
  export type Response = IPageIDiscussionBoardUserProfile;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/userProfiles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/userProfiles";
  export const random = (): IPageIDiscussionBoardUserProfile =>
    typia.random<IPageIDiscussionBoardUserProfile>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single user profile (discussion_board_user_profile) by id.
 *
 * The GET /discussionBoard/userProfiles/{id} endpoint retrieves a detailed
 * profile entity from the discussion_board_user_profile table for a specified
 * UUID. It returns bio, display name, profile picture URI, and other user-set
 * profile data.
 *
 * Business scenarios include user-facing profile pages, admin and moderator
 * inspection, and profile audits. Request must supply a valid UUID path
 * parameter. Security logic ensures only privileged users or profile owners can
 * access non-public profiles. Not-found or forbidden errors occur where
 * needed.
 *
 * The endpoint may be used after searching profiles, for viewing a profile in
 * detail, or to populate profile displays in activity logs. It connects to
 * update and audit endpoints as well.
 *
 * @param props.connection
 * @param props.id UUID for the user profile to fetch.
 * @path /discussionBoard/userProfiles/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** UUID for the user profile to fetch. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardUserProfile;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/userProfiles/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/userProfiles/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardUserProfile =>
    typia.random<IDiscussionBoardUserProfile>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing user profile (discussion_board_user_profile) by id.
 *
 * The PUT /discussionBoard/userProfiles/{id} endpoint updates profile fields
 * for the user profile record matching the provided UUID in the
 * discussion_board_user_profile table. Updatable properties include
 * display_name, bio, and profile_picture_uri, with strict validation for
 * formats and allowed values.
 *
 * Security is enforced: only the profile owner or elevated roles (admin,
 * moderator) can invoke this endpoint on an arbitrary profile. Full response is
 * returned for audit or UI update. Error handling covers not-found,
 * unauthorized, and validation failures.
 *
 * May be used as part of a user onboarding/completion experience, or as a
 * moderation/admin corrective tool. Related to profile get, create, and search
 * endpoints.
 *
 * @param props.connection
 * @param props.id Target profile's UUID.
 * @param props.body Updated profile fields (display_name, bio, etc.)
 * @path /discussionBoard/userProfiles/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Target profile's UUID. */
    id: string & tags.Format<"uuid">;

    /** Updated profile fields (display_name, bio, etc.) */
    body: IDiscussionBoardUserProfile.IUpdate;
  };
  export type Body = IDiscussionBoardUserProfile.IUpdate;
  export type Response = IDiscussionBoardUserProfile;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/userProfiles/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/userProfiles/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardUserProfile =>
    typia.random<IDiscussionBoardUserProfile>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete/disable a user profile (discussion_board_user_profile) by id (soft
 * delete).
 *
 * The DELETE /discussionBoard/userProfiles/{id} endpoint disables or
 * soft-deletes the referenced user profile in discussion_board_user_profile for
 * the specified UUID. The action sets the deleted_at field or marks the profile
 * as inactive without physical deletion, ensuring audit and compliance
 * practices.
 *
 * Authorization is enforced to prevent unauthorized profile
 * deletion—admins/moderators or the profile owner may act. A successful
 * deletion responds with an operation status indicator. Errors for not-found or
 * validation are returned as appropriate.
 *
 * Use cases span administrative corrections, moderation enforcement, and
 * privacy-compliance flows. This endpoint may trigger further data cleanup or
 * notification workflows. Related endpoints include profile get, update, and
 * paginated search endpoints.
 *
 * @param props.connection
 * @param props.id UUID of the user profile to delete/disable.
 * @path /discussionBoard/userProfiles/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** UUID of the user profile to delete/disable. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IOperationStatus;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/userProfiles/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/userProfiles/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IOperationStatus =>
    typia.random<IOperationStatus>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
