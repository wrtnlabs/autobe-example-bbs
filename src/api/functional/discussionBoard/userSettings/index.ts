import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IDiscussionBoardUserSetting } from "../../../structures/IDiscussionBoardUserSetting";
import { IPageIDiscussionBoardUserSetting } from "../../../structures/IPageIDiscussionBoardUserSetting";

/**
 * Create a new discussion_board_user_setting record.
 *
 * This API creates a new settings record for a user, allowing explicit
 * selection of notification preferences, UI theme, and interface language (as
 * required for accessibility and personalization per requirements document).
 * Conversation participants must be authenticated, and one user cannot have
 * multiple settings records. If an existing record already exists for the
 * specified user, returns an error. Related endpoints allow updating, patching,
 * or deleting existing settings. Security: Only a user or admin can invoke this
 * endpoint for their own settings.
 *
 * @param props.connection
 * @param props.body Creation info for user settings.
 * @path /discussionBoard/userSettings
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return true === connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** Creation info for user settings. */
    body: IDiscussionBoardUserSetting.ICreate;
  };
  export type Body = IDiscussionBoardUserSetting.ICreate;
  export type Response = IDiscussionBoardUserSetting;

  export const METADATA = {
    method: "POST",
    path: "/discussionBoard/userSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/userSettings";
  export const random = (): IDiscussionBoardUserSetting =>
    typia.random<IDiscussionBoardUserSetting>();
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List discussion_board_user_setting records with filters and pagination.
 *
 * Lists user settings records (discussion_board_user_setting) that match search
 * filters such as notification/in-app email flags, theme, or language
 * preference. Pagination parameters control result set size. This endpoint is
 * secured so only authorized admins or the current user can view these records.
 * Use cases include administrative review of all usersâ€™ settings, analytics on
 * notification opt-in rates, or advanced personalized search. If filters are
 * invalid or the requesting user is not authorized, returns an error. Related
 * endpoints allow creation (POST), read by ID (GET), update (PUT), and deletion
 * (DELETE) of specific user setting records.
 *
 * @param props.connection
 * @param props.body User settings search, filter, and pagination info.
 * @path /discussionBoard/userSettings
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** User settings search, filter, and pagination info. */
    body: IDiscussionBoardUserSetting.IRequest;
  };
  export type Body = IDiscussionBoardUserSetting.IRequest;
  export type Response = IPageIDiscussionBoardUserSetting;

  export const METADATA = {
    method: "PATCH",
    path: "/discussionBoard/userSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/discussionBoard/userSettings";
  export const random = (): IPageIDiscussionBoardUserSetting =>
    typia.random<IPageIDiscussionBoardUserSetting>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a discussion_board_user_setting record by ID.
 *
 * Returns a single discussion_board_user_setting as defined in the Prisma
 * schema for user preferences. Authentication verifies that only the owner or
 * administrators can access the requested record. Returns an error for missing
 * records or unauthorized access attempts. Frequently used for displaying
 * preference panels, supporting detailed audits, or for troubleshooting user
 * experience issues. Works together with update (PUT), partial update (PATCH),
 * and delete (DELETE) endpoints for full CRUD coverage.
 *
 * @param props.connection
 * @param props.id ID of the settings record to retrieve.
 * @path /discussionBoard/userSettings/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return true === connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** ID of the settings record to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardUserSetting;

  export const METADATA = {
    method: "GET",
    path: "/discussionBoard/userSettings/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/userSettings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardUserSetting =>
    typia.random<IDiscussionBoardUserSetting>();
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a discussion_board_user_setting record by ID.
 *
 * This endpoint allows a user or admin to fully update settings by ID,
 * replacing notification/email/in-app flags, theme, and language preferences.
 * If the record is not found, returns an error. Use this endpoint only for
 * whole-record changes; to update just a portion, use PATCH (if implemented).
 * Access is limited to the user (for their own record) or admin. Related
 * endpoints include GET by ID, POST for new record creation, PATCH for search,
 * DELETE for record removal.
 *
 * @param props.connection
 * @param props.id ID of the user settings record to update.
 * @param props.body User settings update payload.
 * @path /discussionBoard/userSettings/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return true === connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** ID of the user settings record to update. */
    id: string & tags.Format<"uuid">;

    /** User settings update payload. */
    body: IDiscussionBoardUserSetting.IUpdate;
  };
  export type Body = IDiscussionBoardUserSetting.IUpdate;
  export type Response = IDiscussionBoardUserSetting;

  export const METADATA = {
    method: "PUT",
    path: "/discussionBoard/userSettings/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/discussionBoard/userSettings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardUserSetting =>
    typia.random<IDiscussionBoardUserSetting>();
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a discussion_board_user_setting record by ID.
 *
 * This endpoint soft-deletes a user setting record from the
 * discussion_board_user_setting table, updating the record's deleted_at flag
 * for recovery and compliance. Only the owner or an administrator is authorized
 * to delete a settings record. Related endpoints allow creation, retrieval, and
 * updating of user setting records. Access is limited by authentication. If not
 * found, or not authorized, returns an error.
 *
 * @param props.connection
 * @param props.id ID of the user settings record to soft-delete.
 * @path /discussionBoard/userSettings/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return true === connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** ID of the user settings record to soft-delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IDiscussionBoardUserSetting;

  export const METADATA = {
    method: "DELETE",
    path: "/discussionBoard/userSettings/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/discussionBoard/userSettings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IDiscussionBoardUserSetting =>
    typia.random<IDiscussionBoardUserSetting>();
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
