import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IThreadTag } from "../../../structures/IThreadTag";
import { IPageIThreadTag } from "../../../structures/IPageIThreadTag";

/**
 * Creates a new thread-tag assignment, linking a tag to a thread in the
 * normalized M:N table.
 *
 * This endpoint assigns a tag to a thread, creating an entry in the
 * 'thread_tags' table. Both thread_id and tag_id must exist and be unique for
 * that assignment (composite unique constraint is enforced by Prisma). Atomic,
 * normalized row creation with the correct metadata is carried out, and audit
 * logs may record the creation event for transparency.
 *
 * Validates references to ensure the tag and thread both exist and are not
 * already linked. Returns the newly created thread-tag object. Only admins,
 * moderators, or users with required trust are allowed if business logic
 * specifies. This operation supports all forum tagging, search, and filter
 * features and is directly linked to tag moderation endpoints.
 *
 * @param props.body The required thread_id and tag_id for a new assignment.
 * @path /categoriesTags/threadTags
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function post(
  connection: IConnection,
  props: post.Props,
): Promise<post.Response> {
  return !!connection.simulate
    ? post.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...post.METADATA,
          path: post.path(),
          status: null,
        },
        props.body,
      );
}
export namespace post {
  export type Props = {
    /** The required thread_id and tag_id for a new assignment. */
    body: IThreadTag.ICreate;
  };
  export type Body = IThreadTag.ICreate;
  export type Response = IThreadTag;

  export const METADATA = {
    method: "POST",
    path: "/categoriesTags/threadTags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/categoriesTags/threadTags";
  export const random = (g?: Partial<typia.IRandomGenerator>): IThreadTag =>
    typia.random<IThreadTag>(g);
  export const simulate = (
    connection: IConnection,
    props: post.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: post.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieves a paginated, filtered list of thread-tag assignments from the
 * normalized M:N 'thread_tags' table.
 *
 * This endpoint enables clients to list thread-tag relationships, each
 * representing an assignment of a tag to a thread (thread_tags table). The
 * search supports filtering by tag name, thread title, or direct ids, as well
 * as creation date and sorting preferences for optimal administrative UI/UX.
 *
 * Results return normalized atomic assignments, strictly adhering to 3NF and
 * auditability. Used for managing, reviewing, and auditing tagged content
 * across the forum. Pagination ensures scalable performance for large boards.
 * RBAC may restrict sensitive filters or expose metadata for admin-only views.
 * This operation forms the basis for tag-assignment dashboards and bulk
 * curation tools.
 *
 * @param props.body List filtering, searching, and pagination parameters (by
 *   tag, thread, creation date, etc).
 * @path /categoriesTags/threadTags
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return !!connection.simulate
    ? patch.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /**
     * List filtering, searching, and pagination parameters (by tag, thread,
     * creation date, etc).
     */
    body: IThreadTag.IRequest;
  };
  export type Body = IThreadTag.IRequest;
  export type Response = IPageIThreadTag;

  export const METADATA = {
    method: "PATCH",
    path: "/categoriesTags/threadTags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/categoriesTags/threadTags";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIThreadTag => typia.random<IPageIThreadTag>(g);
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieves atomic details of a thread-tag assignment from the 'thread_tags'
 * table by id.
 *
 * This endpoint fetches the details of a single thread-tag assignment using its
 * unique id. It returns an atomic thread-tag object containing references to
 * both the thread and the tag, with assignment metadata (such as timestamp).
 *
 * Used for moderating, tracking, or auditing tag usage, as well as powering
 * detailed admin or dashboard displays. Error handling returns not-found for
 * invalid ids or if assignment was deleted. Related endpoints include bulk
 * assignment listing, creation, and update. Security: access may be restricted
 * to moderators/admins for audit or curation scenarios, but read-only for most
 * authenticated users.
 *
 * @param props.id Unique identifier for the thread-tag assignment to retrieve.
 * @path /categoriesTags/threadTags/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getById(
  connection: IConnection,
  props: getById.Props,
): Promise<getById.Response> {
  return !!connection.simulate
    ? getById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getById.METADATA,
          path: getById.path(props),
          status: null,
        },
      );
}
export namespace getById {
  export type Props = {
    /** Unique identifier for the thread-tag assignment to retrieve. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IThreadTag;

  export const METADATA = {
    method: "GET",
    path: "/categoriesTags/threadTags/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/categoriesTags/threadTags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IThreadTag =>
    typia.random<IThreadTag>(g);
  export const simulate = (
    connection: IConnection,
    props: getById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Updates a thread-tag assignment in the 'thread_tags' table by unique id,
 * enforcing uniqueness and normalization.
 *
 * This endpoint updates the details of a thread-tag assignment, as identified
 * by its unique id. It is used by admin or moderator workflows to modify how
 * threads are labeled, enforcing atomic updates per Prisma schema and ensuring
 * the (thread_id, tag_id) pair remains unique after any change.
 *
 * Error handling is provided for attempts to create duplicates, reference
 * invalid threads/tags, or update with malformed data. Edits are typically
 * logged for audit/compliance. The endpoint is part of the overall tag
 * management and search/filter UI functions. It helps maintain highly accurate
 * topic categorization across the board.
 *
 * @param props.id Unique id of the thread-tag assignment to update.
 * @param props.body The updated thread_id or tag_id values (atomic and unique).
 * @path /categoriesTags/threadTags/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putById(
  connection: IConnection,
  props: putById.Props,
): Promise<putById.Response> {
  return !!connection.simulate
    ? putById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putById.METADATA,
          path: putById.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace putById {
  export type Props = {
    /** Unique id of the thread-tag assignment to update. */
    id: string & tags.Format<"uuid">;

    /** The updated thread_id or tag_id values (atomic and unique). */
    body: IThreadTag.IUpdate;
  };
  export type Body = IThreadTag.IUpdate;
  export type Response = IThreadTag;

  export const METADATA = {
    method: "PUT",
    path: "/categoriesTags/threadTags/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/categoriesTags/threadTags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): IThreadTag =>
    typia.random<IThreadTag>(g);
  export const simulate = (
    connection: IConnection,
    props: putById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Deletes a thread-tag assignment from the 'thread_tags' M:N table by its
 * unique id, returning a status result.
 *
 * This endpoint removes a thread-tag assignment from the 'thread_tags' table.
 * Deletion occurs by unique assignment id, with underlying logic ensuring the
 * relationship is not required for referential integrity elsewhere. Typically,
 * only admins or moderators perform this operation, and all actions are logged
 * for audit and review purposes as dictated by business rules.
 *
 * Handles errors for non-existent assignments or dependencies blocking
 * deletion. Ensures continued adherence to strict atomic and normalized data
 * models. Enables clean-up of tag assignments to keep thread discovery and
 * search/filtering highly accurate.
 *
 * @param props.id Unique id of the thread-tag assignment to delete.
 * @path /categoriesTags/threadTags/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseById(
  connection: IConnection,
  props: eraseById.Props,
): Promise<eraseById.Response> {
  return !!connection.simulate
    ? eraseById.simulate(connection, props)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseById.METADATA,
          path: eraseById.path(props),
          status: null,
        },
      );
}
export namespace eraseById {
  export type Props = {
    /** Unique id of the thread-tag assignment to delete. */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IThreadTag.IDeleteResult;

  export const METADATA = {
    method: "DELETE",
    path: "/categoriesTags/threadTags/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/categoriesTags/threadTags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IThreadTag.IDeleteResult => typia.random<IThreadTag.IDeleteResult>(g);
  export const simulate = (
    connection: IConnection,
    props: eraseById.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseById.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
