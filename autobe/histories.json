[
  {
    "id": "b51adde4-9e1e-4412-9641-df0869e3ab12",
    "type": "userMessage",
    "contents": [
      {
        "type": "text",
        "text": "I want to create a political/economic discussion board. Since I'm not familiar with programming, please write a requirements analysis report as you see fit. The report should be approximately 3 pages long.\n"
      }
    ],
    "created_at": "2025-06-09T05:49:50.474Z"
  },
  {
    "id": "4444a46e-6ede-4049-b27a-628e6e96271f",
    "type": "analyze",
    "reason": "Create a requirements analysis report for a political/economic discussion board. The report should be about 3 pages long and suitable for someone with no programming background. Use clear, non-technical explanations for the system purpose, features, user roles, data structure, and business rules. Do not include any design requirements, as the user did not provide any. If user input is vague or incomplete, supplement only with standard best practices for such platforms.",
    "files": {
      "00_toc.md": "# Table of Contents\n\n1. [Introduction and Purpose](01_introduction_and_purpose.md)\n2. [Key Features and User Roles](02_key_features_and_user_roles.md)\n3. [Data Structure and Business Rules](03_data_structure_and_business_rules.md)\n\nEach section is designed to clearly lay out the purpose, main functions, target users, and operational guidelines for the discussion board, using accessible language suitable for non-technical readers.",
      "01_introduction_and_purpose.md": "# Introduction and Purpose\n\n## Overview\nThis document provides an introduction and outlines the purpose of a Political/Economic Discussion Board platform. It is intended for an audience with no programming background, aiming for clarity and accessibility about the system’s objectives and value. This document is part of a broader requirements analysis, which includes system features, user roles, data structure, and business rules covered in related documents.\n\n## Goals of the Discussion Board\n\nThe Political/Economic Discussion Board is designed as an online gathering place where people can discuss, share, and debate topics related to politics and economics. The main goals of the platform are:\n\n- To foster informed and respectful conversations.\n- To create a space where users can share news, opinions, and analysis.\n- To support constructive debate by allowing different perspectives to be expressed.\n- To encourage community-driven content while moderating for civility and factual accuracy.\n\n## Target Users\nThe discussion board is intended for:\n- General members of the public interested in politics and economics\n- Students and educators seeking information or discussion opportunities\n- Journalists and opinion leaders sharing insights or analysis\n- Community moderators keeping conversations respectful and accurate\n\n## Use Cases\nTypical ways people might use the discussion board include:\n- Posting questions about current political or economic events\n- Sharing news articles and starting discussions\n- Engaging in debates on policy proposals or global events\n- Fact-checking statements for accuracy\n- Connecting with others who have similar or opposing viewpoints\n\n## Benefits\nThe platform provides a reliable, easy-to-use space for civic engagement. Users benefit from:\n- Free access to wide-ranging discussions\n- Exposure to multiple viewpoints, promoting critical thinking\n- Guidance and moderation to ensure a respectful environment\n- The ability to both consume and contribute content easily\n\n---\n\n[Continue to Key Features and User Roles](02_key_features_and_user_roles.md)",
      "02_key_features_and_user_roles.md": "# Key Features and User Roles\n\n## Overview\nThis section outlines the essential functions and participant roles for a political/economic discussion board. The goal is to facilitate open, respectful, and insightful discussions on political and economic topics, making it easy for users of any background to engage safely and meaningfully.\n\n---\n\n## 1. Core Features\n\n### 1.1. Discussion Threads\n- Users can create, view, and contribute to ongoing discussions (called \"threads\").\n- Threads are organized by category (e.g., politics, economics, current events), enabling easy navigation.\n\n### 1.2. Posting and Commenting\n- Registered users can start new threads or reply to existing ones.\n- Replies can be nested to show conversation flow.\n\n### 1.3. Voting System\n- Users can upvote or downvote posts and replies, raising helpful or insightful contributions and lowering less useful ones.\n\n### 1.4. Moderation Tools\n- Moderators oversee discussions, enforce rules, and can remove posts that violate guidelines (e.g., hate speech, spam).\n- Users can report inappropriate content for review.\n\n### 1.5. User Profiles and Reputation\n- Each user has a profile with a public username, optional bio, and summary of their participation.\n- Reputation points reflect positive contributions and trustworthiness.\n\n### 1.6. Notification and Search\n- Notifications alert users to replies or mentions.\n- Search tools help find relevant discussions and posts.\n\n---\n\n## 2. User Roles\n\n| Role         | Main Abilities                                                    |\n|--------------|-------------------------------------------------------------------|\n| Visitor      | Browse and read posts, but cannot participate actively            |\n| Member       | Create threads, comment, vote, customize profile                  |\n| Moderator    | Edit/delete posts, manage reports, enforce rules, assist users    |\n| Administrator| Set rules, manage categories and users, oversee the platform      |\n\n- **Visitors** have read-only access for easy entry.\n- **Members** can fully participate in discussions after signing up.\n- **Moderators** are trusted community members with extra responsibilities to keep the board welcoming and informative.\n- **Administrators** manage the overall setup, policies, and safety of the platform.\n\n---\n\n## 3. Accessibility & Best Practices\n- Simple, clear navigation for all users.\n- Rule reminders before posting.\n- Options to follow or mute threads.\n- Privacy protections, such as the ability to hide real names.\n\n---\n\n[Return to Table of Contents](./00_toc.md) | [Next: Data Structure & Business Rules](./03_data_structure_and_business_rules.md)\n",
      "03_data_structure_and_business_rules.md": "# Data Structure and Business Rules for Political/Economic Discussion Board\n\n---\n\n## Overview\nThis section describes how the key information and rules that enable a robust, user-focused political/economic discussion board are structured. The explanations are intended for a general audience with no technical background. No design or implementation details are included, focusing solely on the organization and logic that would shape the platform.\n\n## 1. Core Data Entities\nThe discussion board revolves around several main types of information (“data entities”). These define what kinds of things exist in the system and how they are related. The main entities are:\n\n- **User:** An individual participating on the board (as reader, poster, or moderator)\n- **Post:** A discussion topic or article submitted by a user\n- **Comment:** A reply or discussion made in response to a post or another comment\n- **Category:** Broad topics (e.g., politics, economics, international affairs) under which posts are organized\n- **Vote:** An indication of support or disagreement with posts or comments\n\n### Entity Table\n| Entity     | Description                          | Main Attributes                 |\n|------------|--------------------------------------|---------------------------------|\n| User       | A registered board member            | Username, email, role, status   |\n| Post       | New topic or article                 | Title, content, author, time, category, vote tally |\n| Comment    | Response to post/comment             | Content, author, time, parent post/comment, vote tally |\n| Category   | Topic area for organization          | Name, description               |\n| Vote       | User feedback on posts/comments      | Voter, target (post/comment), value (+1 or -1) |\n\n## 2. Relationships and Data Flow\n- A **User** can create many **Posts** and **Comments**.\n- Each **Post** belongs to one **Category**, and each **Comment** is linked to a **Post** or another **Comment**.\n- A **Post** or **Comment** can have multiple **Votes** from different **Users**.\n\n### Example Relationship Diagram\n\n```mermaid\nerDiagram\n    USER ||--o{ POST : makes\n    USER ||--o{ COMMENT : writes\n    POST ||--o{ COMMENT : receives\n    POST }o--|| CATEGORY : organized_in\n    COMMENT ||--o{ COMMENT : replies\n    POST ||--o{ VOTE : receives\n    COMMENT ||--o{ VOTE : receives\n    USER ||--o{ VOTE : submits\n```\n\n## 3. Business Rules\nBusiness rules are guidelines and requirements that keep the board fair, informative, and secure.\n\n### 3.1 Posting and Commenting\n- Only registered users can create posts or comments.\n- Posts must be assigned to a category.\n- Comments can be placed on posts or as replies to other comments.\n- Editing and deleting posts or comments is limited to their original authors (within a time window, if enforced).\n\n### 3.2 Voting System\n- All registered users can vote (upvote or downvote) on posts and comments.\n- Each user is allowed only one vote per post or comment.\n- Vote tallies are visible and help users find useful or popular discussions.\n\n### 3.3 Moderation and User Roles\n- Roles include: regular users, moderators, and administrators.\n- Moderators can remove posts/comments that violate policies (e.g., personal attacks, hate speech).\n- Repeated rule-breaking may result in warnings, temporary suspensions, or bans.\n\n### 3.4 Content Organization\n- Categories are managed by administrators, ensuring posts fit the board’s focus.\n- Users can suggest new categories for consideration.\n\n### 3.5 Privacy and Security\n- Email addresses and private data are not publicly visible.\n- Passwords and sensitive information remain protected.\n- Users must accept the terms and rules before joining.\n\n## 4. Example Scenario\nA new user joins and chooses their area of interest, such as \"Economics.\" They post a discussion about inflation. Other users reply, ask questions, and upvote insightful comments. Moderators remove off-topic or rule-breaking content.\n\n## 5. Key Takeaways\n- The platform encourages respectful and insightful debate on political and economic topics.\n- Rules and structures ensure fair participation, content quality, and a safe environment.\n- The board is organized for easy navigation, with user-driven voting to highlight quality discussions.\n\n[Return to Table of Contents](./00_toc.md)\n"
    },
    "step": 0,
    "created_at": "2025-06-09T05:49:56.464Z",
    "completed_at": "2025-06-09T05:50:44.046Z"
  },
  {
    "id": "036b8432-0aa1-4b9e-b86e-ce9fc5a82f84",
    "type": "userMessage",
    "contents": [
      {
        "type": "text",
        "text": "Design the database schema, but don't make it complicate please.\n"
      }
    ],
    "created_at": "2025-06-09T05:51:32.953Z"
  },
  {
    "type": "prisma",
    "id": "8ddb5a92-c653-410b-81a6-8d25aefdd437",
    "created_at": "2025-06-09T05:51:36.014Z",
    "completed_at": "2025-06-09T05:54:22.131Z",
    "reason": "The requirements analysis report for a political/economic discussion board has been completed and the user requested a simple, non-complicated database schema. Proceed to design a straightforward schema with minimal but sufficient entities and relationships for this context.",
    "description": "",
    "result": {
      "success": true,
      "data": {
        "files": [
          {
            "filename": "schema-01-core.prisma",
            "namespace": "Core",
            "models": [
              {
                "name": "users",
                "description": "User information - This implements the 'User' entity from the requirements analysis document (03_data_structure_and_business_rules.md). \n\nRepresents registered members of the discussion board. Each user record holds public profile data and permissions (role and status). For example, Alice with email alice@email.com can be a regular user, moderator, or admin.\n\nKey relationships: references user_roles for permission, and relates to posts, comments, and votes they create.\nSpecial behaviors: emails are unique; passwords are stored securely; role assignment required.",
                "material": false,
                "primaryField": {
                  "name": "id",
                  "type": "uuid",
                  "description": "Primary Key. \nUnique identifier for each user."
                },
                "foreignFields": [
                  {
                    "name": "user_role_id",
                    "type": "uuid",
                    "description": "Role of the user. Target model's {@link user_roles.id}.\nDetermines user permissions such as regular member, moderator, or administrator.",
                    "relation": {
                      "name": "role",
                      "targetModel": "user_roles"
                    },
                    "unique": false,
                    "nullable": false
                  }
                ],
                "plainFields": [
                  {
                    "name": "username",
                    "type": "string",
                    "description": "Username visible on the platform - Implements profile display requirement. Must be unique and public. For example, 'politicoFan88'.",
                    "nullable": false
                  },
                  {
                    "name": "email",
                    "type": "string",
                    "description": "User's email address - Used for login and notifications. Must be unique. For example, 'user@example.com'.",
                    "nullable": false
                  },
                  {
                    "name": "bio",
                    "type": "string",
                    "description": "Optional short biography - Lets users share info about themselves. For example, 'Economics student, debate enthusiast.'",
                    "nullable": true
                  },
                  {
                    "name": "password_hash",
                    "type": "string",
                    "description": "Hashed password - Implements security requirement. Stores a hashed version of the user password for authentication. Example: long hash string. Not public.",
                    "nullable": false
                  },
                  {
                    "name": "created_at",
                    "type": "datetime",
                    "description": "Account creation timestamp - Implements auditability. For example, '2024-06-09T10:00:00+09:00'.",
                    "nullable": false
                  },
                  {
                    "name": "updated_at",
                    "type": "datetime",
                    "description": "Timestamp of last profile update - Implements history/auth traceability. For example, '2024-07-01T12:30:00+09:00'.",
                    "nullable": false
                  },
                  {
                    "name": "status",
                    "type": "string",
                    "description": "Account status - Implements moderation/authentication rules. For example, 'active', 'suspended', or 'banned'.",
                    "nullable": false
                  }
                ],
                "uniqueIndexes": [
                  {
                    "fieldNames": [
                      "username"
                    ],
                    "unique": true
                  },
                  {
                    "fieldNames": [
                      "email"
                    ],
                    "unique": true
                  }
                ],
                "plainIndexes": [
                  {
                    "fieldNames": [
                      "created_at"
                    ]
                  }
                ],
                "ginIndexes": []
              },
              {
                "name": "user_roles",
                "description": "User role definitions - This implements the role structure outlined in user roles section of the requirements analysis document (02_key_features_and_user_roles.md).\n\nDefines different permissions and capabilities for users. For example, 'member', 'moderator', 'administrator'.\n\nKey relationships: referenced by users table; no direct link to posts or comments.\nSpecial behaviors: role 'name' must be unique.",
                "material": false,
                "primaryField": {
                  "name": "id",
                  "type": "uuid",
                  "description": "Primary Key. Unique identifier for user role."
                },
                "foreignFields": [],
                "plainFields": [
                  {
                    "name": "name",
                    "type": "string",
                    "description": "Role label - Implements user roles requirement. Example: 'member', 'moderator', 'administrator'. Must be unique.",
                    "nullable": false
                  },
                  {
                    "name": "description",
                    "type": "string",
                    "description": "Role description - Gives context about permissions and duties; e.g., 'Can moderate comments and suspend users' for moderators.",
                    "nullable": false
                  }
                ],
                "uniqueIndexes": [
                  {
                    "fieldNames": [
                      "name"
                    ],
                    "unique": true
                  }
                ],
                "plainIndexes": [],
                "ginIndexes": []
              },
              {
                "name": "categories",
                "description": "Discussion categories - This covers the 'Category' entity from the requirements document (03_data_structure_and_business_rules.md).\n\nRepresents the main topic divisions organizing posts. For example, 'Politics', 'Economics', 'International Affairs'.\n\nKey relationships: referenced by posts; managed by administrators.\nSpecial behaviors: unique name required, can be suggested by users but created by admin.",
                "material": false,
                "primaryField": {
                  "name": "id",
                  "type": "uuid",
                  "description": "Primary Key. Unique identifier for category."
                },
                "foreignFields": [],
                "plainFields": [
                  {
                    "name": "name",
                    "type": "string",
                    "description": "Category name - Implements content organization and navigation requirement. For example, 'Politics'. Must be unique per category.",
                    "nullable": false
                  },
                  {
                    "name": "description",
                    "type": "string",
                    "description": "Category description - Explains scope. For example, 'Discussion about domestic and international political systems, governance, and related events.'",
                    "nullable": false
                  },
                  {
                    "name": "created_at",
                    "type": "datetime",
                    "description": "Timestamp when the category was added - Implements audit trail. Example: '2024-06-09T09:00:00+09:00'.",
                    "nullable": false
                  }
                ],
                "uniqueIndexes": [
                  {
                    "fieldNames": [
                      "name"
                    ],
                    "unique": true
                  }
                ],
                "plainIndexes": [
                  {
                    "fieldNames": [
                      "created_at"
                    ]
                  }
                ],
                "ginIndexes": []
              }
            ]
          },
          {
            "filename": "schema-02-posts.prisma",
            "namespace": "Posts",
            "models": [
              {
                "name": "posts",
                "description": "Post entity - This implements the 'Post' entity from the requirements document (see Data Structure and Business Rules, section 1, and Example Scenario). \n\nRepresents discussion topics or articles submitted by users. Provides a core construct to enable users to initiate threads, share analysis, and start community debates. For example, a user posts a discussion about inflation in the 'Economics' category. \n\nKey relationships: Each post belongs to one user (author) and one category. Each post can have many comments and votes. \nSpecial behaviors: A post must be assigned to a category, may be edited/deleted by its author, and is visible to all users. Vote tally and creation metadata are key for surfacing relevant content.",
                "material": false,
                "primaryField": {
                  "name": "id",
                  "type": "uuid",
                  "description": "Primary Key. Unique identifier for each post."
                },
                "foreignFields": [
                  {
                    "name": "user_id",
                    "type": "uuid",
                    "description": "Author's {@link users.id} - Links each post to its authoring user account. Enforces the association between posts and registered users. Required for accountability and profile-related features.",
                    "relation": {
                      "name": "author",
                      "targetModel": "users"
                    },
                    "unique": false,
                    "nullable": false
                  },
                  {
                    "name": "category_id",
                    "type": "uuid",
                    "description": "Category's {@link categories.id} - Associates the post with a topic/category, used for board structure and navigation. Enforces the requirement that every post has a topical context.",
                    "relation": {
                      "name": "category",
                      "targetModel": "categories"
                    },
                    "unique": false,
                    "nullable": false
                  }
                ],
                "plainFields": [
                  {
                    "name": "title",
                    "type": "string",
                    "description": "Title of the post - Implements the requirement that each post has a headline/subject. Business meaning: summary/subject line visible in post lists and thread views. For example, 'Economic Impact of Inflation in 2025'.",
                    "nullable": false
                  },
                  {
                    "name": "content",
                    "type": "string",
                    "description": "Body content of the post - Implements the rule that posts have main text where users express opinions, share news, analysis, etc. For example, a 400-word analysis of current economic events. Allows rich content or text.",
                    "nullable": false
                  },
                  {
                    "name": "created_at",
                    "type": "datetime",
                    "description": "Creation timestamp - Implements transparency and audit requirements by recording when the post was created. Business use: shows recency in lists, allows moderation tracking.",
                    "nullable": false
                  },
                  {
                    "name": "updated_at",
                    "type": "datetime",
                    "description": "Last edited timestamp - Allows tracking of post edits for evidence/history. Enforces business constraint of allowing users to edit posts within the permitted window. For example, updated_at is changed when a user fixes a typo.",
                    "nullable": false
                  },
                  {
                    "name": "deleted_at",
                    "type": "datetime",
                    "description": "Soft deletion timestamp - Implements moderation rules (see Moderation and User Roles). Posts are not hard deleted but marked with this field if removed for rule violations or by user request. For example, moderators mark spam here for audit/history.",
                    "nullable": true
                  }
                ],
                "uniqueIndexes": [],
                "plainIndexes": [
                  {
                    "fieldNames": [
                      "category_id",
                      "created_at"
                    ]
                  },
                  {
                    "fieldNames": [
                      "user_id",
                      "created_at"
                    ]
                  },
                  {
                    "fieldNames": [
                      "created_at"
                    ]
                  }
                ],
                "ginIndexes": [
                  {
                    "fieldName": "title"
                  },
                  {
                    "fieldName": "content"
                  }
                ]
              },
              {
                "name": "comments",
                "description": "Comment entity - This implements the 'Comment' entity from the requirements (see Data Structure and Business Rules section 1, and Example Scenario).\n\nRepresents replies to posts or other comments, allowing for nested conversations and community discussion. For example, a user comments on a post about inflation, or replies to another comment with their opinion.\n\nKey relationships: Each comment is written by a user and is attached either directly to a post or as a nested reply to another comment. Each comment can have multiple votes. Replies form a hierarchy.\nSpecial behaviors: Only registered users can comment. Comments may be deleted/edited by their author within constraints. Vote tally supports surfacing relevant replies. Threaded (self-referential) relations supported.",
                "material": false,
                "primaryField": {
                  "name": "id",
                  "type": "uuid",
                  "description": "Primary Key. Unique identifier for each comment."
                },
                "foreignFields": [
                  {
                    "name": "user_id",
                    "type": "uuid",
                    "description": "Author's {@link users.id} - Indicates the owner/author of the comment. Enforces accountability, links to profile and reputation system. Required for audit and moderation.",
                    "relation": {
                      "name": "author",
                      "targetModel": "users"
                    },
                    "unique": false,
                    "nullable": false
                  },
                  {
                    "name": "post_id",
                    "type": "uuid",
                    "description": "Parent post's {@link posts.id} - The post that this comment is in response to. Implements the association between comments and discussions. Required unless it's a reply to another comment only.",
                    "relation": {
                      "name": "post",
                      "targetModel": "posts"
                    },
                    "unique": false,
                    "nullable": false
                  },
                  {
                    "name": "parent_id",
                    "type": "uuid",
                    "description": "Parent comment's {@link comments.id} - Implements threaded/nested replies, allowing for comment hierarchies. Enables conversations to branch. Nullable for top-level comments (direct responses to posts).",
                    "relation": {
                      "name": "parent",
                      "targetModel": "comments"
                    },
                    "unique": false,
                    "nullable": true
                  }
                ],
                "plainFields": [
                  {
                    "name": "content",
                    "type": "string",
                    "description": "Comment body - Implements the rule that each comment consists of user-written text/content. Used for replies, opinions, and ongoing discussion. For example, 'I agree and here’s why...'.",
                    "nullable": false
                  },
                  {
                    "name": "created_at",
                    "type": "datetime",
                    "description": "Creation timestamp - Implements audit/history requirement for comment posting, tracking the date and time for moderation and display ordering. For example, enables 'most recent first' sorting.",
                    "nullable": false
                  },
                  {
                    "name": "updated_at",
                    "type": "datetime",
                    "description": "Last edited timestamp - Implements edit history tracking for evidence and transparency. If a user updates their comment, this records when.",
                    "nullable": false
                  },
                  {
                    "name": "deleted_at",
                    "type": "datetime",
                    "description": "Soft deletion timestamp - Implements moderation controls by marking comments removed (not hard deleted) for evidence/history. Used if comment violates rules, is self-removed, or by moderator action.",
                    "nullable": true
                  }
                ],
                "uniqueIndexes": [],
                "plainIndexes": [
                  {
                    "fieldNames": [
                      "post_id",
                      "created_at"
                    ]
                  },
                  {
                    "fieldNames": [
                      "user_id",
                      "created_at"
                    ]
                  },
                  {
                    "fieldNames": [
                      "parent_id",
                      "created_at"
                    ]
                  }
                ],
                "ginIndexes": [
                  {
                    "fieldName": "content"
                  }
                ]
              }
            ]
          },
          {
            "filename": "schema-03-votes.prisma",
            "namespace": "Votes",
            "models": [
              {
                "name": "votes",
                "description": "Vote records - This implements the voting/feedback requirements section described in the requirements analysis, enabling users to provide positive or negative feedback on posts and comments in the discussion board. \n\nBusiness purpose: Allows users to upvote or downvote content, surfacing high-quality posts and comments, while discouraging low-quality contributions. Only registered users can cast votes and only one vote per content item per user is allowed, enforcing fairness and preventing manipulation. Used to calculate real-time content ranking and trust metrics.\n\nKey relationships: Votes always belong to a user and point to either a post or a comment. The voted target is mutually exclusive: each row references either a post or a comment, but never both. \n\nSpecial behaviors: Unique constraint ensures one vote per user per post or comment. Cascade deletion if the user or voted content is removed, to maintain data integrity.",
                "material": false,
                "primaryField": {
                  "name": "id",
                  "type": "uuid",
                  "description": "Primary Key. Unique identifier for each vote record."
                },
                "foreignFields": [
                  {
                    "name": "user_id",
                    "type": "uuid",
                    "description": "Voter's user reference - Links each vote to the user who cast it. Implements the requirement that only registered users can vote. Business meaning: Tracks voting history and enforces unique voting constraints. Example: User 'U' upvotes a comment, linking the vote to 'U's user_id.",
                    "relation": {
                      "name": "user",
                      "targetModel": "users"
                    },
                    "unique": false,
                    "nullable": false
                  },
                  {
                    "name": "post_id",
                    "type": "uuid",
                    "description": "Target post's reference - References the post being voted on, if the vote relates to a post (and not a comment). Implements mutual exclusivity rule and enables vote tallies for posts. Example: Voting on a thread increases the tally on the referenced post. Constraint: Only one of post_id or comment_id is non-null per row.",
                    "relation": {
                      "name": "post",
                      "targetModel": "posts"
                    },
                    "unique": false,
                    "nullable": true
                  },
                  {
                    "name": "comment_id",
                    "type": "uuid",
                    "description": "Target comment's reference - References the comment being voted on, if applicable. Implements mutual exclusivity rule as with posts. Example: Voting on a reply records the vote linked to this comment. Only one of post_id or comment_id is set per vote record.",
                    "relation": {
                      "name": "comment",
                      "targetModel": "comments"
                    },
                    "unique": false,
                    "nullable": true
                  }
                ],
                "plainFields": [
                  {
                    "name": "value",
                    "type": "int",
                    "description": "Vote value - Implements the upvote/downvote requirement. Stores +1 for upvote, -1 for downvote. Business meaning: This value is aggregated to produce content rankings. Example: A +1 value indicates an upvote from a user.",
                    "nullable": false
                  },
                  {
                    "name": "created_at",
                    "type": "datetime",
                    "description": "Vote timestamp - Implements auditing requirements for vote tracking. Stores the date and time the vote was made. Used for analytics and to enforce time-based voting limits, if ever required by policy.",
                    "nullable": false
                  }
                ],
                "uniqueIndexes": [
                  {
                    "fieldNames": [
                      "user_id",
                      "post_id"
                    ],
                    "unique": true
                  },
                  {
                    "fieldNames": [
                      "user_id",
                      "comment_id"
                    ],
                    "unique": true
                  }
                ],
                "plainIndexes": [
                  {
                    "fieldNames": [
                      "post_id",
                      "created_at"
                    ]
                  },
                  {
                    "fieldNames": [
                      "comment_id",
                      "created_at"
                    ]
                  }
                ],
                "ginIndexes": []
              }
            ]
          }
        ]
      }
    },
    "schemas": {
      "schema-01-core.prisma": "/// User information - This implements the 'User' entity from the requirements analysis document (03_data_structure_and_business_rules.md). \n///\n/// Represents registered members of the discussion board. Each user record holds public profile data and permissions (role and status). For example, Alice with email alice@email.com can be a regular user, moderator, or admin.\n///\n/// Key relationships: references user_roles for permission, and relates to posts, comments, and votes they create.\n/// Special behaviors: emails are unique; passwords are stored securely; role assignment required.\n///\n/// @namespace Core\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel users {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. \n  /// Unique identifier for each user.\n  id String @id @db.Uuid\n  \n  /// Role of the user. Target model's {@link user_roles.id}.\n  /// Determines user permissions such as regular member, moderator, or administrator.\n  user_role_id String @db.Uuid\n  \n  /// Username visible on the platform - Implements profile display requirement. Must be unique and public. For example, 'politicoFan88'.\n  username String\n  \n  /// User's email address - Used for login and notifications. Must be unique. For example, 'user@example.com'.\n  email String\n  \n  /// Optional short biography - Lets users share info about themselves. For example, 'Economics student, debate enthusiast.'\n  bio String?\n  \n  /// Hashed password - Implements security requirement. Stores a hashed version of the user password for authentication. Example: long hash string. Not public.\n  password_hash String\n  \n  /// Account creation timestamp - Implements auditability. For example, '2024-06-09T10:00:00+09:00'.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp of last profile update - Implements history/auth traceability. For example, '2024-07-01T12:30:00+09:00'.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Account status - Implements moderation/authentication rules. For example, 'active', 'suspended', or 'banned'.\n  status String\n  \n  //----\n  // RELATIONS\n  //----\n  role user_roles @relation(fields: [user_role_id], references: [id], onDelete: Cascade)\n  \n  posts posts[]\n  comments comments[]\n  votes votes[]\n  \n  @@index([user_role_id])\n  \n  @@unique([username])\n  @@unique([email])\n  @@index([created_at])\n}\n\n/// User role definitions - This implements the role structure outlined in user roles section of the requirements analysis document (02_key_features_and_user_roles.md).\n///\n/// Defines different permissions and capabilities for users. For example, 'member', 'moderator', 'administrator'.\n///\n/// Key relationships: referenced by users table; no direct link to posts or comments.\n/// Special behaviors: role 'name' must be unique.\n///\n/// @namespace Core\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel user_roles {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for user role.\n  id String @id @db.Uuid\n  \n  /// Role label - Implements user roles requirement. Example: 'member', 'moderator', 'administrator'. Must be unique.\n  name String\n  \n  /// Role description - Gives context about permissions and duties; e.g., 'Can moderate comments and suspend users' for moderators.\n  description String\n  \n  //----\n  // RELATIONS\n  //----\n  users users[]\n  \n  @@unique([name])\n}\n\n/// Discussion categories - This covers the 'Category' entity from the requirements document (03_data_structure_and_business_rules.md).\n///\n/// Represents the main topic divisions organizing posts. For example, 'Politics', 'Economics', 'International Affairs'.\n///\n/// Key relationships: referenced by posts; managed by administrators.\n/// Special behaviors: unique name required, can be suggested by users but created by admin.\n///\n/// @namespace Core\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel categories {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for category.\n  id String @id @db.Uuid\n  \n  /// Category name - Implements content organization and navigation requirement. For example, 'Politics'. Must be unique per category.\n  name String\n  \n  /// Category description - Explains scope. For example, 'Discussion about domestic and international political systems, governance, and related events.'\n  description String\n  \n  /// Timestamp when the category was added - Implements audit trail. Example: '2024-06-09T09:00:00+09:00'.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  posts posts[]\n  \n  @@unique([name])\n  @@index([created_at])\n}",
      "schema-02-posts.prisma": "/// Post entity - This implements the 'Post' entity from the requirements document (see Data Structure and Business Rules, section 1, and Example Scenario). \n///\n/// Represents discussion topics or articles submitted by users. Provides a core construct to enable users to initiate threads, share analysis, and start community debates. For example, a user posts a discussion about inflation in the 'Economics' category. \n///\n/// Key relationships: Each post belongs to one user (author) and one category. Each post can have many comments and votes. \n/// Special behaviors: A post must be assigned to a category, may be edited/deleted by its author, and is visible to all users. Vote tally and creation metadata are key for surfacing relevant content.\n///\n/// @namespace Posts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel posts {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for each post.\n  id String @id @db.Uuid\n  \n  /// Author's {@link users.id} - Links each post to its authoring user account. Enforces the association between posts and registered users. Required for accountability and profile-related features.\n  user_id String @db.Uuid\n  \n  /// Category's {@link categories.id} - Associates the post with a topic/category, used for board structure and navigation. Enforces the requirement that every post has a topical context.\n  category_id String @db.Uuid\n  \n  /// Title of the post - Implements the requirement that each post has a headline/subject. Business meaning: summary/subject line visible in post lists and thread views. For example, 'Economic Impact of Inflation in 2025'.\n  title String\n  \n  /// Body content of the post - Implements the rule that posts have main text where users express opinions, share news, analysis, etc. For example, a 400-word analysis of current economic events. Allows rich content or text.\n  content String\n  \n  /// Creation timestamp - Implements transparency and audit requirements by recording when the post was created. Business use: shows recency in lists, allows moderation tracking.\n  created_at DateTime @db.Timestamptz\n  \n  /// Last edited timestamp - Allows tracking of post edits for evidence/history. Enforces business constraint of allowing users to edit posts within the permitted window. For example, updated_at is changed when a user fixes a typo.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Soft deletion timestamp - Implements moderation rules (see Moderation and User Roles). Posts are not hard deleted but marked with this field if removed for rule violations or by user request. For example, moderators mark spam here for audit/history.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  author users @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  category categories @relation(fields: [category_id], references: [id], onDelete: Cascade)\n  \n  comments comments[]\n  votes votes[]\n  \n  @@index([category_id, created_at])\n  @@index([user_id, created_at])\n  @@index([created_at])\n  @@index([title(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Comment entity - This implements the 'Comment' entity from the requirements (see Data Structure and Business Rules section 1, and Example Scenario).\n///\n/// Represents replies to posts or other comments, allowing for nested conversations and community discussion. For example, a user comments on a post about inflation, or replies to another comment with their opinion.\n///\n/// Key relationships: Each comment is written by a user and is attached either directly to a post or as a nested reply to another comment. Each comment can have multiple votes. Replies form a hierarchy.\n/// Special behaviors: Only registered users can comment. Comments may be deleted/edited by their author within constraints. Vote tally supports surfacing relevant replies. Threaded (self-referential) relations supported.\n///\n/// @namespace Posts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel comments {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for each comment.\n  id String @id @db.Uuid\n  \n  /// Author's {@link users.id} - Indicates the owner/author of the comment. Enforces accountability, links to profile and reputation system. Required for audit and moderation.\n  user_id String @db.Uuid\n  \n  /// Parent post's {@link posts.id} - The post that this comment is in response to. Implements the association between comments and discussions. Required unless it's a reply to another comment only.\n  post_id String @db.Uuid\n  \n  /// Parent comment's {@link comments.id} - Implements threaded/nested replies, allowing for comment hierarchies. Enables conversations to branch. Nullable for top-level comments (direct responses to posts).\n  parent_id String? @db.Uuid\n  \n  /// Comment body - Implements the rule that each comment consists of user-written text/content. Used for replies, opinions, and ongoing discussion. For example, 'I agree and here’s why...'.\n  content String\n  \n  /// Creation timestamp - Implements audit/history requirement for comment posting, tracking the date and time for moderation and display ordering. For example, enables 'most recent first' sorting.\n  created_at DateTime @db.Timestamptz\n  \n  /// Last edited timestamp - Implements edit history tracking for evidence and transparency. If a user updates their comment, this records when.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Soft deletion timestamp - Implements moderation controls by marking comments removed (not hard deleted) for evidence/history. Used if comment violates rules, is self-removed, or by moderator action.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  author users @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  post posts @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  parent comments? @relation(\"recursive\", fields: [parent_id], references: [id], onDelete: Cascade)\n  \n  recursive comments[] @relation(\"recursive\")\n  votes votes[]\n  \n  @@index([post_id, created_at])\n  @@index([user_id, created_at])\n  @@index([parent_id, created_at])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}",
      "schema-03-votes.prisma": "/// Vote records - This implements the voting/feedback requirements section described in the requirements analysis, enabling users to provide positive or negative feedback on posts and comments in the discussion board. \n///\n/// Business purpose: Allows users to upvote or downvote content, surfacing high-quality posts and comments, while discouraging low-quality contributions. Only registered users can cast votes and only one vote per content item per user is allowed, enforcing fairness and preventing manipulation. Used to calculate real-time content ranking and trust metrics.\n///\n/// Key relationships: Votes always belong to a user and point to either a post or a comment. The voted target is mutually exclusive: each row references either a post or a comment, but never both. \n///\n/// Special behaviors: Unique constraint ensures one vote per user per post or comment. Cascade deletion if the user or voted content is removed, to maintain data integrity.\n///\n/// @namespace Votes\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel votes {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for each vote record.\n  id String @id @db.Uuid\n  \n  /// Voter's user reference - Links each vote to the user who cast it. Implements the requirement that only registered users can vote. Business meaning: Tracks voting history and enforces unique voting constraints. Example: User 'U' upvotes a comment, linking the vote to 'U's user_id.\n  user_id String @db.Uuid\n  \n  /// Target post's reference - References the post being voted on, if the vote relates to a post (and not a comment). Implements mutual exclusivity rule and enables vote tallies for posts. Example: Voting on a thread increases the tally on the referenced post. Constraint: Only one of post_id or comment_id is non-null per row.\n  post_id String? @db.Uuid\n  \n  /// Target comment's reference - References the comment being voted on, if applicable. Implements mutual exclusivity rule as with posts. Example: Voting on a reply records the vote linked to this comment. Only one of post_id or comment_id is set per vote record.\n  comment_id String? @db.Uuid\n  \n  /// Vote value - Implements the upvote/downvote requirement. Stores +1 for upvote, -1 for downvote. Business meaning: This value is aggregated to produce content rankings. Example: A +1 value indicates an upvote from a user.\n  value Int @db.Integer\n  \n  /// Vote timestamp - Implements auditing requirements for vote tracking. Stores the date and time the vote was made. Used for analytics and to enforce time-based voting limits, if ever required by policy.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  user users @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  post posts? @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  comment comments? @relation(fields: [comment_id], references: [id], onDelete: Cascade)\n  \n  @@unique([user_id, post_id])\n  @@unique([user_id, comment_id])\n  @@index([post_id, created_at])\n  @@index([comment_id, created_at])\n}",
      "main.prisma": "generator client {\n  provider        = \"prisma-client-js\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n  binaryTargets   = [\"native\"]\n}\n\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = []\n}\n\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../docs/ERD.md\"\n}"
    },
    "compiled": {
      "type": "success",
      "schemas": {
        "schema-01-core.prisma": "/// User information - This implements the 'User' entity from the requirements analysis document (03_data_structure_and_business_rules.md). \n///\n/// Represents registered members of the discussion board. Each user record holds public profile data and permissions (role and status). For example, Alice with email alice@email.com can be a regular user, moderator, or admin.\n///\n/// Key relationships: references user_roles for permission, and relates to posts, comments, and votes they create.\n/// Special behaviors: emails are unique; passwords are stored securely; role assignment required.\n///\n/// @namespace Core\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel users {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. \n  /// Unique identifier for each user.\n  id String @id @db.Uuid\n\n  /// Role of the user. Target model's {@link user_roles.id}.\n  /// Determines user permissions such as regular member, moderator, or administrator.\n  user_role_id String @db.Uuid\n\n  /// Username visible on the platform - Implements profile display requirement. Must be unique and public. For example, 'politicoFan88'.\n  username String\n\n  /// User's email address - Used for login and notifications. Must be unique. For example, 'user@example.com'.\n  email String\n\n  /// Optional short biography - Lets users share info about themselves. For example, 'Economics student, debate enthusiast.'\n  bio String?\n\n  /// Hashed password - Implements security requirement. Stores a hashed version of the user password for authentication. Example: long hash string. Not public.\n  password_hash String\n\n  /// Account creation timestamp - Implements auditability. For example, '2024-06-09T10:00:00+09:00'.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp of last profile update - Implements history/auth traceability. For example, '2024-07-01T12:30:00+09:00'.\n  updated_at DateTime @db.Timestamptz\n\n  /// Account status - Implements moderation/authentication rules. For example, 'active', 'suspended', or 'banned'.\n  status String\n\n  //----\n  // RELATIONS\n  //----\n  role user_roles @relation(fields: [user_role_id], references: [id], onDelete: Cascade)\n\n  posts    posts[]\n  comments comments[]\n  votes    votes[]\n\n  @@unique([username])\n  @@unique([email])\n  @@index([user_role_id])\n  @@index([created_at])\n}\n\n/// User role definitions - This implements the role structure outlined in user roles section of the requirements analysis document (02_key_features_and_user_roles.md).\n///\n/// Defines different permissions and capabilities for users. For example, 'member', 'moderator', 'administrator'.\n///\n/// Key relationships: referenced by users table; no direct link to posts or comments.\n/// Special behaviors: role 'name' must be unique.\n///\n/// @namespace Core\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel user_roles {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for user role.\n  id String @id @db.Uuid\n\n  /// Role label - Implements user roles requirement. Example: 'member', 'moderator', 'administrator'. Must be unique.\n  name String\n\n  /// Role description - Gives context about permissions and duties; e.g., 'Can moderate comments and suspend users' for moderators.\n  description String\n\n  //----\n  // RELATIONS\n  //----\n  users users[]\n\n  @@unique([name])\n}\n\n/// Discussion categories - This covers the 'Category' entity from the requirements document (03_data_structure_and_business_rules.md).\n///\n/// Represents the main topic divisions organizing posts. For example, 'Politics', 'Economics', 'International Affairs'.\n///\n/// Key relationships: referenced by posts; managed by administrators.\n/// Special behaviors: unique name required, can be suggested by users but created by admin.\n///\n/// @namespace Core\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel categories {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for category.\n  id String @id @db.Uuid\n\n  /// Category name - Implements content organization and navigation requirement. For example, 'Politics'. Must be unique per category.\n  name String\n\n  /// Category description - Explains scope. For example, 'Discussion about domestic and international political systems, governance, and related events.'\n  description String\n\n  /// Timestamp when the category was added - Implements audit trail. Example: '2024-06-09T09:00:00+09:00'.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  posts posts[]\n\n  @@unique([name])\n  @@index([created_at])\n}\n",
        "schema-02-posts.prisma": "/// Post entity - This implements the 'Post' entity from the requirements document (see Data Structure and Business Rules, section 1, and Example Scenario). \n///\n/// Represents discussion topics or articles submitted by users. Provides a core construct to enable users to initiate threads, share analysis, and start community debates. For example, a user posts a discussion about inflation in the 'Economics' category. \n///\n/// Key relationships: Each post belongs to one user (author) and one category. Each post can have many comments and votes. \n/// Special behaviors: A post must be assigned to a category, may be edited/deleted by its author, and is visible to all users. Vote tally and creation metadata are key for surfacing relevant content.\n///\n/// @namespace Posts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel posts {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for each post.\n  id String @id @db.Uuid\n\n  /// Author's {@link users.id} - Links each post to its authoring user account. Enforces the association between posts and registered users. Required for accountability and profile-related features.\n  user_id String @db.Uuid\n\n  /// Category's {@link categories.id} - Associates the post with a topic/category, used for board structure and navigation. Enforces the requirement that every post has a topical context.\n  category_id String @db.Uuid\n\n  /// Title of the post - Implements the requirement that each post has a headline/subject. Business meaning: summary/subject line visible in post lists and thread views. For example, 'Economic Impact of Inflation in 2025'.\n  title String\n\n  /// Body content of the post - Implements the rule that posts have main text where users express opinions, share news, analysis, etc. For example, a 400-word analysis of current economic events. Allows rich content or text.\n  content String\n\n  /// Creation timestamp - Implements transparency and audit requirements by recording when the post was created. Business use: shows recency in lists, allows moderation tracking.\n  created_at DateTime @db.Timestamptz\n\n  /// Last edited timestamp - Allows tracking of post edits for evidence/history. Enforces business constraint of allowing users to edit posts within the permitted window. For example, updated_at is changed when a user fixes a typo.\n  updated_at DateTime @db.Timestamptz\n\n  /// Soft deletion timestamp - Implements moderation rules (see Moderation and User Roles). Posts are not hard deleted but marked with this field if removed for rule violations or by user request. For example, moderators mark spam here for audit/history.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  author   users      @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  category categories @relation(fields: [category_id], references: [id], onDelete: Cascade)\n\n  comments comments[]\n  votes    votes[]\n\n  @@index([category_id, created_at])\n  @@index([user_id, created_at])\n  @@index([created_at])\n  @@index([title(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n\n/// Comment entity - This implements the 'Comment' entity from the requirements (see Data Structure and Business Rules section 1, and Example Scenario).\n///\n/// Represents replies to posts or other comments, allowing for nested conversations and community discussion. For example, a user comments on a post about inflation, or replies to another comment with their opinion.\n///\n/// Key relationships: Each comment is written by a user and is attached either directly to a post or as a nested reply to another comment. Each comment can have multiple votes. Replies form a hierarchy.\n/// Special behaviors: Only registered users can comment. Comments may be deleted/edited by their author within constraints. Vote tally supports surfacing relevant replies. Threaded (self-referential) relations supported.\n///\n/// @namespace Posts\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel comments {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for each comment.\n  id String @id @db.Uuid\n\n  /// Author's {@link users.id} - Indicates the owner/author of the comment. Enforces accountability, links to profile and reputation system. Required for audit and moderation.\n  user_id String @db.Uuid\n\n  /// Parent post's {@link posts.id} - The post that this comment is in response to. Implements the association between comments and discussions. Required unless it's a reply to another comment only.\n  post_id String @db.Uuid\n\n  /// Parent comment's {@link comments.id} - Implements threaded/nested replies, allowing for comment hierarchies. Enables conversations to branch. Nullable for top-level comments (direct responses to posts).\n  parent_id String? @db.Uuid\n\n  /// Comment body - Implements the rule that each comment consists of user-written text/content. Used for replies, opinions, and ongoing discussion. For example, 'I agree and here’s why...'.\n  content String\n\n  /// Creation timestamp - Implements audit/history requirement for comment posting, tracking the date and time for moderation and display ordering. For example, enables 'most recent first' sorting.\n  created_at DateTime @db.Timestamptz\n\n  /// Last edited timestamp - Implements edit history tracking for evidence and transparency. If a user updates their comment, this records when.\n  updated_at DateTime @db.Timestamptz\n\n  /// Soft deletion timestamp - Implements moderation controls by marking comments removed (not hard deleted) for evidence/history. Used if comment violates rules, is self-removed, or by moderator action.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  author users     @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  post   posts     @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  parent comments? @relation(\"recursive\", fields: [parent_id], references: [id], onDelete: Cascade)\n\n  recursive comments[] @relation(\"recursive\")\n  votes     votes[]\n\n  @@index([post_id, created_at])\n  @@index([user_id, created_at])\n  @@index([parent_id, created_at])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n",
        "schema-03-votes.prisma": "/// Vote records - This implements the voting/feedback requirements section described in the requirements analysis, enabling users to provide positive or negative feedback on posts and comments in the discussion board. \n///\n/// Business purpose: Allows users to upvote or downvote content, surfacing high-quality posts and comments, while discouraging low-quality contributions. Only registered users can cast votes and only one vote per content item per user is allowed, enforcing fairness and preventing manipulation. Used to calculate real-time content ranking and trust metrics.\n///\n/// Key relationships: Votes always belong to a user and point to either a post or a comment. The voted target is mutually exclusive: each row references either a post or a comment, but never both. \n///\n/// Special behaviors: Unique constraint ensures one vote per user per post or comment. Cascade deletion if the user or voted content is removed, to maintain data integrity.\n///\n/// @namespace Votes\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel votes {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key. Unique identifier for each vote record.\n  id String @id @db.Uuid\n\n  /// Voter's user reference - Links each vote to the user who cast it. Implements the requirement that only registered users can vote. Business meaning: Tracks voting history and enforces unique voting constraints. Example: User 'U' upvotes a comment, linking the vote to 'U's user_id.\n  user_id String @db.Uuid\n\n  /// Target post's reference - References the post being voted on, if the vote relates to a post (and not a comment). Implements mutual exclusivity rule and enables vote tallies for posts. Example: Voting on a thread increases the tally on the referenced post. Constraint: Only one of post_id or comment_id is non-null per row.\n  post_id String? @db.Uuid\n\n  /// Target comment's reference - References the comment being voted on, if applicable. Implements mutual exclusivity rule as with posts. Example: Voting on a reply records the vote linked to this comment. Only one of post_id or comment_id is set per vote record.\n  comment_id String? @db.Uuid\n\n  /// Vote value - Implements the upvote/downvote requirement. Stores +1 for upvote, -1 for downvote. Business meaning: This value is aggregated to produce content rankings. Example: A +1 value indicates an upvote from a user.\n  value Int @db.Integer\n\n  /// Vote timestamp - Implements auditing requirements for vote tracking. Stores the date and time the vote was made. Used for analytics and to enforce time-based voting limits, if ever required by policy.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  user    users     @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  post    posts?    @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  comment comments? @relation(fields: [comment_id], references: [id], onDelete: Cascade)\n\n  @@unique([user_id, post_id])\n  @@unique([user_id, comment_id])\n  @@index([post_id, created_at])\n  @@index([comment_id, created_at])\n}\n",
        "main.prisma": "generator client {\n  provider        = \"prisma-client-js\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n  binaryTargets   = [\"native\"]\n}\n\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = []\n}\n\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../docs/ERD.md\"\n}\n"
      },
      "nodeModules": {
        "node_modules/.prisma/client/client.d.ts": "export * from \"./index\"",
        "node_modules/.prisma/client/default.d.ts": "export * from \"./index\"",
        "node_modules/.prisma/client/edge.d.ts": "export * from \"./default\"",
        "node_modules/.prisma/client/index.d.ts": "\n/**\n * Client\n**/\n\nimport * as runtime from './runtime/library.js';\nimport $Types = runtime.Types // general types\nimport $Public = runtime.Types.Public\nimport $Utils = runtime.Types.Utils\nimport $Extensions = runtime.Types.Extensions\nimport $Result = runtime.Types.Result\n\nexport type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n\n/**\n * Model users\n * User information - This implements the 'User' entity from the requirements analysis document (03_data_structure_and_business_rules.md). \n * \n * Represents registered members of the discussion board. Each user record holds public profile data and permissions (role and status). For example, Alice with email alice@email.com can be a regular user, moderator, or admin.\n * \n * Key relationships: references user_roles for permission, and relates to posts, comments, and votes they create.\n * Special behaviors: emails are unique; passwords are stored securely; role assignment required.\n * \n * @namespace Core\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type users = $Result.DefaultSelection<Prisma.$usersPayload>\n/**\n * Model user_roles\n * User role definitions - This implements the role structure outlined in user roles section of the requirements analysis document (02_key_features_and_user_roles.md).\n * \n * Defines different permissions and capabilities for users. For example, 'member', 'moderator', 'administrator'.\n * \n * Key relationships: referenced by users table; no direct link to posts or comments.\n * Special behaviors: role 'name' must be unique.\n * \n * @namespace Core\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type user_roles = $Result.DefaultSelection<Prisma.$user_rolesPayload>\n/**\n * Model categories\n * Discussion categories - This covers the 'Category' entity from the requirements document (03_data_structure_and_business_rules.md).\n * \n * Represents the main topic divisions organizing posts. For example, 'Politics', 'Economics', 'International Affairs'.\n * \n * Key relationships: referenced by posts; managed by administrators.\n * Special behaviors: unique name required, can be suggested by users but created by admin.\n * \n * @namespace Core\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type categories = $Result.DefaultSelection<Prisma.$categoriesPayload>\n/**\n * Model posts\n * Post entity - This implements the 'Post' entity from the requirements document (see Data Structure and Business Rules, section 1, and Example Scenario). \n * \n * Represents discussion topics or articles submitted by users. Provides a core construct to enable users to initiate threads, share analysis, and start community debates. For example, a user posts a discussion about inflation in the 'Economics' category. \n * \n * Key relationships: Each post belongs to one user (author) and one category. Each post can have many comments and votes. \n * Special behaviors: A post must be assigned to a category, may be edited/deleted by its author, and is visible to all users. Vote tally and creation metadata are key for surfacing relevant content.\n * \n * @namespace Posts\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type posts = $Result.DefaultSelection<Prisma.$postsPayload>\n/**\n * Model comments\n * Comment entity - This implements the 'Comment' entity from the requirements (see Data Structure and Business Rules section 1, and Example Scenario).\n * \n * Represents replies to posts or other comments, allowing for nested conversations and community discussion. For example, a user comments on a post about inflation, or replies to another comment with their opinion.\n * \n * Key relationships: Each comment is written by a user and is attached either directly to a post or as a nested reply to another comment. Each comment can have multiple votes. Replies form a hierarchy.\n * Special behaviors: Only registered users can comment. Comments may be deleted/edited by their author within constraints. Vote tally supports surfacing relevant replies. Threaded (self-referential) relations supported.\n * \n * @namespace Posts\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type comments = $Result.DefaultSelection<Prisma.$commentsPayload>\n/**\n * Model votes\n * Vote records - This implements the voting/feedback requirements section described in the requirements analysis, enabling users to provide positive or negative feedback on posts and comments in the discussion board. \n * \n * Business purpose: Allows users to upvote or downvote content, surfacing high-quality posts and comments, while discouraging low-quality contributions. Only registered users can cast votes and only one vote per content item per user is allowed, enforcing fairness and preventing manipulation. Used to calculate real-time content ranking and trust metrics.\n * \n * Key relationships: Votes always belong to a user and point to either a post or a comment. The voted target is mutually exclusive: each row references either a post or a comment, but never both. \n * \n * Special behaviors: Unique constraint ensures one vote per user per post or comment. Cascade deletion if the user or voted content is removed, to maintain data integrity.\n * \n * @namespace Votes\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type votes = $Result.DefaultSelection<Prisma.$votesPayload>\n\n/**\n * ##  Prisma Client ʲˢ\n *\n * Type-safe database client for TypeScript & Node.js\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Users\n * const users = await prisma.users.findMany()\n * ```\n *\n *\n * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n */\nexport class PrismaClient<\n  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,\n  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n    /**\n   * ##  Prisma Client ʲˢ\n   *\n   * Type-safe database client for TypeScript & Node.js\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Users\n   * const users = await prisma.users.findMany()\n   * ```\n   *\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n   */\n\n  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);\n  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): $Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): $Utils.JsPromise<void>;\n\n  /**\n   * Add a middleware\n   * @deprecated since 4.16.0. For new code, prefer client extensions instead.\n   * @see https://pris.ly/d/extensions\n   */\n  $use(cb: Prisma.Middleware): void\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>\n\n\n  $extends: $Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.users`: Exposes CRUD operations for the **users** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Users\n    * const users = await prisma.users.findMany()\n    * ```\n    */\n  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.user_roles`: Exposes CRUD operations for the **user_roles** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more User_roles\n    * const user_roles = await prisma.user_roles.findMany()\n    * ```\n    */\n  get user_roles(): Prisma.user_rolesDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.categories`: Exposes CRUD operations for the **categories** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Categories\n    * const categories = await prisma.categories.findMany()\n    * ```\n    */\n  get categories(): Prisma.categoriesDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.posts`: Exposes CRUD operations for the **posts** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Posts\n    * const posts = await prisma.posts.findMany()\n    * ```\n    */\n  get posts(): Prisma.postsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.comments`: Exposes CRUD operations for the **comments** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Comments\n    * const comments = await prisma.comments.findMany()\n    * ```\n    */\n  get comments(): Prisma.commentsDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.votes`: Exposes CRUD operations for the **votes** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Votes\n    * const votes = await prisma.votes.findMany()\n    * ```\n    */\n  get votes(): Prisma.votesDelegate<ExtArgs, ClientOptions>;\n}\n\nexport namespace Prisma {\n  export import DMMF = runtime.DMMF\n\n  export type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n  /**\n   * Validator\n   */\n  export import validator = runtime.Public.validator\n\n  /**\n   * Prisma Errors\n   */\n  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError\n  export import PrismaClientValidationError = runtime.PrismaClientValidationError\n\n  /**\n   * Re-export of sql-template-tag\n   */\n  export import sql = runtime.sqltag\n  export import empty = runtime.empty\n  export import join = runtime.join\n  export import raw = runtime.raw\n  export import Sql = runtime.Sql\n\n\n\n  /**\n   * Decimal.js\n   */\n  export import Decimal = runtime.Decimal\n\n  export type DecimalJsLike = runtime.DecimalJsLike\n\n  /**\n   * Metrics\n   */\n  export type Metrics = runtime.Metrics\n  export type Metric<T> = runtime.Metric<T>\n  export type MetricHistogram = runtime.MetricHistogram\n  export type MetricHistogramBucket = runtime.MetricHistogramBucket\n\n  /**\n  * Extensions\n  */\n  export import Extension = $Extensions.UserArgs\n  export import getExtensionContext = runtime.Extensions.getExtensionContext\n  export import Args = $Public.Args\n  export import Payload = $Public.Payload\n  export import Result = $Public.Result\n  export import Exact = $Public.Exact\n\n  /**\n   * Prisma Client JS version: local\n   * Query Engine version: local\n   */\n  export type PrismaVersion = {\n    client: string\n  }\n\n  export const prismaVersion: PrismaVersion\n\n  /**\n   * Utility Types\n   */\n\n\n  export import JsonObject = runtime.JsonObject\n  export import JsonArray = runtime.JsonArray\n  export import JsonValue = runtime.JsonValue\n  export import InputJsonObject = runtime.InputJsonObject\n  export import InputJsonArray = runtime.InputJsonArray\n  export import InputJsonValue = runtime.InputJsonValue\n\n  /**\n   * Types of the values used to represent different kinds of `null` values when working with JSON fields.\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  namespace NullTypes {\n    /**\n    * Type of `Prisma.DbNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class DbNull {\n      private DbNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.JsonNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class JsonNull {\n      private JsonNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.AnyNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class AnyNull {\n      private AnyNull: never\n      private constructor()\n    }\n  }\n\n  /**\n   * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const DbNull: NullTypes.DbNull\n\n  /**\n   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const JsonNull: NullTypes.JsonNull\n\n  /**\n   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const AnyNull: NullTypes.AnyNull\n\n  type SelectAndInclude = {\n    select: any\n    include: any\n  }\n\n  type SelectAndOmit = {\n    select: any\n    omit: any\n  }\n\n  /**\n   * Get the type of the value, that the Promise holds.\n   */\n  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;\n\n  /**\n   * Get the return type of a function which returns a Promise.\n   */\n  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>\n\n  /**\n   * From T, pick a set of properties whose keys are in the union K\n   */\n  type Prisma__Pick<T, K extends keyof T> = {\n      [P in K]: T[P];\n  };\n\n\n  export type Enumerable<T> = T | Array<T>;\n\n  export type RequiredKeys<T> = {\n    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K\n  }[keyof T]\n\n  export type TruthyKeys<T> = keyof {\n    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K\n  }\n\n  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>\n\n  /**\n   * Subset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n   */\n  export type Subset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never;\n  };\n\n  /**\n   * SelectSubset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n   * Additionally, it validates, if both select and include are present. If the case, it errors.\n   */\n  export type SelectSubset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    (T extends SelectAndInclude\n      ? 'Please either choose `select` or `include`.'\n      : T extends SelectAndOmit\n        ? 'Please either choose `select` or `omit`.'\n        : {})\n\n  /**\n   * Subset + Intersection\n   * @desc From `T` pick properties that exist in `U` and intersect `K`\n   */\n  export type SubsetIntersection<T, U, K> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    K\n\n  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n  /**\n   * XOR is needed to have a real mutually exclusive union type\n   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n   */\n  type XOR<T, U> =\n    T extends object ?\n    U extends object ?\n      (Without<T, U> & U) | (Without<U, T> & T)\n    : U : T\n\n\n  /**\n   * Is T a Record?\n   */\n  type IsObject<T extends any> = T extends Array<any>\n  ? False\n  : T extends Date\n  ? False\n  : T extends Uint8Array\n  ? False\n  : T extends BigInt\n  ? False\n  : T extends object\n  ? True\n  : False\n\n\n  /**\n   * If it's T[], return T\n   */\n  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n  /**\n   * From ts-toolbelt\n   */\n\n  type __Either<O extends object, K extends Key> = Omit<O, K> &\n    {\n      // Merge all but K\n      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n    }[K]\n\n  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\n  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\n  type _Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean\n  > = {\n    1: EitherStrict<O, K>\n    0: EitherLoose<O, K>\n  }[strict]\n\n  type Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean = 1\n  > = O extends unknown ? _Either<O, K, strict> : never\n\n  export type Union = any\n\n  type PatchUndefined<O extends object, O1 extends object> = {\n    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n  } & {}\n\n  /** Helper Types for \"Merge\" **/\n  export type IntersectOf<U extends Union> = (\n    U extends unknown ? (k: U) => void : never\n  ) extends (k: infer I) => void\n    ? I\n    : never\n\n  export type Overwrite<O extends object, O1 extends object> = {\n      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n  } & {};\n\n  type _Merge<U extends object> = IntersectOf<Overwrite<U, {\n      [K in keyof U]-?: At<U, K>;\n  }>>;\n\n  type Key = string | number | symbol;\n  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;\n  type AtStrict<O extends object, K extends Key> = O[K & keyof O];\n  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\n  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n      1: AtStrict<O, K>;\n      0: AtLoose<O, K>;\n  }[strict];\n\n  export type ComputeRaw<A extends any> = A extends Function ? A : {\n    [K in keyof A]: A[K];\n  } & {};\n\n  export type OptionalFlat<O> = {\n    [K in keyof O]?: O[K];\n  } & {};\n\n  type _Record<K extends keyof any, T> = {\n    [P in K]: T;\n  };\n\n  // cause typescript not to expand types and preserve names\n  type NoExpand<T> = T extends unknown ? T : never;\n\n  // this type assumes the passed object is entirely optional\n  type AtLeast<O extends object, K extends string> = NoExpand<\n    O extends unknown\n    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n    : never>;\n\n  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\n  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n  /** End Helper Types for \"Merge\" **/\n\n  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\n  /**\n  A [[Boolean]]\n  */\n  export type Boolean = True | False\n\n  // /**\n  // 1\n  // */\n  export type True = 1\n\n  /**\n  0\n  */\n  export type False = 0\n\n  export type Not<B extends Boolean> = {\n    0: 1\n    1: 0\n  }[B]\n\n  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n    ? 0 // anything `never` is false\n    : A1 extends A2\n    ? 1\n    : 0\n\n  export type Has<U extends Union, U1 extends Union> = Not<\n    Extends<Exclude<U1, U>, U1>\n  >\n\n  export type Or<B1 extends Boolean, B2 extends Boolean> = {\n    0: {\n      0: 0\n      1: 1\n    }\n    1: {\n      0: 1\n      1: 1\n    }\n  }[B1][B2]\n\n  export type Keys<U extends Union> = U extends unknown ? keyof U : never\n\n  type Cast<A, B> = A extends B ? A : B;\n\n  export const type: unique symbol;\n\n\n\n  /**\n   * Used by group by\n   */\n\n  export type GetScalarType<T, O> = O extends object ? {\n    [P in keyof T]: P extends keyof O\n      ? O[P]\n      : never\n  } : never\n\n  type FieldPaths<\n    T,\n    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n  > = IsObject<T> extends True ? U : T\n\n  type GetHavingFields<T> = {\n    [K in keyof T]: Or<\n      Or<Extends<'OR', K>, Extends<'AND', K>>,\n      Extends<'NOT', K>\n    > extends True\n      ? // infer is only needed to not hit TS limit\n        // based on the brilliant idea of Pierre-Antoine Mills\n        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n        T[K] extends infer TK\n        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n        : never\n      : {} extends FieldPaths<T[K]>\n      ? never\n      : K\n  }[keyof T]\n\n  /**\n   * Convert tuple to union\n   */\n  type _TupleToUnion<T> = T extends (infer E)[] ? E : never\n  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\n  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n  /**\n   * Like `Pick`, but additionally can also accept an array of keys\n   */\n  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n  /**\n   * Exclude all keys with underscores\n   */\n  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\n  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\n  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\n  export const ModelName: {\n    users: 'users',\n    user_roles: 'user_roles',\n    categories: 'categories',\n    posts: 'posts',\n    comments: 'comments',\n    votes: 'votes'\n  };\n\n  export type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n  export type Datasources = {\n    db?: Datasource\n  }\n\n  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {\n    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>\n  }\n\n  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n    globalOmitOptions: {\n      omit: GlobalOmitOptions\n    }\n    meta: {\n      modelProps: \"users\" | \"user_roles\" | \"categories\" | \"posts\" | \"comments\" | \"votes\"\n      txIsolationLevel: Prisma.TransactionIsolationLevel\n    }\n    model: {\n      users: {\n        payload: Prisma.$usersPayload<ExtArgs>\n        fields: Prisma.usersFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.usersFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>\n          }\n          findFirst: {\n            args: Prisma.usersFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>\n          }\n          findMany: {\n            args: Prisma.usersFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]\n          }\n          create: {\n            args: Prisma.usersCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>\n          }\n          createMany: {\n            args: Prisma.usersCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]\n          }\n          delete: {\n            args: Prisma.usersDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>\n          }\n          update: {\n            args: Prisma.usersUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>\n          }\n          deleteMany: {\n            args: Prisma.usersDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.usersUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]\n          }\n          upsert: {\n            args: Prisma.usersUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$usersPayload>\n          }\n          aggregate: {\n            args: Prisma.UsersAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateUsers>\n          }\n          groupBy: {\n            args: Prisma.usersGroupByArgs<ExtArgs>\n            result: $Utils.Optional<UsersGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.usersCountArgs<ExtArgs>\n            result: $Utils.Optional<UsersCountAggregateOutputType> | number\n          }\n        }\n      }\n      user_roles: {\n        payload: Prisma.$user_rolesPayload<ExtArgs>\n        fields: Prisma.user_rolesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.user_rolesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.user_rolesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>\n          }\n          findFirst: {\n            args: Prisma.user_rolesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.user_rolesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>\n          }\n          findMany: {\n            args: Prisma.user_rolesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]\n          }\n          create: {\n            args: Prisma.user_rolesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>\n          }\n          createMany: {\n            args: Prisma.user_rolesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.user_rolesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]\n          }\n          delete: {\n            args: Prisma.user_rolesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>\n          }\n          update: {\n            args: Prisma.user_rolesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>\n          }\n          deleteMany: {\n            args: Prisma.user_rolesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.user_rolesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.user_rolesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]\n          }\n          upsert: {\n            args: Prisma.user_rolesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>\n          }\n          aggregate: {\n            args: Prisma.User_rolesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateUser_roles>\n          }\n          groupBy: {\n            args: Prisma.user_rolesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<User_rolesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.user_rolesCountArgs<ExtArgs>\n            result: $Utils.Optional<User_rolesCountAggregateOutputType> | number\n          }\n        }\n      }\n      categories: {\n        payload: Prisma.$categoriesPayload<ExtArgs>\n        fields: Prisma.categoriesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.categoriesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.categoriesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>\n          }\n          findFirst: {\n            args: Prisma.categoriesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.categoriesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>\n          }\n          findMany: {\n            args: Prisma.categoriesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]\n          }\n          create: {\n            args: Prisma.categoriesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>\n          }\n          createMany: {\n            args: Prisma.categoriesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.categoriesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]\n          }\n          delete: {\n            args: Prisma.categoriesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>\n          }\n          update: {\n            args: Prisma.categoriesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>\n          }\n          deleteMany: {\n            args: Prisma.categoriesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.categoriesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.categoriesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]\n          }\n          upsert: {\n            args: Prisma.categoriesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>\n          }\n          aggregate: {\n            args: Prisma.CategoriesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateCategories>\n          }\n          groupBy: {\n            args: Prisma.categoriesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<CategoriesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.categoriesCountArgs<ExtArgs>\n            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number\n          }\n        }\n      }\n      posts: {\n        payload: Prisma.$postsPayload<ExtArgs>\n        fields: Prisma.postsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.postsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.postsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>\n          }\n          findFirst: {\n            args: Prisma.postsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.postsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>\n          }\n          findMany: {\n            args: Prisma.postsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>[]\n          }\n          create: {\n            args: Prisma.postsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>\n          }\n          createMany: {\n            args: Prisma.postsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.postsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>[]\n          }\n          delete: {\n            args: Prisma.postsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>\n          }\n          update: {\n            args: Prisma.postsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>\n          }\n          deleteMany: {\n            args: Prisma.postsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.postsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.postsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>[]\n          }\n          upsert: {\n            args: Prisma.postsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$postsPayload>\n          }\n          aggregate: {\n            args: Prisma.PostsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregatePosts>\n          }\n          groupBy: {\n            args: Prisma.postsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<PostsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.postsCountArgs<ExtArgs>\n            result: $Utils.Optional<PostsCountAggregateOutputType> | number\n          }\n        }\n      }\n      comments: {\n        payload: Prisma.$commentsPayload<ExtArgs>\n        fields: Prisma.commentsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.commentsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.commentsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>\n          }\n          findFirst: {\n            args: Prisma.commentsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.commentsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>\n          }\n          findMany: {\n            args: Prisma.commentsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]\n          }\n          create: {\n            args: Prisma.commentsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>\n          }\n          createMany: {\n            args: Prisma.commentsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.commentsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]\n          }\n          delete: {\n            args: Prisma.commentsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>\n          }\n          update: {\n            args: Prisma.commentsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>\n          }\n          deleteMany: {\n            args: Prisma.commentsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.commentsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.commentsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]\n          }\n          upsert: {\n            args: Prisma.commentsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$commentsPayload>\n          }\n          aggregate: {\n            args: Prisma.CommentsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateComments>\n          }\n          groupBy: {\n            args: Prisma.commentsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<CommentsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.commentsCountArgs<ExtArgs>\n            result: $Utils.Optional<CommentsCountAggregateOutputType> | number\n          }\n        }\n      }\n      votes: {\n        payload: Prisma.$votesPayload<ExtArgs>\n        fields: Prisma.votesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.votesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.votesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>\n          }\n          findFirst: {\n            args: Prisma.votesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.votesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>\n          }\n          findMany: {\n            args: Prisma.votesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>[]\n          }\n          create: {\n            args: Prisma.votesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>\n          }\n          createMany: {\n            args: Prisma.votesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.votesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>[]\n          }\n          delete: {\n            args: Prisma.votesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>\n          }\n          update: {\n            args: Prisma.votesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>\n          }\n          deleteMany: {\n            args: Prisma.votesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.votesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.votesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>[]\n          }\n          upsert: {\n            args: Prisma.votesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$votesPayload>\n          }\n          aggregate: {\n            args: Prisma.VotesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateVotes>\n          }\n          groupBy: {\n            args: Prisma.votesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<VotesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.votesCountArgs<ExtArgs>\n            result: $Utils.Optional<VotesCountAggregateOutputType> | number\n          }\n        }\n      }\n    }\n  } & {\n    other: {\n      payload: any\n      operations: {\n        $executeRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $executeRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n        $queryRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $queryRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n      }\n    }\n  }\n  export const defineExtension: $Extensions.ExtendsHook<\"define\", Prisma.TypeMapCb, $Extensions.DefaultArgs>\n  export type DefaultPrismaClient = PrismaClient\n  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n  export interface PrismaClientOptions {\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasources?: Datasources\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasourceUrl?: string\n    /**\n     * @default \"colorless\"\n     */\n    errorFormat?: ErrorFormat\n    /**\n     * @example\n     * ```\n     * // Defaults to stdout\n     * log: ['query', 'info', 'warn', 'error']\n     * \n     * // Emit as events\n     * log: [\n     *   { emit: 'stdout', level: 'query' },\n     *   { emit: 'stdout', level: 'info' },\n     *   { emit: 'stdout', level: 'warn' }\n     *   { emit: 'stdout', level: 'error' }\n     * ]\n     * ```\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n     */\n    log?: (LogLevel | LogDefinition)[]\n    /**\n     * The default values for transactionOptions\n     * maxWait ?= 2000\n     * timeout ?= 5000\n     */\n    transactionOptions?: {\n      maxWait?: number\n      timeout?: number\n      isolationLevel?: Prisma.TransactionIsolationLevel\n    }\n    /**\n     * Global configuration for omitting model fields by default.\n     * \n     * @example\n     * ```\n     * const prisma = new PrismaClient({\n     *   omit: {\n     *     user: {\n     *       password: true\n     *     }\n     *   }\n     * })\n     * ```\n     */\n    omit?: Prisma.GlobalOmitConfig\n  }\n  export type GlobalOmitConfig = {\n    users?: usersOmit\n    user_roles?: user_rolesOmit\n    categories?: categoriesOmit\n    posts?: postsOmit\n    comments?: commentsOmit\n    votes?: votesOmit\n  }\n\n  /* Types for Logging */\n  export type LogLevel = 'info' | 'query' | 'warn' | 'error'\n  export type LogDefinition = {\n    level: LogLevel\n    emit: 'stdout' | 'event'\n  }\n\n  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never\n  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?\n    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>\n    : never\n\n  export type QueryEvent = {\n    timestamp: Date\n    query: string\n    params: string\n    duration: number\n    target: string\n  }\n\n  export type LogEvent = {\n    timestamp: Date\n    message: string\n    target: string\n  }\n  /* End Types for Logging */\n\n\n  export type PrismaAction =\n    | 'findUnique'\n    | 'findUniqueOrThrow'\n    | 'findMany'\n    | 'findFirst'\n    | 'findFirstOrThrow'\n    | 'create'\n    | 'createMany'\n    | 'createManyAndReturn'\n    | 'update'\n    | 'updateMany'\n    | 'updateManyAndReturn'\n    | 'upsert'\n    | 'delete'\n    | 'deleteMany'\n    | 'executeRaw'\n    | 'queryRaw'\n    | 'aggregate'\n    | 'count'\n    | 'runCommandRaw'\n    | 'findRaw'\n    | 'groupBy'\n\n  /**\n   * These options are being passed into the middleware as \"params\"\n   */\n  export type MiddlewareParams = {\n    model?: ModelName\n    action: PrismaAction\n    args: any\n    dataPath: string[]\n    runInTransaction: boolean\n  }\n\n  /**\n   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n   */\n  export type Middleware<T = any> = (\n    params: MiddlewareParams,\n    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,\n  ) => $Utils.JsPromise<T>\n\n  // tested in getLogLevel.test.ts\n  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;\n\n  /**\n   * `PrismaClient` proxy available in interactive transactions.\n   */\n  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>\n\n  export type Datasource = {\n    url?: string\n  }\n\n  /**\n   * Count Types\n   */\n\n\n  /**\n   * Count Type UsersCountOutputType\n   */\n\n  export type UsersCountOutputType = {\n    posts: number\n    comments: number\n    votes: number\n  }\n\n  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    posts?: boolean | UsersCountOutputTypeCountPostsArgs\n    comments?: boolean | UsersCountOutputTypeCountCommentsArgs\n    votes?: boolean | UsersCountOutputTypeCountVotesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * UsersCountOutputType without action\n   */\n  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the UsersCountOutputType\n     */\n    select?: UsersCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * UsersCountOutputType without action\n   */\n  export type UsersCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: postsWhereInput\n  }\n\n  /**\n   * UsersCountOutputType without action\n   */\n  export type UsersCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: commentsWhereInput\n  }\n\n  /**\n   * UsersCountOutputType without action\n   */\n  export type UsersCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: votesWhereInput\n  }\n\n\n  /**\n   * Count Type User_rolesCountOutputType\n   */\n\n  export type User_rolesCountOutputType = {\n    users: number\n  }\n\n  export type User_rolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    users?: boolean | User_rolesCountOutputTypeCountUsersArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * User_rolesCountOutputType without action\n   */\n  export type User_rolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the User_rolesCountOutputType\n     */\n    select?: User_rolesCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * User_rolesCountOutputType without action\n   */\n  export type User_rolesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: usersWhereInput\n  }\n\n\n  /**\n   * Count Type CategoriesCountOutputType\n   */\n\n  export type CategoriesCountOutputType = {\n    posts: number\n  }\n\n  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    posts?: boolean | CategoriesCountOutputTypeCountPostsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * CategoriesCountOutputType without action\n   */\n  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the CategoriesCountOutputType\n     */\n    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * CategoriesCountOutputType without action\n   */\n  export type CategoriesCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: postsWhereInput\n  }\n\n\n  /**\n   * Count Type PostsCountOutputType\n   */\n\n  export type PostsCountOutputType = {\n    comments: number\n    votes: number\n  }\n\n  export type PostsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    comments?: boolean | PostsCountOutputTypeCountCommentsArgs\n    votes?: boolean | PostsCountOutputTypeCountVotesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * PostsCountOutputType without action\n   */\n  export type PostsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the PostsCountOutputType\n     */\n    select?: PostsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * PostsCountOutputType without action\n   */\n  export type PostsCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: commentsWhereInput\n  }\n\n  /**\n   * PostsCountOutputType without action\n   */\n  export type PostsCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: votesWhereInput\n  }\n\n\n  /**\n   * Count Type CommentsCountOutputType\n   */\n\n  export type CommentsCountOutputType = {\n    recursive: number\n    votes: number\n  }\n\n  export type CommentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    recursive?: boolean | CommentsCountOutputTypeCountRecursiveArgs\n    votes?: boolean | CommentsCountOutputTypeCountVotesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * CommentsCountOutputType without action\n   */\n  export type CommentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the CommentsCountOutputType\n     */\n    select?: CommentsCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * CommentsCountOutputType without action\n   */\n  export type CommentsCountOutputTypeCountRecursiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: commentsWhereInput\n  }\n\n  /**\n   * CommentsCountOutputType without action\n   */\n  export type CommentsCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: votesWhereInput\n  }\n\n\n  /**\n   * Models\n   */\n\n  /**\n   * Model users\n   */\n\n  export type AggregateUsers = {\n    _count: UsersCountAggregateOutputType | null\n    _min: UsersMinAggregateOutputType | null\n    _max: UsersMaxAggregateOutputType | null\n  }\n\n  export type UsersMinAggregateOutputType = {\n    id: string | null\n    user_role_id: string | null\n    username: string | null\n    email: string | null\n    bio: string | null\n    password_hash: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    status: string | null\n  }\n\n  export type UsersMaxAggregateOutputType = {\n    id: string | null\n    user_role_id: string | null\n    username: string | null\n    email: string | null\n    bio: string | null\n    password_hash: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    status: string | null\n  }\n\n  export type UsersCountAggregateOutputType = {\n    id: number\n    user_role_id: number\n    username: number\n    email: number\n    bio: number\n    password_hash: number\n    created_at: number\n    updated_at: number\n    status: number\n    _all: number\n  }\n\n\n  export type UsersMinAggregateInputType = {\n    id?: true\n    user_role_id?: true\n    username?: true\n    email?: true\n    bio?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n    status?: true\n  }\n\n  export type UsersMaxAggregateInputType = {\n    id?: true\n    user_role_id?: true\n    username?: true\n    email?: true\n    bio?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n    status?: true\n  }\n\n  export type UsersCountAggregateInputType = {\n    id?: true\n    user_role_id?: true\n    username?: true\n    email?: true\n    bio?: true\n    password_hash?: true\n    created_at?: true\n    updated_at?: true\n    status?: true\n    _all?: true\n  }\n\n  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which users to aggregate.\n     */\n    where?: usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of users to fetch.\n     */\n    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned users\n    **/\n    _count?: true | UsersCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: UsersMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: UsersMaxAggregateInputType\n  }\n\n  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {\n        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateUsers[P]>\n      : GetScalarType<T[P], AggregateUsers[P]>\n  }\n\n\n\n\n  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: usersWhereInput\n    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]\n    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum\n    having?: usersScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: UsersCountAggregateInputType | true\n    _min?: UsersMinAggregateInputType\n    _max?: UsersMaxAggregateInputType\n  }\n\n  export type UsersGroupByOutputType = {\n    id: string\n    user_role_id: string\n    username: string\n    email: string\n    bio: string | null\n    password_hash: string\n    created_at: Date\n    updated_at: Date\n    status: string\n    _count: UsersCountAggregateOutputType | null\n    _min: UsersMinAggregateOutputType | null\n    _max: UsersMaxAggregateOutputType | null\n  }\n\n  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<UsersGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], UsersGroupByOutputType[P]>\n            : GetScalarType<T[P], UsersGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_role_id?: boolean\n    username?: boolean\n    email?: boolean\n    bio?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    status?: boolean\n    role?: boolean | user_rolesDefaultArgs<ExtArgs>\n    posts?: boolean | users$postsArgs<ExtArgs>\n    comments?: boolean | users$commentsArgs<ExtArgs>\n    votes?: boolean | users$votesArgs<ExtArgs>\n    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"users\"]>\n\n  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_role_id?: boolean\n    username?: boolean\n    email?: boolean\n    bio?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    status?: boolean\n    role?: boolean | user_rolesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"users\"]>\n\n  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_role_id?: boolean\n    username?: boolean\n    email?: boolean\n    bio?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    status?: boolean\n    role?: boolean | user_rolesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"users\"]>\n\n  export type usersSelectScalar = {\n    id?: boolean\n    user_role_id?: boolean\n    username?: boolean\n    email?: boolean\n    bio?: boolean\n    password_hash?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    status?: boolean\n  }\n\n  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"user_role_id\" | \"username\" | \"email\" | \"bio\" | \"password_hash\" | \"created_at\" | \"updated_at\" | \"status\", ExtArgs[\"result\"][\"users\"]>\n  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    role?: boolean | user_rolesDefaultArgs<ExtArgs>\n    posts?: boolean | users$postsArgs<ExtArgs>\n    comments?: boolean | users$commentsArgs<ExtArgs>\n    votes?: boolean | users$votesArgs<ExtArgs>\n    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    role?: boolean | user_rolesDefaultArgs<ExtArgs>\n  }\n  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    role?: boolean | user_rolesDefaultArgs<ExtArgs>\n  }\n\n  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"users\"\n    objects: {\n      role: Prisma.$user_rolesPayload<ExtArgs>\n      posts: Prisma.$postsPayload<ExtArgs>[]\n      comments: Prisma.$commentsPayload<ExtArgs>[]\n      votes: Prisma.$votesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key. \n       * Unique identifier for each user.\n       */\n      id: string\n      /**\n       * Role of the user. Target model's {@link user_roles.id}.\n       * Determines user permissions such as regular member, moderator, or administrator.\n       */\n      user_role_id: string\n      /**\n       * Username visible on the platform - Implements profile display requirement. Must be unique and public. For example, 'politicoFan88'.\n       */\n      username: string\n      /**\n       * User's email address - Used for login and notifications. Must be unique. For example, 'user@example.com'.\n       */\n      email: string\n      /**\n       * Optional short biography - Lets users share info about themselves. For example, 'Economics student, debate enthusiast.'\n       */\n      bio: string | null\n      /**\n       * Hashed password - Implements security requirement. Stores a hashed version of the user password for authentication. Example: long hash string. Not public.\n       */\n      password_hash: string\n      /**\n       * Account creation timestamp - Implements auditability. For example, '2024-06-09T10:00:00+09:00'.\n       */\n      created_at: Date\n      /**\n       * Timestamp of last profile update - Implements history/auth traceability. For example, '2024-07-01T12:30:00+09:00'.\n       */\n      updated_at: Date\n      /**\n       * Account status - Implements moderation/authentication rules. For example, 'active', 'suspended', or 'banned'.\n       */\n      status: string\n    }, ExtArgs[\"result\"][\"users\"]>\n    composites: {}\n  }\n\n  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>\n\n  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: UsersCountAggregateInputType | true\n    }\n\n  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }\n    /**\n     * Find zero or one Users that matches the filter.\n     * @param {usersFindUniqueArgs} args - Arguments to find a Users\n     * @example\n     * // Get one Users\n     * const users = await prisma.users.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Users that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users\n     * @example\n     * // Get one Users\n     * const users = await prisma.users.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Users that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {usersFindFirstArgs} args - Arguments to find a Users\n     * @example\n     * // Get one Users\n     * const users = await prisma.users.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Users that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users\n     * @example\n     * // Get one Users\n     * const users = await prisma.users.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Users that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Users\n     * const users = await prisma.users.findMany()\n     * \n     * // Get first 10 Users\n     * const users = await prisma.users.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Users.\n     * @param {usersCreateArgs} args - Arguments to create a Users.\n     * @example\n     * // Create one Users\n     * const Users = await prisma.users.create({\n     *   data: {\n     *     // ... data to create a Users\n     *   }\n     * })\n     * \n     */\n    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Users.\n     * @param {usersCreateManyArgs} args - Arguments to create many Users.\n     * @example\n     * // Create many Users\n     * const users = await prisma.users.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Users and returns the data saved in the database.\n     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.\n     * @example\n     * // Create many Users\n     * const users = await prisma.users.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Users and only return the `id`\n     * const usersWithIdOnly = await prisma.users.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Users.\n     * @param {usersDeleteArgs} args - Arguments to delete one Users.\n     * @example\n     * // Delete one Users\n     * const Users = await prisma.users.delete({\n     *   where: {\n     *     // ... filter to delete one Users\n     *   }\n     * })\n     * \n     */\n    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Users.\n     * @param {usersUpdateArgs} args - Arguments to update one Users.\n     * @example\n     * // Update one Users\n     * const users = await prisma.users.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Users.\n     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.\n     * @example\n     * // Delete a few Users\n     * const { count } = await prisma.users.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Users\n     * const users = await prisma.users.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Users and returns the data updated in the database.\n     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.\n     * @example\n     * // Update many Users\n     * const users = await prisma.users.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Users and only return the `id`\n     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Users.\n     * @param {usersUpsertArgs} args - Arguments to update or create a Users.\n     * @example\n     * // Update or create a Users\n     * const users = await prisma.users.upsert({\n     *   create: {\n     *     // ... data to create a Users\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Users we want to update\n     *   }\n     * })\n     */\n    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {usersCountArgs} args - Arguments to filter Users to count.\n     * @example\n     * // Count the number of Users\n     * const count = await prisma.users.count({\n     *   where: {\n     *     // ... the filter for the Users we want to count\n     *   }\n     * })\n    **/\n    count<T extends usersCountArgs>(\n      args?: Subset<T, usersCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], UsersCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>\n\n    /**\n     * Group by Users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {usersGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends usersGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: usersGroupByArgs['orderBy'] }\n        : { orderBy?: usersGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the users model\n   */\n  readonly fields: usersFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for users.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    role<T extends user_rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, user_rolesDefaultArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    posts<T extends users$postsArgs<ExtArgs> = {}>(args?: Subset<T, users$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    comments<T extends users$commentsArgs<ExtArgs> = {}>(args?: Subset<T, users$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    votes<T extends users$votesArgs<ExtArgs> = {}>(args?: Subset<T, users$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the users model\n   */\n  interface usersFieldRefs {\n    readonly id: FieldRef<\"users\", 'String'>\n    readonly user_role_id: FieldRef<\"users\", 'String'>\n    readonly username: FieldRef<\"users\", 'String'>\n    readonly email: FieldRef<\"users\", 'String'>\n    readonly bio: FieldRef<\"users\", 'String'>\n    readonly password_hash: FieldRef<\"users\", 'String'>\n    readonly created_at: FieldRef<\"users\", 'DateTime'>\n    readonly updated_at: FieldRef<\"users\", 'DateTime'>\n    readonly status: FieldRef<\"users\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * users findUnique\n   */\n  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * Filter, which users to fetch.\n     */\n    where: usersWhereUniqueInput\n  }\n\n  /**\n   * users findUniqueOrThrow\n   */\n  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * Filter, which users to fetch.\n     */\n    where: usersWhereUniqueInput\n  }\n\n  /**\n   * users findFirst\n   */\n  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * Filter, which users to fetch.\n     */\n    where?: usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of users to fetch.\n     */\n    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for users.\n     */\n    cursor?: usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of users.\n     */\n    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]\n  }\n\n  /**\n   * users findFirstOrThrow\n   */\n  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * Filter, which users to fetch.\n     */\n    where?: usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of users to fetch.\n     */\n    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for users.\n     */\n    cursor?: usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of users.\n     */\n    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]\n  }\n\n  /**\n   * users findMany\n   */\n  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * Filter, which users to fetch.\n     */\n    where?: usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of users to fetch.\n     */\n    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing users.\n     */\n    cursor?: usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` users.\n     */\n    skip?: number\n    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]\n  }\n\n  /**\n   * users create\n   */\n  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * The data needed to create a users.\n     */\n    data: XOR<usersCreateInput, usersUncheckedCreateInput>\n  }\n\n  /**\n   * users createMany\n   */\n  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many users.\n     */\n    data: usersCreateManyInput | usersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * users createManyAndReturn\n   */\n  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * The data used to create many users.\n     */\n    data: usersCreateManyInput | usersCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * users update\n   */\n  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * The data needed to update a users.\n     */\n    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>\n    /**\n     * Choose, which users to update.\n     */\n    where: usersWhereUniqueInput\n  }\n\n  /**\n   * users updateMany\n   */\n  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update users.\n     */\n    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>\n    /**\n     * Filter which users to update\n     */\n    where?: usersWhereInput\n    /**\n     * Limit how many users to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * users updateManyAndReturn\n   */\n  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * The data used to update users.\n     */\n    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>\n    /**\n     * Filter which users to update\n     */\n    where?: usersWhereInput\n    /**\n     * Limit how many users to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * users upsert\n   */\n  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * The filter to search for the users to update in case it exists.\n     */\n    where: usersWhereUniqueInput\n    /**\n     * In case the users found by the `where` argument doesn't exist, create a new users with this data.\n     */\n    create: XOR<usersCreateInput, usersUncheckedCreateInput>\n    /**\n     * In case the users was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>\n  }\n\n  /**\n   * users delete\n   */\n  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    /**\n     * Filter which users to delete.\n     */\n    where: usersWhereUniqueInput\n  }\n\n  /**\n   * users deleteMany\n   */\n  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which users to delete\n     */\n    where?: usersWhereInput\n    /**\n     * Limit how many users to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * users.posts\n   */\n  export type users$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    where?: postsWhereInput\n    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]\n    cursor?: postsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]\n  }\n\n  /**\n   * users.comments\n   */\n  export type users$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    where?: commentsWhereInput\n    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]\n    cursor?: commentsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]\n  }\n\n  /**\n   * users.votes\n   */\n  export type users$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    where?: votesWhereInput\n    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]\n    cursor?: votesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]\n  }\n\n  /**\n   * users without action\n   */\n  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model user_roles\n   */\n\n  export type AggregateUser_roles = {\n    _count: User_rolesCountAggregateOutputType | null\n    _min: User_rolesMinAggregateOutputType | null\n    _max: User_rolesMaxAggregateOutputType | null\n  }\n\n  export type User_rolesMinAggregateOutputType = {\n    id: string | null\n    name: string | null\n    description: string | null\n  }\n\n  export type User_rolesMaxAggregateOutputType = {\n    id: string | null\n    name: string | null\n    description: string | null\n  }\n\n  export type User_rolesCountAggregateOutputType = {\n    id: number\n    name: number\n    description: number\n    _all: number\n  }\n\n\n  export type User_rolesMinAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n  }\n\n  export type User_rolesMaxAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n  }\n\n  export type User_rolesCountAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    _all?: true\n  }\n\n  export type User_rolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which user_roles to aggregate.\n     */\n    where?: user_rolesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of user_roles to fetch.\n     */\n    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: user_rolesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` user_roles from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` user_roles.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned user_roles\n    **/\n    _count?: true | User_rolesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: User_rolesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: User_rolesMaxAggregateInputType\n  }\n\n  export type GetUser_rolesAggregateType<T extends User_rolesAggregateArgs> = {\n        [P in keyof T & keyof AggregateUser_roles]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateUser_roles[P]>\n      : GetScalarType<T[P], AggregateUser_roles[P]>\n  }\n\n\n\n\n  export type user_rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: user_rolesWhereInput\n    orderBy?: user_rolesOrderByWithAggregationInput | user_rolesOrderByWithAggregationInput[]\n    by: User_rolesScalarFieldEnum[] | User_rolesScalarFieldEnum\n    having?: user_rolesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: User_rolesCountAggregateInputType | true\n    _min?: User_rolesMinAggregateInputType\n    _max?: User_rolesMaxAggregateInputType\n  }\n\n  export type User_rolesGroupByOutputType = {\n    id: string\n    name: string\n    description: string\n    _count: User_rolesCountAggregateOutputType | null\n    _min: User_rolesMinAggregateOutputType | null\n    _max: User_rolesMaxAggregateOutputType | null\n  }\n\n  type GetUser_rolesGroupByPayload<T extends user_rolesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<User_rolesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof User_rolesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], User_rolesGroupByOutputType[P]>\n            : GetScalarType<T[P], User_rolesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type user_rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    users?: boolean | user_roles$usersArgs<ExtArgs>\n    _count?: boolean | User_rolesCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"user_roles\"]>\n\n  export type user_rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n  }, ExtArgs[\"result\"][\"user_roles\"]>\n\n  export type user_rolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n  }, ExtArgs[\"result\"][\"user_roles\"]>\n\n  export type user_rolesSelectScalar = {\n    id?: boolean\n    name?: boolean\n    description?: boolean\n  }\n\n  export type user_rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"name\" | \"description\", ExtArgs[\"result\"][\"user_roles\"]>\n  export type user_rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    users?: boolean | user_roles$usersArgs<ExtArgs>\n    _count?: boolean | User_rolesCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type user_rolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type user_rolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $user_rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"user_roles\"\n    objects: {\n      users: Prisma.$usersPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key. Unique identifier for user role.\n       */\n      id: string\n      /**\n       * Role label - Implements user roles requirement. Example: 'member', 'moderator', 'administrator'. Must be unique.\n       */\n      name: string\n      /**\n       * Role description - Gives context about permissions and duties; e.g., 'Can moderate comments and suspend users' for moderators.\n       */\n      description: string\n    }, ExtArgs[\"result\"][\"user_roles\"]>\n    composites: {}\n  }\n\n  type user_rolesGetPayload<S extends boolean | null | undefined | user_rolesDefaultArgs> = $Result.GetResult<Prisma.$user_rolesPayload, S>\n\n  type user_rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<user_rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: User_rolesCountAggregateInputType | true\n    }\n\n  export interface user_rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_roles'], meta: { name: 'user_roles' } }\n    /**\n     * Find zero or one User_roles that matches the filter.\n     * @param {user_rolesFindUniqueArgs} args - Arguments to find a User_roles\n     * @example\n     * // Get one User_roles\n     * const user_roles = await prisma.user_roles.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends user_rolesFindUniqueArgs>(args: SelectSubset<T, user_rolesFindUniqueArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one User_roles that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {user_rolesFindUniqueOrThrowArgs} args - Arguments to find a User_roles\n     * @example\n     * // Get one User_roles\n     * const user_roles = await prisma.user_roles.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends user_rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, user_rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first User_roles that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {user_rolesFindFirstArgs} args - Arguments to find a User_roles\n     * @example\n     * // Get one User_roles\n     * const user_roles = await prisma.user_roles.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends user_rolesFindFirstArgs>(args?: SelectSubset<T, user_rolesFindFirstArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first User_roles that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {user_rolesFindFirstOrThrowArgs} args - Arguments to find a User_roles\n     * @example\n     * // Get one User_roles\n     * const user_roles = await prisma.user_roles.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends user_rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, user_rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more User_roles that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {user_rolesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all User_roles\n     * const user_roles = await prisma.user_roles.findMany()\n     * \n     * // Get first 10 User_roles\n     * const user_roles = await prisma.user_roles.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const user_rolesWithIdOnly = await prisma.user_roles.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends user_rolesFindManyArgs>(args?: SelectSubset<T, user_rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a User_roles.\n     * @param {user_rolesCreateArgs} args - Arguments to create a User_roles.\n     * @example\n     * // Create one User_roles\n     * const User_roles = await prisma.user_roles.create({\n     *   data: {\n     *     // ... data to create a User_roles\n     *   }\n     * })\n     * \n     */\n    create<T extends user_rolesCreateArgs>(args: SelectSubset<T, user_rolesCreateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many User_roles.\n     * @param {user_rolesCreateManyArgs} args - Arguments to create many User_roles.\n     * @example\n     * // Create many User_roles\n     * const user_roles = await prisma.user_roles.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends user_rolesCreateManyArgs>(args?: SelectSubset<T, user_rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many User_roles and returns the data saved in the database.\n     * @param {user_rolesCreateManyAndReturnArgs} args - Arguments to create many User_roles.\n     * @example\n     * // Create many User_roles\n     * const user_roles = await prisma.user_roles.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many User_roles and only return the `id`\n     * const user_rolesWithIdOnly = await prisma.user_roles.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends user_rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, user_rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a User_roles.\n     * @param {user_rolesDeleteArgs} args - Arguments to delete one User_roles.\n     * @example\n     * // Delete one User_roles\n     * const User_roles = await prisma.user_roles.delete({\n     *   where: {\n     *     // ... filter to delete one User_roles\n     *   }\n     * })\n     * \n     */\n    delete<T extends user_rolesDeleteArgs>(args: SelectSubset<T, user_rolesDeleteArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one User_roles.\n     * @param {user_rolesUpdateArgs} args - Arguments to update one User_roles.\n     * @example\n     * // Update one User_roles\n     * const user_roles = await prisma.user_roles.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends user_rolesUpdateArgs>(args: SelectSubset<T, user_rolesUpdateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more User_roles.\n     * @param {user_rolesDeleteManyArgs} args - Arguments to filter User_roles to delete.\n     * @example\n     * // Delete a few User_roles\n     * const { count } = await prisma.user_roles.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends user_rolesDeleteManyArgs>(args?: SelectSubset<T, user_rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more User_roles.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {user_rolesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many User_roles\n     * const user_roles = await prisma.user_roles.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends user_rolesUpdateManyArgs>(args: SelectSubset<T, user_rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more User_roles and returns the data updated in the database.\n     * @param {user_rolesUpdateManyAndReturnArgs} args - Arguments to update many User_roles.\n     * @example\n     * // Update many User_roles\n     * const user_roles = await prisma.user_roles.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more User_roles and only return the `id`\n     * const user_rolesWithIdOnly = await prisma.user_roles.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends user_rolesUpdateManyAndReturnArgs>(args: SelectSubset<T, user_rolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one User_roles.\n     * @param {user_rolesUpsertArgs} args - Arguments to update or create a User_roles.\n     * @example\n     * // Update or create a User_roles\n     * const user_roles = await prisma.user_roles.upsert({\n     *   create: {\n     *     // ... data to create a User_roles\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the User_roles we want to update\n     *   }\n     * })\n     */\n    upsert<T extends user_rolesUpsertArgs>(args: SelectSubset<T, user_rolesUpsertArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of User_roles.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {user_rolesCountArgs} args - Arguments to filter User_roles to count.\n     * @example\n     * // Count the number of User_roles\n     * const count = await prisma.user_roles.count({\n     *   where: {\n     *     // ... the filter for the User_roles we want to count\n     *   }\n     * })\n    **/\n    count<T extends user_rolesCountArgs>(\n      args?: Subset<T, user_rolesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], User_rolesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a User_roles.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {User_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends User_rolesAggregateArgs>(args: Subset<T, User_rolesAggregateArgs>): Prisma.PrismaPromise<GetUser_rolesAggregateType<T>>\n\n    /**\n     * Group by User_roles.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {user_rolesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends user_rolesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: user_rolesGroupByArgs['orderBy'] }\n        : { orderBy?: user_rolesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, user_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the user_roles model\n   */\n  readonly fields: user_rolesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for user_roles.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__user_rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    users<T extends user_roles$usersArgs<ExtArgs> = {}>(args?: Subset<T, user_roles$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the user_roles model\n   */\n  interface user_rolesFieldRefs {\n    readonly id: FieldRef<\"user_roles\", 'String'>\n    readonly name: FieldRef<\"user_roles\", 'String'>\n    readonly description: FieldRef<\"user_roles\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * user_roles findUnique\n   */\n  export type user_rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * Filter, which user_roles to fetch.\n     */\n    where: user_rolesWhereUniqueInput\n  }\n\n  /**\n   * user_roles findUniqueOrThrow\n   */\n  export type user_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * Filter, which user_roles to fetch.\n     */\n    where: user_rolesWhereUniqueInput\n  }\n\n  /**\n   * user_roles findFirst\n   */\n  export type user_rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * Filter, which user_roles to fetch.\n     */\n    where?: user_rolesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of user_roles to fetch.\n     */\n    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for user_roles.\n     */\n    cursor?: user_rolesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` user_roles from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` user_roles.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of user_roles.\n     */\n    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]\n  }\n\n  /**\n   * user_roles findFirstOrThrow\n   */\n  export type user_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * Filter, which user_roles to fetch.\n     */\n    where?: user_rolesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of user_roles to fetch.\n     */\n    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for user_roles.\n     */\n    cursor?: user_rolesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` user_roles from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` user_roles.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of user_roles.\n     */\n    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]\n  }\n\n  /**\n   * user_roles findMany\n   */\n  export type user_rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * Filter, which user_roles to fetch.\n     */\n    where?: user_rolesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of user_roles to fetch.\n     */\n    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing user_roles.\n     */\n    cursor?: user_rolesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` user_roles from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` user_roles.\n     */\n    skip?: number\n    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]\n  }\n\n  /**\n   * user_roles create\n   */\n  export type user_rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a user_roles.\n     */\n    data: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>\n  }\n\n  /**\n   * user_roles createMany\n   */\n  export type user_rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many user_roles.\n     */\n    data: user_rolesCreateManyInput | user_rolesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * user_roles createManyAndReturn\n   */\n  export type user_rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * The data used to create many user_roles.\n     */\n    data: user_rolesCreateManyInput | user_rolesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * user_roles update\n   */\n  export type user_rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a user_roles.\n     */\n    data: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>\n    /**\n     * Choose, which user_roles to update.\n     */\n    where: user_rolesWhereUniqueInput\n  }\n\n  /**\n   * user_roles updateMany\n   */\n  export type user_rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update user_roles.\n     */\n    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyInput>\n    /**\n     * Filter which user_roles to update\n     */\n    where?: user_rolesWhereInput\n    /**\n     * Limit how many user_roles to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * user_roles updateManyAndReturn\n   */\n  export type user_rolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * The data used to update user_roles.\n     */\n    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyInput>\n    /**\n     * Filter which user_roles to update\n     */\n    where?: user_rolesWhereInput\n    /**\n     * Limit how many user_roles to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * user_roles upsert\n   */\n  export type user_rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the user_roles to update in case it exists.\n     */\n    where: user_rolesWhereUniqueInput\n    /**\n     * In case the user_roles found by the `where` argument doesn't exist, create a new user_roles with this data.\n     */\n    create: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>\n    /**\n     * In case the user_roles was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>\n  }\n\n  /**\n   * user_roles delete\n   */\n  export type user_rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n    /**\n     * Filter which user_roles to delete.\n     */\n    where: user_rolesWhereUniqueInput\n  }\n\n  /**\n   * user_roles deleteMany\n   */\n  export type user_rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which user_roles to delete\n     */\n    where?: user_rolesWhereInput\n    /**\n     * Limit how many user_roles to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * user_roles.users\n   */\n  export type user_roles$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the users\n     */\n    select?: usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the users\n     */\n    omit?: usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: usersInclude<ExtArgs> | null\n    where?: usersWhereInput\n    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]\n    cursor?: usersWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]\n  }\n\n  /**\n   * user_roles without action\n   */\n  export type user_rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the user_roles\n     */\n    select?: user_rolesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the user_roles\n     */\n    omit?: user_rolesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: user_rolesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model categories\n   */\n\n  export type AggregateCategories = {\n    _count: CategoriesCountAggregateOutputType | null\n    _min: CategoriesMinAggregateOutputType | null\n    _max: CategoriesMaxAggregateOutputType | null\n  }\n\n  export type CategoriesMinAggregateOutputType = {\n    id: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n  }\n\n  export type CategoriesMaxAggregateOutputType = {\n    id: string | null\n    name: string | null\n    description: string | null\n    created_at: Date | null\n  }\n\n  export type CategoriesCountAggregateOutputType = {\n    id: number\n    name: number\n    description: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type CategoriesMinAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    created_at?: true\n  }\n\n  export type CategoriesMaxAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    created_at?: true\n  }\n\n  export type CategoriesCountAggregateInputType = {\n    id?: true\n    name?: true\n    description?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which categories to aggregate.\n     */\n    where?: categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of categories to fetch.\n     */\n    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` categories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned categories\n    **/\n    _count?: true | CategoriesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: CategoriesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: CategoriesMaxAggregateInputType\n  }\n\n  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {\n        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateCategories[P]>\n      : GetScalarType<T[P], AggregateCategories[P]>\n  }\n\n\n\n\n  export type categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: categoriesWhereInput\n    orderBy?: categoriesOrderByWithAggregationInput | categoriesOrderByWithAggregationInput[]\n    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum\n    having?: categoriesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: CategoriesCountAggregateInputType | true\n    _min?: CategoriesMinAggregateInputType\n    _max?: CategoriesMaxAggregateInputType\n  }\n\n  export type CategoriesGroupByOutputType = {\n    id: string\n    name: string\n    description: string\n    created_at: Date\n    _count: CategoriesCountAggregateOutputType | null\n    _min: CategoriesMinAggregateOutputType | null\n    _max: CategoriesMaxAggregateOutputType | null\n  }\n\n  type GetCategoriesGroupByPayload<T extends categoriesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<CategoriesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>\n            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n    posts?: boolean | categories$postsArgs<ExtArgs>\n    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"categories\"]>\n\n  export type categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n  }, ExtArgs[\"result\"][\"categories\"]>\n\n  export type categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n  }, ExtArgs[\"result\"][\"categories\"]>\n\n  export type categoriesSelectScalar = {\n    id?: boolean\n    name?: boolean\n    description?: boolean\n    created_at?: boolean\n  }\n\n  export type categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"name\" | \"description\" | \"created_at\", ExtArgs[\"result\"][\"categories\"]>\n  export type categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    posts?: boolean | categories$postsArgs<ExtArgs>\n    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"categories\"\n    objects: {\n      posts: Prisma.$postsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key. Unique identifier for category.\n       */\n      id: string\n      /**\n       * Category name - Implements content organization and navigation requirement. For example, 'Politics'. Must be unique per category.\n       */\n      name: string\n      /**\n       * Category description - Explains scope. For example, 'Discussion about domestic and international political systems, governance, and related events.'\n       */\n      description: string\n      /**\n       * Timestamp when the category was added - Implements audit trail. Example: '2024-06-09T09:00:00+09:00'.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"categories\"]>\n    composites: {}\n  }\n\n  type categoriesGetPayload<S extends boolean | null | undefined | categoriesDefaultArgs> = $Result.GetResult<Prisma.$categoriesPayload, S>\n\n  type categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: CategoriesCountAggregateInputType | true\n    }\n\n  export interface categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categories'], meta: { name: 'categories' } }\n    /**\n     * Find zero or one Categories that matches the filter.\n     * @param {categoriesFindUniqueArgs} args - Arguments to find a Categories\n     * @example\n     * // Get one Categories\n     * const categories = await prisma.categories.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends categoriesFindUniqueArgs>(args: SelectSubset<T, categoriesFindUniqueArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Categories that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {categoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories\n     * @example\n     * // Get one Categories\n     * const categories = await prisma.categories.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Categories that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {categoriesFindFirstArgs} args - Arguments to find a Categories\n     * @example\n     * // Get one Categories\n     * const categories = await prisma.categories.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends categoriesFindFirstArgs>(args?: SelectSubset<T, categoriesFindFirstArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Categories that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {categoriesFindFirstOrThrowArgs} args - Arguments to find a Categories\n     * @example\n     * // Get one Categories\n     * const categories = await prisma.categories.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Categories that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {categoriesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Categories\n     * const categories = await prisma.categories.findMany()\n     * \n     * // Get first 10 Categories\n     * const categories = await prisma.categories.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends categoriesFindManyArgs>(args?: SelectSubset<T, categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Categories.\n     * @param {categoriesCreateArgs} args - Arguments to create a Categories.\n     * @example\n     * // Create one Categories\n     * const Categories = await prisma.categories.create({\n     *   data: {\n     *     // ... data to create a Categories\n     *   }\n     * })\n     * \n     */\n    create<T extends categoriesCreateArgs>(args: SelectSubset<T, categoriesCreateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Categories.\n     * @param {categoriesCreateManyArgs} args - Arguments to create many Categories.\n     * @example\n     * // Create many Categories\n     * const categories = await prisma.categories.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends categoriesCreateManyArgs>(args?: SelectSubset<T, categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Categories and returns the data saved in the database.\n     * @param {categoriesCreateManyAndReturnArgs} args - Arguments to create many Categories.\n     * @example\n     * // Create many Categories\n     * const categories = await prisma.categories.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Categories and only return the `id`\n     * const categoriesWithIdOnly = await prisma.categories.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Categories.\n     * @param {categoriesDeleteArgs} args - Arguments to delete one Categories.\n     * @example\n     * // Delete one Categories\n     * const Categories = await prisma.categories.delete({\n     *   where: {\n     *     // ... filter to delete one Categories\n     *   }\n     * })\n     * \n     */\n    delete<T extends categoriesDeleteArgs>(args: SelectSubset<T, categoriesDeleteArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Categories.\n     * @param {categoriesUpdateArgs} args - Arguments to update one Categories.\n     * @example\n     * // Update one Categories\n     * const categories = await prisma.categories.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends categoriesUpdateArgs>(args: SelectSubset<T, categoriesUpdateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Categories.\n     * @param {categoriesDeleteManyArgs} args - Arguments to filter Categories to delete.\n     * @example\n     * // Delete a few Categories\n     * const { count } = await prisma.categories.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends categoriesDeleteManyArgs>(args?: SelectSubset<T, categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {categoriesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Categories\n     * const categories = await prisma.categories.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends categoriesUpdateManyArgs>(args: SelectSubset<T, categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Categories and returns the data updated in the database.\n     * @param {categoriesUpdateManyAndReturnArgs} args - Arguments to update many Categories.\n     * @example\n     * // Update many Categories\n     * const categories = await prisma.categories.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Categories and only return the `id`\n     * const categoriesWithIdOnly = await prisma.categories.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Categories.\n     * @param {categoriesUpsertArgs} args - Arguments to update or create a Categories.\n     * @example\n     * // Update or create a Categories\n     * const categories = await prisma.categories.upsert({\n     *   create: {\n     *     // ... data to create a Categories\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Categories we want to update\n     *   }\n     * })\n     */\n    upsert<T extends categoriesUpsertArgs>(args: SelectSubset<T, categoriesUpsertArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {categoriesCountArgs} args - Arguments to filter Categories to count.\n     * @example\n     * // Count the number of Categories\n     * const count = await prisma.categories.count({\n     *   where: {\n     *     // ... the filter for the Categories we want to count\n     *   }\n     * })\n    **/\n    count<T extends categoriesCountArgs>(\n      args?: Subset<T, categoriesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>\n\n    /**\n     * Group by Categories.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {categoriesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends categoriesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: categoriesGroupByArgs['orderBy'] }\n        : { orderBy?: categoriesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the categories model\n   */\n  readonly fields: categoriesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for categories.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    posts<T extends categories$postsArgs<ExtArgs> = {}>(args?: Subset<T, categories$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the categories model\n   */\n  interface categoriesFieldRefs {\n    readonly id: FieldRef<\"categories\", 'String'>\n    readonly name: FieldRef<\"categories\", 'String'>\n    readonly description: FieldRef<\"categories\", 'String'>\n    readonly created_at: FieldRef<\"categories\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * categories findUnique\n   */\n  export type categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which categories to fetch.\n     */\n    where: categoriesWhereUniqueInput\n  }\n\n  /**\n   * categories findUniqueOrThrow\n   */\n  export type categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which categories to fetch.\n     */\n    where: categoriesWhereUniqueInput\n  }\n\n  /**\n   * categories findFirst\n   */\n  export type categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which categories to fetch.\n     */\n    where?: categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of categories to fetch.\n     */\n    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for categories.\n     */\n    cursor?: categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` categories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of categories.\n     */\n    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]\n  }\n\n  /**\n   * categories findFirstOrThrow\n   */\n  export type categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which categories to fetch.\n     */\n    where?: categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of categories to fetch.\n     */\n    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for categories.\n     */\n    cursor?: categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` categories.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of categories.\n     */\n    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]\n  }\n\n  /**\n   * categories findMany\n   */\n  export type categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * Filter, which categories to fetch.\n     */\n    where?: categoriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of categories to fetch.\n     */\n    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing categories.\n     */\n    cursor?: categoriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` categories from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` categories.\n     */\n    skip?: number\n    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]\n  }\n\n  /**\n   * categories create\n   */\n  export type categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a categories.\n     */\n    data: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>\n  }\n\n  /**\n   * categories createMany\n   */\n  export type categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many categories.\n     */\n    data: categoriesCreateManyInput | categoriesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * categories createManyAndReturn\n   */\n  export type categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * The data used to create many categories.\n     */\n    data: categoriesCreateManyInput | categoriesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * categories update\n   */\n  export type categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a categories.\n     */\n    data: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>\n    /**\n     * Choose, which categories to update.\n     */\n    where: categoriesWhereUniqueInput\n  }\n\n  /**\n   * categories updateMany\n   */\n  export type categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update categories.\n     */\n    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>\n    /**\n     * Filter which categories to update\n     */\n    where?: categoriesWhereInput\n    /**\n     * Limit how many categories to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * categories updateManyAndReturn\n   */\n  export type categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * The data used to update categories.\n     */\n    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>\n    /**\n     * Filter which categories to update\n     */\n    where?: categoriesWhereInput\n    /**\n     * Limit how many categories to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * categories upsert\n   */\n  export type categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the categories to update in case it exists.\n     */\n    where: categoriesWhereUniqueInput\n    /**\n     * In case the categories found by the `where` argument doesn't exist, create a new categories with this data.\n     */\n    create: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>\n    /**\n     * In case the categories was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>\n  }\n\n  /**\n   * categories delete\n   */\n  export type categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n    /**\n     * Filter which categories to delete.\n     */\n    where: categoriesWhereUniqueInput\n  }\n\n  /**\n   * categories deleteMany\n   */\n  export type categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which categories to delete\n     */\n    where?: categoriesWhereInput\n    /**\n     * Limit how many categories to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * categories.posts\n   */\n  export type categories$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    where?: postsWhereInput\n    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]\n    cursor?: postsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]\n  }\n\n  /**\n   * categories without action\n   */\n  export type categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the categories\n     */\n    select?: categoriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the categories\n     */\n    omit?: categoriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: categoriesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model posts\n   */\n\n  export type AggregatePosts = {\n    _count: PostsCountAggregateOutputType | null\n    _min: PostsMinAggregateOutputType | null\n    _max: PostsMaxAggregateOutputType | null\n  }\n\n  export type PostsMinAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    category_id: string | null\n    title: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type PostsMaxAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    category_id: string | null\n    title: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type PostsCountAggregateOutputType = {\n    id: number\n    user_id: number\n    category_id: number\n    title: number\n    content: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type PostsMinAggregateInputType = {\n    id?: true\n    user_id?: true\n    category_id?: true\n    title?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type PostsMaxAggregateInputType = {\n    id?: true\n    user_id?: true\n    category_id?: true\n    title?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type PostsCountAggregateInputType = {\n    id?: true\n    user_id?: true\n    category_id?: true\n    title?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type PostsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which posts to aggregate.\n     */\n    where?: postsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of posts to fetch.\n     */\n    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: postsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` posts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` posts.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned posts\n    **/\n    _count?: true | PostsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: PostsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: PostsMaxAggregateInputType\n  }\n\n  export type GetPostsAggregateType<T extends PostsAggregateArgs> = {\n        [P in keyof T & keyof AggregatePosts]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregatePosts[P]>\n      : GetScalarType<T[P], AggregatePosts[P]>\n  }\n\n\n\n\n  export type postsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: postsWhereInput\n    orderBy?: postsOrderByWithAggregationInput | postsOrderByWithAggregationInput[]\n    by: PostsScalarFieldEnum[] | PostsScalarFieldEnum\n    having?: postsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: PostsCountAggregateInputType | true\n    _min?: PostsMinAggregateInputType\n    _max?: PostsMaxAggregateInputType\n  }\n\n  export type PostsGroupByOutputType = {\n    id: string\n    user_id: string\n    category_id: string\n    title: string\n    content: string\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: PostsCountAggregateOutputType | null\n    _min: PostsMinAggregateOutputType | null\n    _max: PostsMaxAggregateOutputType | null\n  }\n\n  type GetPostsGroupByPayload<T extends postsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<PostsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof PostsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], PostsGroupByOutputType[P]>\n            : GetScalarType<T[P], PostsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type postsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    category_id?: boolean\n    title?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    category?: boolean | categoriesDefaultArgs<ExtArgs>\n    comments?: boolean | posts$commentsArgs<ExtArgs>\n    votes?: boolean | posts$votesArgs<ExtArgs>\n    _count?: boolean | PostsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"posts\"]>\n\n  export type postsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    category_id?: boolean\n    title?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    category?: boolean | categoriesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"posts\"]>\n\n  export type postsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    category_id?: boolean\n    title?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    category?: boolean | categoriesDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"posts\"]>\n\n  export type postsSelectScalar = {\n    id?: boolean\n    user_id?: boolean\n    category_id?: boolean\n    title?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type postsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"user_id\" | \"category_id\" | \"title\" | \"content\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"posts\"]>\n  export type postsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    category?: boolean | categoriesDefaultArgs<ExtArgs>\n    comments?: boolean | posts$commentsArgs<ExtArgs>\n    votes?: boolean | posts$votesArgs<ExtArgs>\n    _count?: boolean | PostsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type postsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    category?: boolean | categoriesDefaultArgs<ExtArgs>\n  }\n  export type postsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    category?: boolean | categoriesDefaultArgs<ExtArgs>\n  }\n\n  export type $postsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"posts\"\n    objects: {\n      author: Prisma.$usersPayload<ExtArgs>\n      category: Prisma.$categoriesPayload<ExtArgs>\n      comments: Prisma.$commentsPayload<ExtArgs>[]\n      votes: Prisma.$votesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key. Unique identifier for each post.\n       */\n      id: string\n      /**\n       * Author's {@link users.id} - Links each post to its authoring user account. Enforces the association between posts and registered users. Required for accountability and profile-related features.\n       */\n      user_id: string\n      /**\n       * Category's {@link categories.id} - Associates the post with a topic/category, used for board structure and navigation. Enforces the requirement that every post has a topical context.\n       */\n      category_id: string\n      /**\n       * Title of the post - Implements the requirement that each post has a headline/subject. Business meaning: summary/subject line visible in post lists and thread views. For example, 'Economic Impact of Inflation in 2025'.\n       */\n      title: string\n      /**\n       * Body content of the post - Implements the rule that posts have main text where users express opinions, share news, analysis, etc. For example, a 400-word analysis of current economic events. Allows rich content or text.\n       */\n      content: string\n      /**\n       * Creation timestamp - Implements transparency and audit requirements by recording when the post was created. Business use: shows recency in lists, allows moderation tracking.\n       */\n      created_at: Date\n      /**\n       * Last edited timestamp - Allows tracking of post edits for evidence/history. Enforces business constraint of allowing users to edit posts within the permitted window. For example, updated_at is changed when a user fixes a typo.\n       */\n      updated_at: Date\n      /**\n       * Soft deletion timestamp - Implements moderation rules (see Moderation and User Roles). Posts are not hard deleted but marked with this field if removed for rule violations or by user request. For example, moderators mark spam here for audit/history.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"posts\"]>\n    composites: {}\n  }\n\n  type postsGetPayload<S extends boolean | null | undefined | postsDefaultArgs> = $Result.GetResult<Prisma.$postsPayload, S>\n\n  type postsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<postsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: PostsCountAggregateInputType | true\n    }\n\n  export interface postsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['posts'], meta: { name: 'posts' } }\n    /**\n     * Find zero or one Posts that matches the filter.\n     * @param {postsFindUniqueArgs} args - Arguments to find a Posts\n     * @example\n     * // Get one Posts\n     * const posts = await prisma.posts.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends postsFindUniqueArgs>(args: SelectSubset<T, postsFindUniqueArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Posts that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {postsFindUniqueOrThrowArgs} args - Arguments to find a Posts\n     * @example\n     * // Get one Posts\n     * const posts = await prisma.posts.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends postsFindUniqueOrThrowArgs>(args: SelectSubset<T, postsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Posts that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {postsFindFirstArgs} args - Arguments to find a Posts\n     * @example\n     * // Get one Posts\n     * const posts = await prisma.posts.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends postsFindFirstArgs>(args?: SelectSubset<T, postsFindFirstArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Posts that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {postsFindFirstOrThrowArgs} args - Arguments to find a Posts\n     * @example\n     * // Get one Posts\n     * const posts = await prisma.posts.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends postsFindFirstOrThrowArgs>(args?: SelectSubset<T, postsFindFirstOrThrowArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Posts that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {postsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Posts\n     * const posts = await prisma.posts.findMany()\n     * \n     * // Get first 10 Posts\n     * const posts = await prisma.posts.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const postsWithIdOnly = await prisma.posts.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends postsFindManyArgs>(args?: SelectSubset<T, postsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Posts.\n     * @param {postsCreateArgs} args - Arguments to create a Posts.\n     * @example\n     * // Create one Posts\n     * const Posts = await prisma.posts.create({\n     *   data: {\n     *     // ... data to create a Posts\n     *   }\n     * })\n     * \n     */\n    create<T extends postsCreateArgs>(args: SelectSubset<T, postsCreateArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Posts.\n     * @param {postsCreateManyArgs} args - Arguments to create many Posts.\n     * @example\n     * // Create many Posts\n     * const posts = await prisma.posts.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends postsCreateManyArgs>(args?: SelectSubset<T, postsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Posts and returns the data saved in the database.\n     * @param {postsCreateManyAndReturnArgs} args - Arguments to create many Posts.\n     * @example\n     * // Create many Posts\n     * const posts = await prisma.posts.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Posts and only return the `id`\n     * const postsWithIdOnly = await prisma.posts.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends postsCreateManyAndReturnArgs>(args?: SelectSubset<T, postsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Posts.\n     * @param {postsDeleteArgs} args - Arguments to delete one Posts.\n     * @example\n     * // Delete one Posts\n     * const Posts = await prisma.posts.delete({\n     *   where: {\n     *     // ... filter to delete one Posts\n     *   }\n     * })\n     * \n     */\n    delete<T extends postsDeleteArgs>(args: SelectSubset<T, postsDeleteArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Posts.\n     * @param {postsUpdateArgs} args - Arguments to update one Posts.\n     * @example\n     * // Update one Posts\n     * const posts = await prisma.posts.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends postsUpdateArgs>(args: SelectSubset<T, postsUpdateArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Posts.\n     * @param {postsDeleteManyArgs} args - Arguments to filter Posts to delete.\n     * @example\n     * // Delete a few Posts\n     * const { count } = await prisma.posts.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends postsDeleteManyArgs>(args?: SelectSubset<T, postsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Posts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {postsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Posts\n     * const posts = await prisma.posts.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends postsUpdateManyArgs>(args: SelectSubset<T, postsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Posts and returns the data updated in the database.\n     * @param {postsUpdateManyAndReturnArgs} args - Arguments to update many Posts.\n     * @example\n     * // Update many Posts\n     * const posts = await prisma.posts.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Posts and only return the `id`\n     * const postsWithIdOnly = await prisma.posts.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends postsUpdateManyAndReturnArgs>(args: SelectSubset<T, postsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Posts.\n     * @param {postsUpsertArgs} args - Arguments to update or create a Posts.\n     * @example\n     * // Update or create a Posts\n     * const posts = await prisma.posts.upsert({\n     *   create: {\n     *     // ... data to create a Posts\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Posts we want to update\n     *   }\n     * })\n     */\n    upsert<T extends postsUpsertArgs>(args: SelectSubset<T, postsUpsertArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Posts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {postsCountArgs} args - Arguments to filter Posts to count.\n     * @example\n     * // Count the number of Posts\n     * const count = await prisma.posts.count({\n     *   where: {\n     *     // ... the filter for the Posts we want to count\n     *   }\n     * })\n    **/\n    count<T extends postsCountArgs>(\n      args?: Subset<T, postsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], PostsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Posts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {PostsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends PostsAggregateArgs>(args: Subset<T, PostsAggregateArgs>): Prisma.PrismaPromise<GetPostsAggregateType<T>>\n\n    /**\n     * Group by Posts.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {postsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends postsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: postsGroupByArgs['orderBy'] }\n        : { orderBy?: postsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, postsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the posts model\n   */\n  readonly fields: postsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for posts.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__postsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    author<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    category<T extends categoriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoriesDefaultArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    comments<T extends posts$commentsArgs<ExtArgs> = {}>(args?: Subset<T, posts$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    votes<T extends posts$votesArgs<ExtArgs> = {}>(args?: Subset<T, posts$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the posts model\n   */\n  interface postsFieldRefs {\n    readonly id: FieldRef<\"posts\", 'String'>\n    readonly user_id: FieldRef<\"posts\", 'String'>\n    readonly category_id: FieldRef<\"posts\", 'String'>\n    readonly title: FieldRef<\"posts\", 'String'>\n    readonly content: FieldRef<\"posts\", 'String'>\n    readonly created_at: FieldRef<\"posts\", 'DateTime'>\n    readonly updated_at: FieldRef<\"posts\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"posts\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * posts findUnique\n   */\n  export type postsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * Filter, which posts to fetch.\n     */\n    where: postsWhereUniqueInput\n  }\n\n  /**\n   * posts findUniqueOrThrow\n   */\n  export type postsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * Filter, which posts to fetch.\n     */\n    where: postsWhereUniqueInput\n  }\n\n  /**\n   * posts findFirst\n   */\n  export type postsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * Filter, which posts to fetch.\n     */\n    where?: postsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of posts to fetch.\n     */\n    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for posts.\n     */\n    cursor?: postsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` posts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` posts.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of posts.\n     */\n    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]\n  }\n\n  /**\n   * posts findFirstOrThrow\n   */\n  export type postsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * Filter, which posts to fetch.\n     */\n    where?: postsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of posts to fetch.\n     */\n    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for posts.\n     */\n    cursor?: postsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` posts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` posts.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of posts.\n     */\n    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]\n  }\n\n  /**\n   * posts findMany\n   */\n  export type postsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * Filter, which posts to fetch.\n     */\n    where?: postsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of posts to fetch.\n     */\n    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing posts.\n     */\n    cursor?: postsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` posts from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` posts.\n     */\n    skip?: number\n    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]\n  }\n\n  /**\n   * posts create\n   */\n  export type postsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a posts.\n     */\n    data: XOR<postsCreateInput, postsUncheckedCreateInput>\n  }\n\n  /**\n   * posts createMany\n   */\n  export type postsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many posts.\n     */\n    data: postsCreateManyInput | postsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * posts createManyAndReturn\n   */\n  export type postsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * The data used to create many posts.\n     */\n    data: postsCreateManyInput | postsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * posts update\n   */\n  export type postsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a posts.\n     */\n    data: XOR<postsUpdateInput, postsUncheckedUpdateInput>\n    /**\n     * Choose, which posts to update.\n     */\n    where: postsWhereUniqueInput\n  }\n\n  /**\n   * posts updateMany\n   */\n  export type postsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update posts.\n     */\n    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyInput>\n    /**\n     * Filter which posts to update\n     */\n    where?: postsWhereInput\n    /**\n     * Limit how many posts to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * posts updateManyAndReturn\n   */\n  export type postsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * The data used to update posts.\n     */\n    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyInput>\n    /**\n     * Filter which posts to update\n     */\n    where?: postsWhereInput\n    /**\n     * Limit how many posts to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * posts upsert\n   */\n  export type postsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the posts to update in case it exists.\n     */\n    where: postsWhereUniqueInput\n    /**\n     * In case the posts found by the `where` argument doesn't exist, create a new posts with this data.\n     */\n    create: XOR<postsCreateInput, postsUncheckedCreateInput>\n    /**\n     * In case the posts was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<postsUpdateInput, postsUncheckedUpdateInput>\n  }\n\n  /**\n   * posts delete\n   */\n  export type postsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    /**\n     * Filter which posts to delete.\n     */\n    where: postsWhereUniqueInput\n  }\n\n  /**\n   * posts deleteMany\n   */\n  export type postsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which posts to delete\n     */\n    where?: postsWhereInput\n    /**\n     * Limit how many posts to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * posts.comments\n   */\n  export type posts$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    where?: commentsWhereInput\n    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]\n    cursor?: commentsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]\n  }\n\n  /**\n   * posts.votes\n   */\n  export type posts$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    where?: votesWhereInput\n    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]\n    cursor?: votesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]\n  }\n\n  /**\n   * posts without action\n   */\n  export type postsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model comments\n   */\n\n  export type AggregateComments = {\n    _count: CommentsCountAggregateOutputType | null\n    _min: CommentsMinAggregateOutputType | null\n    _max: CommentsMaxAggregateOutputType | null\n  }\n\n  export type CommentsMinAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    post_id: string | null\n    parent_id: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type CommentsMaxAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    post_id: string | null\n    parent_id: string | null\n    content: string | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type CommentsCountAggregateOutputType = {\n    id: number\n    user_id: number\n    post_id: number\n    parent_id: number\n    content: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type CommentsMinAggregateInputType = {\n    id?: true\n    user_id?: true\n    post_id?: true\n    parent_id?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type CommentsMaxAggregateInputType = {\n    id?: true\n    user_id?: true\n    post_id?: true\n    parent_id?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type CommentsCountAggregateInputType = {\n    id?: true\n    user_id?: true\n    post_id?: true\n    parent_id?: true\n    content?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type CommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which comments to aggregate.\n     */\n    where?: commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of comments to fetch.\n     */\n    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` comments.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned comments\n    **/\n    _count?: true | CommentsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: CommentsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: CommentsMaxAggregateInputType\n  }\n\n  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {\n        [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateComments[P]>\n      : GetScalarType<T[P], AggregateComments[P]>\n  }\n\n\n\n\n  export type commentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: commentsWhereInput\n    orderBy?: commentsOrderByWithAggregationInput | commentsOrderByWithAggregationInput[]\n    by: CommentsScalarFieldEnum[] | CommentsScalarFieldEnum\n    having?: commentsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: CommentsCountAggregateInputType | true\n    _min?: CommentsMinAggregateInputType\n    _max?: CommentsMaxAggregateInputType\n  }\n\n  export type CommentsGroupByOutputType = {\n    id: string\n    user_id: string\n    post_id: string\n    parent_id: string | null\n    content: string\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: CommentsCountAggregateOutputType | null\n    _min: CommentsMinAggregateOutputType | null\n    _max: CommentsMaxAggregateOutputType | null\n  }\n\n  type GetCommentsGroupByPayload<T extends commentsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<CommentsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof CommentsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], CommentsGroupByOutputType[P]>\n            : GetScalarType<T[P], CommentsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type commentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    parent_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | postsDefaultArgs<ExtArgs>\n    parent?: boolean | comments$parentArgs<ExtArgs>\n    recursive?: boolean | comments$recursiveArgs<ExtArgs>\n    votes?: boolean | comments$votesArgs<ExtArgs>\n    _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"comments\"]>\n\n  export type commentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    parent_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | postsDefaultArgs<ExtArgs>\n    parent?: boolean | comments$parentArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"comments\"]>\n\n  export type commentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    parent_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | postsDefaultArgs<ExtArgs>\n    parent?: boolean | comments$parentArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"comments\"]>\n\n  export type commentsSelectScalar = {\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    parent_id?: boolean\n    content?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type commentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"user_id\" | \"post_id\" | \"parent_id\" | \"content\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"comments\"]>\n  export type commentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | postsDefaultArgs<ExtArgs>\n    parent?: boolean | comments$parentArgs<ExtArgs>\n    recursive?: boolean | comments$recursiveArgs<ExtArgs>\n    votes?: boolean | comments$votesArgs<ExtArgs>\n    _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type commentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | postsDefaultArgs<ExtArgs>\n    parent?: boolean | comments$parentArgs<ExtArgs>\n  }\n  export type commentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    author?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | postsDefaultArgs<ExtArgs>\n    parent?: boolean | comments$parentArgs<ExtArgs>\n  }\n\n  export type $commentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"comments\"\n    objects: {\n      author: Prisma.$usersPayload<ExtArgs>\n      post: Prisma.$postsPayload<ExtArgs>\n      parent: Prisma.$commentsPayload<ExtArgs> | null\n      recursive: Prisma.$commentsPayload<ExtArgs>[]\n      votes: Prisma.$votesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key. Unique identifier for each comment.\n       */\n      id: string\n      /**\n       * Author's {@link users.id} - Indicates the owner/author of the comment. Enforces accountability, links to profile and reputation system. Required for audit and moderation.\n       */\n      user_id: string\n      /**\n       * Parent post's {@link posts.id} - The post that this comment is in response to. Implements the association between comments and discussions. Required unless it's a reply to another comment only.\n       */\n      post_id: string\n      /**\n       * Parent comment's {@link comments.id} - Implements threaded/nested replies, allowing for comment hierarchies. Enables conversations to branch. Nullable for top-level comments (direct responses to posts).\n       */\n      parent_id: string | null\n      /**\n       * Comment body - Implements the rule that each comment consists of user-written text/content. Used for replies, opinions, and ongoing discussion. For example, 'I agree and here’s why...'.\n       */\n      content: string\n      /**\n       * Creation timestamp - Implements audit/history requirement for comment posting, tracking the date and time for moderation and display ordering. For example, enables 'most recent first' sorting.\n       */\n      created_at: Date\n      /**\n       * Last edited timestamp - Implements edit history tracking for evidence and transparency. If a user updates their comment, this records when.\n       */\n      updated_at: Date\n      /**\n       * Soft deletion timestamp - Implements moderation controls by marking comments removed (not hard deleted) for evidence/history. Used if comment violates rules, is self-removed, or by moderator action.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"comments\"]>\n    composites: {}\n  }\n\n  type commentsGetPayload<S extends boolean | null | undefined | commentsDefaultArgs> = $Result.GetResult<Prisma.$commentsPayload, S>\n\n  type commentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<commentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: CommentsCountAggregateInputType | true\n    }\n\n  export interface commentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comments'], meta: { name: 'comments' } }\n    /**\n     * Find zero or one Comments that matches the filter.\n     * @param {commentsFindUniqueArgs} args - Arguments to find a Comments\n     * @example\n     * // Get one Comments\n     * const comments = await prisma.comments.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends commentsFindUniqueArgs>(args: SelectSubset<T, commentsFindUniqueArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Comments that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {commentsFindUniqueOrThrowArgs} args - Arguments to find a Comments\n     * @example\n     * // Get one Comments\n     * const comments = await prisma.comments.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends commentsFindUniqueOrThrowArgs>(args: SelectSubset<T, commentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Comments that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {commentsFindFirstArgs} args - Arguments to find a Comments\n     * @example\n     * // Get one Comments\n     * const comments = await prisma.comments.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends commentsFindFirstArgs>(args?: SelectSubset<T, commentsFindFirstArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Comments that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {commentsFindFirstOrThrowArgs} args - Arguments to find a Comments\n     * @example\n     * // Get one Comments\n     * const comments = await prisma.comments.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends commentsFindFirstOrThrowArgs>(args?: SelectSubset<T, commentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Comments that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {commentsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Comments\n     * const comments = await prisma.comments.findMany()\n     * \n     * // Get first 10 Comments\n     * const comments = await prisma.comments.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const commentsWithIdOnly = await prisma.comments.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends commentsFindManyArgs>(args?: SelectSubset<T, commentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Comments.\n     * @param {commentsCreateArgs} args - Arguments to create a Comments.\n     * @example\n     * // Create one Comments\n     * const Comments = await prisma.comments.create({\n     *   data: {\n     *     // ... data to create a Comments\n     *   }\n     * })\n     * \n     */\n    create<T extends commentsCreateArgs>(args: SelectSubset<T, commentsCreateArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Comments.\n     * @param {commentsCreateManyArgs} args - Arguments to create many Comments.\n     * @example\n     * // Create many Comments\n     * const comments = await prisma.comments.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends commentsCreateManyArgs>(args?: SelectSubset<T, commentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Comments and returns the data saved in the database.\n     * @param {commentsCreateManyAndReturnArgs} args - Arguments to create many Comments.\n     * @example\n     * // Create many Comments\n     * const comments = await prisma.comments.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Comments and only return the `id`\n     * const commentsWithIdOnly = await prisma.comments.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends commentsCreateManyAndReturnArgs>(args?: SelectSubset<T, commentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Comments.\n     * @param {commentsDeleteArgs} args - Arguments to delete one Comments.\n     * @example\n     * // Delete one Comments\n     * const Comments = await prisma.comments.delete({\n     *   where: {\n     *     // ... filter to delete one Comments\n     *   }\n     * })\n     * \n     */\n    delete<T extends commentsDeleteArgs>(args: SelectSubset<T, commentsDeleteArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Comments.\n     * @param {commentsUpdateArgs} args - Arguments to update one Comments.\n     * @example\n     * // Update one Comments\n     * const comments = await prisma.comments.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends commentsUpdateArgs>(args: SelectSubset<T, commentsUpdateArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Comments.\n     * @param {commentsDeleteManyArgs} args - Arguments to filter Comments to delete.\n     * @example\n     * // Delete a few Comments\n     * const { count } = await prisma.comments.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends commentsDeleteManyArgs>(args?: SelectSubset<T, commentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {commentsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Comments\n     * const comments = await prisma.comments.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends commentsUpdateManyArgs>(args: SelectSubset<T, commentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Comments and returns the data updated in the database.\n     * @param {commentsUpdateManyAndReturnArgs} args - Arguments to update many Comments.\n     * @example\n     * // Update many Comments\n     * const comments = await prisma.comments.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Comments and only return the `id`\n     * const commentsWithIdOnly = await prisma.comments.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends commentsUpdateManyAndReturnArgs>(args: SelectSubset<T, commentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Comments.\n     * @param {commentsUpsertArgs} args - Arguments to update or create a Comments.\n     * @example\n     * // Update or create a Comments\n     * const comments = await prisma.comments.upsert({\n     *   create: {\n     *     // ... data to create a Comments\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Comments we want to update\n     *   }\n     * })\n     */\n    upsert<T extends commentsUpsertArgs>(args: SelectSubset<T, commentsUpsertArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {commentsCountArgs} args - Arguments to filter Comments to count.\n     * @example\n     * // Count the number of Comments\n     * const count = await prisma.comments.count({\n     *   where: {\n     *     // ... the filter for the Comments we want to count\n     *   }\n     * })\n    **/\n    count<T extends commentsCountArgs>(\n      args?: Subset<T, commentsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], CommentsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): Prisma.PrismaPromise<GetCommentsAggregateType<T>>\n\n    /**\n     * Group by Comments.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {commentsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends commentsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: commentsGroupByArgs['orderBy'] }\n        : { orderBy?: commentsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, commentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the comments model\n   */\n  readonly fields: commentsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for comments.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__commentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    author<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    post<T extends postsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, postsDefaultArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    parent<T extends comments$parentArgs<ExtArgs> = {}>(args?: Subset<T, comments$parentArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    recursive<T extends comments$recursiveArgs<ExtArgs> = {}>(args?: Subset<T, comments$recursiveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    votes<T extends comments$votesArgs<ExtArgs> = {}>(args?: Subset<T, comments$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the comments model\n   */\n  interface commentsFieldRefs {\n    readonly id: FieldRef<\"comments\", 'String'>\n    readonly user_id: FieldRef<\"comments\", 'String'>\n    readonly post_id: FieldRef<\"comments\", 'String'>\n    readonly parent_id: FieldRef<\"comments\", 'String'>\n    readonly content: FieldRef<\"comments\", 'String'>\n    readonly created_at: FieldRef<\"comments\", 'DateTime'>\n    readonly updated_at: FieldRef<\"comments\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"comments\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * comments findUnique\n   */\n  export type commentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which comments to fetch.\n     */\n    where: commentsWhereUniqueInput\n  }\n\n  /**\n   * comments findUniqueOrThrow\n   */\n  export type commentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which comments to fetch.\n     */\n    where: commentsWhereUniqueInput\n  }\n\n  /**\n   * comments findFirst\n   */\n  export type commentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which comments to fetch.\n     */\n    where?: commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of comments to fetch.\n     */\n    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for comments.\n     */\n    cursor?: commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` comments.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of comments.\n     */\n    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]\n  }\n\n  /**\n   * comments findFirstOrThrow\n   */\n  export type commentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which comments to fetch.\n     */\n    where?: commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of comments to fetch.\n     */\n    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for comments.\n     */\n    cursor?: commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` comments.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of comments.\n     */\n    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]\n  }\n\n  /**\n   * comments findMany\n   */\n  export type commentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * Filter, which comments to fetch.\n     */\n    where?: commentsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of comments to fetch.\n     */\n    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing comments.\n     */\n    cursor?: commentsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` comments from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` comments.\n     */\n    skip?: number\n    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]\n  }\n\n  /**\n   * comments create\n   */\n  export type commentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a comments.\n     */\n    data: XOR<commentsCreateInput, commentsUncheckedCreateInput>\n  }\n\n  /**\n   * comments createMany\n   */\n  export type commentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many comments.\n     */\n    data: commentsCreateManyInput | commentsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * comments createManyAndReturn\n   */\n  export type commentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * The data used to create many comments.\n     */\n    data: commentsCreateManyInput | commentsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * comments update\n   */\n  export type commentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a comments.\n     */\n    data: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>\n    /**\n     * Choose, which comments to update.\n     */\n    where: commentsWhereUniqueInput\n  }\n\n  /**\n   * comments updateMany\n   */\n  export type commentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update comments.\n     */\n    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>\n    /**\n     * Filter which comments to update\n     */\n    where?: commentsWhereInput\n    /**\n     * Limit how many comments to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * comments updateManyAndReturn\n   */\n  export type commentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * The data used to update comments.\n     */\n    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>\n    /**\n     * Filter which comments to update\n     */\n    where?: commentsWhereInput\n    /**\n     * Limit how many comments to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * comments upsert\n   */\n  export type commentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the comments to update in case it exists.\n     */\n    where: commentsWhereUniqueInput\n    /**\n     * In case the comments found by the `where` argument doesn't exist, create a new comments with this data.\n     */\n    create: XOR<commentsCreateInput, commentsUncheckedCreateInput>\n    /**\n     * In case the comments was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>\n  }\n\n  /**\n   * comments delete\n   */\n  export type commentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    /**\n     * Filter which comments to delete.\n     */\n    where: commentsWhereUniqueInput\n  }\n\n  /**\n   * comments deleteMany\n   */\n  export type commentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which comments to delete\n     */\n    where?: commentsWhereInput\n    /**\n     * Limit how many comments to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * comments.parent\n   */\n  export type comments$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    where?: commentsWhereInput\n  }\n\n  /**\n   * comments.recursive\n   */\n  export type comments$recursiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    where?: commentsWhereInput\n    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]\n    cursor?: commentsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]\n  }\n\n  /**\n   * comments.votes\n   */\n  export type comments$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    where?: votesWhereInput\n    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]\n    cursor?: votesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]\n  }\n\n  /**\n   * comments without action\n   */\n  export type commentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model votes\n   */\n\n  export type AggregateVotes = {\n    _count: VotesCountAggregateOutputType | null\n    _avg: VotesAvgAggregateOutputType | null\n    _sum: VotesSumAggregateOutputType | null\n    _min: VotesMinAggregateOutputType | null\n    _max: VotesMaxAggregateOutputType | null\n  }\n\n  export type VotesAvgAggregateOutputType = {\n    value: number | null\n  }\n\n  export type VotesSumAggregateOutputType = {\n    value: number | null\n  }\n\n  export type VotesMinAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    post_id: string | null\n    comment_id: string | null\n    value: number | null\n    created_at: Date | null\n  }\n\n  export type VotesMaxAggregateOutputType = {\n    id: string | null\n    user_id: string | null\n    post_id: string | null\n    comment_id: string | null\n    value: number | null\n    created_at: Date | null\n  }\n\n  export type VotesCountAggregateOutputType = {\n    id: number\n    user_id: number\n    post_id: number\n    comment_id: number\n    value: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type VotesAvgAggregateInputType = {\n    value?: true\n  }\n\n  export type VotesSumAggregateInputType = {\n    value?: true\n  }\n\n  export type VotesMinAggregateInputType = {\n    id?: true\n    user_id?: true\n    post_id?: true\n    comment_id?: true\n    value?: true\n    created_at?: true\n  }\n\n  export type VotesMaxAggregateInputType = {\n    id?: true\n    user_id?: true\n    post_id?: true\n    comment_id?: true\n    value?: true\n    created_at?: true\n  }\n\n  export type VotesCountAggregateInputType = {\n    id?: true\n    user_id?: true\n    post_id?: true\n    comment_id?: true\n    value?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type VotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which votes to aggregate.\n     */\n    where?: votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of votes to fetch.\n     */\n    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` votes.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned votes\n    **/\n    _count?: true | VotesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: VotesAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: VotesSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: VotesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: VotesMaxAggregateInputType\n  }\n\n  export type GetVotesAggregateType<T extends VotesAggregateArgs> = {\n        [P in keyof T & keyof AggregateVotes]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateVotes[P]>\n      : GetScalarType<T[P], AggregateVotes[P]>\n  }\n\n\n\n\n  export type votesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: votesWhereInput\n    orderBy?: votesOrderByWithAggregationInput | votesOrderByWithAggregationInput[]\n    by: VotesScalarFieldEnum[] | VotesScalarFieldEnum\n    having?: votesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: VotesCountAggregateInputType | true\n    _avg?: VotesAvgAggregateInputType\n    _sum?: VotesSumAggregateInputType\n    _min?: VotesMinAggregateInputType\n    _max?: VotesMaxAggregateInputType\n  }\n\n  export type VotesGroupByOutputType = {\n    id: string\n    user_id: string\n    post_id: string | null\n    comment_id: string | null\n    value: number\n    created_at: Date\n    _count: VotesCountAggregateOutputType | null\n    _avg: VotesAvgAggregateOutputType | null\n    _sum: VotesSumAggregateOutputType | null\n    _min: VotesMinAggregateOutputType | null\n    _max: VotesMaxAggregateOutputType | null\n  }\n\n  type GetVotesGroupByPayload<T extends votesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<VotesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof VotesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], VotesGroupByOutputType[P]>\n            : GetScalarType<T[P], VotesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type votesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    comment_id?: boolean\n    value?: boolean\n    created_at?: boolean\n    user?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | votes$postArgs<ExtArgs>\n    comment?: boolean | votes$commentArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"votes\"]>\n\n  export type votesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    comment_id?: boolean\n    value?: boolean\n    created_at?: boolean\n    user?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | votes$postArgs<ExtArgs>\n    comment?: boolean | votes$commentArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"votes\"]>\n\n  export type votesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    comment_id?: boolean\n    value?: boolean\n    created_at?: boolean\n    user?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | votes$postArgs<ExtArgs>\n    comment?: boolean | votes$commentArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"votes\"]>\n\n  export type votesSelectScalar = {\n    id?: boolean\n    user_id?: boolean\n    post_id?: boolean\n    comment_id?: boolean\n    value?: boolean\n    created_at?: boolean\n  }\n\n  export type votesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"user_id\" | \"post_id\" | \"comment_id\" | \"value\" | \"created_at\", ExtArgs[\"result\"][\"votes\"]>\n  export type votesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | votes$postArgs<ExtArgs>\n    comment?: boolean | votes$commentArgs<ExtArgs>\n  }\n  export type votesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | votes$postArgs<ExtArgs>\n    comment?: boolean | votes$commentArgs<ExtArgs>\n  }\n  export type votesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | usersDefaultArgs<ExtArgs>\n    post?: boolean | votes$postArgs<ExtArgs>\n    comment?: boolean | votes$commentArgs<ExtArgs>\n  }\n\n  export type $votesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"votes\"\n    objects: {\n      user: Prisma.$usersPayload<ExtArgs>\n      post: Prisma.$postsPayload<ExtArgs> | null\n      comment: Prisma.$commentsPayload<ExtArgs> | null\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key. Unique identifier for each vote record.\n       */\n      id: string\n      /**\n       * Voter's user reference - Links each vote to the user who cast it. Implements the requirement that only registered users can vote. Business meaning: Tracks voting history and enforces unique voting constraints. Example: User 'U' upvotes a comment, linking the vote to 'U's user_id.\n       */\n      user_id: string\n      /**\n       * Target post's reference - References the post being voted on, if the vote relates to a post (and not a comment). Implements mutual exclusivity rule and enables vote tallies for posts. Example: Voting on a thread increases the tally on the referenced post. Constraint: Only one of post_id or comment_id is non-null per row.\n       */\n      post_id: string | null\n      /**\n       * Target comment's reference - References the comment being voted on, if applicable. Implements mutual exclusivity rule as with posts. Example: Voting on a reply records the vote linked to this comment. Only one of post_id or comment_id is set per vote record.\n       */\n      comment_id: string | null\n      /**\n       * Vote value - Implements the upvote/downvote requirement. Stores +1 for upvote, -1 for downvote. Business meaning: This value is aggregated to produce content rankings. Example: A +1 value indicates an upvote from a user.\n       */\n      value: number\n      /**\n       * Vote timestamp - Implements auditing requirements for vote tracking. Stores the date and time the vote was made. Used for analytics and to enforce time-based voting limits, if ever required by policy.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"votes\"]>\n    composites: {}\n  }\n\n  type votesGetPayload<S extends boolean | null | undefined | votesDefaultArgs> = $Result.GetResult<Prisma.$votesPayload, S>\n\n  type votesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<votesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: VotesCountAggregateInputType | true\n    }\n\n  export interface votesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['votes'], meta: { name: 'votes' } }\n    /**\n     * Find zero or one Votes that matches the filter.\n     * @param {votesFindUniqueArgs} args - Arguments to find a Votes\n     * @example\n     * // Get one Votes\n     * const votes = await prisma.votes.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends votesFindUniqueArgs>(args: SelectSubset<T, votesFindUniqueArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Votes that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {votesFindUniqueOrThrowArgs} args - Arguments to find a Votes\n     * @example\n     * // Get one Votes\n     * const votes = await prisma.votes.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends votesFindUniqueOrThrowArgs>(args: SelectSubset<T, votesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Votes that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {votesFindFirstArgs} args - Arguments to find a Votes\n     * @example\n     * // Get one Votes\n     * const votes = await prisma.votes.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends votesFindFirstArgs>(args?: SelectSubset<T, votesFindFirstArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Votes that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {votesFindFirstOrThrowArgs} args - Arguments to find a Votes\n     * @example\n     * // Get one Votes\n     * const votes = await prisma.votes.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends votesFindFirstOrThrowArgs>(args?: SelectSubset<T, votesFindFirstOrThrowArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Votes that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {votesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Votes\n     * const votes = await prisma.votes.findMany()\n     * \n     * // Get first 10 Votes\n     * const votes = await prisma.votes.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const votesWithIdOnly = await prisma.votes.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends votesFindManyArgs>(args?: SelectSubset<T, votesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Votes.\n     * @param {votesCreateArgs} args - Arguments to create a Votes.\n     * @example\n     * // Create one Votes\n     * const Votes = await prisma.votes.create({\n     *   data: {\n     *     // ... data to create a Votes\n     *   }\n     * })\n     * \n     */\n    create<T extends votesCreateArgs>(args: SelectSubset<T, votesCreateArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Votes.\n     * @param {votesCreateManyArgs} args - Arguments to create many Votes.\n     * @example\n     * // Create many Votes\n     * const votes = await prisma.votes.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends votesCreateManyArgs>(args?: SelectSubset<T, votesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Votes and returns the data saved in the database.\n     * @param {votesCreateManyAndReturnArgs} args - Arguments to create many Votes.\n     * @example\n     * // Create many Votes\n     * const votes = await prisma.votes.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Votes and only return the `id`\n     * const votesWithIdOnly = await prisma.votes.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends votesCreateManyAndReturnArgs>(args?: SelectSubset<T, votesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Votes.\n     * @param {votesDeleteArgs} args - Arguments to delete one Votes.\n     * @example\n     * // Delete one Votes\n     * const Votes = await prisma.votes.delete({\n     *   where: {\n     *     // ... filter to delete one Votes\n     *   }\n     * })\n     * \n     */\n    delete<T extends votesDeleteArgs>(args: SelectSubset<T, votesDeleteArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Votes.\n     * @param {votesUpdateArgs} args - Arguments to update one Votes.\n     * @example\n     * // Update one Votes\n     * const votes = await prisma.votes.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends votesUpdateArgs>(args: SelectSubset<T, votesUpdateArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Votes.\n     * @param {votesDeleteManyArgs} args - Arguments to filter Votes to delete.\n     * @example\n     * // Delete a few Votes\n     * const { count } = await prisma.votes.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends votesDeleteManyArgs>(args?: SelectSubset<T, votesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {votesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Votes\n     * const votes = await prisma.votes.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends votesUpdateManyArgs>(args: SelectSubset<T, votesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Votes and returns the data updated in the database.\n     * @param {votesUpdateManyAndReturnArgs} args - Arguments to update many Votes.\n     * @example\n     * // Update many Votes\n     * const votes = await prisma.votes.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Votes and only return the `id`\n     * const votesWithIdOnly = await prisma.votes.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends votesUpdateManyAndReturnArgs>(args: SelectSubset<T, votesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Votes.\n     * @param {votesUpsertArgs} args - Arguments to update or create a Votes.\n     * @example\n     * // Update or create a Votes\n     * const votes = await prisma.votes.upsert({\n     *   create: {\n     *     // ... data to create a Votes\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Votes we want to update\n     *   }\n     * })\n     */\n    upsert<T extends votesUpsertArgs>(args: SelectSubset<T, votesUpsertArgs<ExtArgs>>): Prisma__votesClient<$Result.GetResult<Prisma.$votesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {votesCountArgs} args - Arguments to filter Votes to count.\n     * @example\n     * // Count the number of Votes\n     * const count = await prisma.votes.count({\n     *   where: {\n     *     // ... the filter for the Votes we want to count\n     *   }\n     * })\n    **/\n    count<T extends votesCountArgs>(\n      args?: Subset<T, votesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], VotesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {VotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends VotesAggregateArgs>(args: Subset<T, VotesAggregateArgs>): Prisma.PrismaPromise<GetVotesAggregateType<T>>\n\n    /**\n     * Group by Votes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {votesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends votesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: votesGroupByArgs['orderBy'] }\n        : { orderBy?: votesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, votesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the votes model\n   */\n  readonly fields: votesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for votes.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__votesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    post<T extends votes$postArgs<ExtArgs> = {}>(args?: Subset<T, votes$postArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    comment<T extends votes$commentArgs<ExtArgs> = {}>(args?: Subset<T, votes$commentArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the votes model\n   */\n  interface votesFieldRefs {\n    readonly id: FieldRef<\"votes\", 'String'>\n    readonly user_id: FieldRef<\"votes\", 'String'>\n    readonly post_id: FieldRef<\"votes\", 'String'>\n    readonly comment_id: FieldRef<\"votes\", 'String'>\n    readonly value: FieldRef<\"votes\", 'Int'>\n    readonly created_at: FieldRef<\"votes\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * votes findUnique\n   */\n  export type votesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * Filter, which votes to fetch.\n     */\n    where: votesWhereUniqueInput\n  }\n\n  /**\n   * votes findUniqueOrThrow\n   */\n  export type votesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * Filter, which votes to fetch.\n     */\n    where: votesWhereUniqueInput\n  }\n\n  /**\n   * votes findFirst\n   */\n  export type votesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * Filter, which votes to fetch.\n     */\n    where?: votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of votes to fetch.\n     */\n    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for votes.\n     */\n    cursor?: votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` votes.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of votes.\n     */\n    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]\n  }\n\n  /**\n   * votes findFirstOrThrow\n   */\n  export type votesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * Filter, which votes to fetch.\n     */\n    where?: votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of votes to fetch.\n     */\n    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for votes.\n     */\n    cursor?: votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` votes.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of votes.\n     */\n    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]\n  }\n\n  /**\n   * votes findMany\n   */\n  export type votesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * Filter, which votes to fetch.\n     */\n    where?: votesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of votes to fetch.\n     */\n    orderBy?: votesOrderByWithRelationInput | votesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing votes.\n     */\n    cursor?: votesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` votes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` votes.\n     */\n    skip?: number\n    distinct?: VotesScalarFieldEnum | VotesScalarFieldEnum[]\n  }\n\n  /**\n   * votes create\n   */\n  export type votesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a votes.\n     */\n    data: XOR<votesCreateInput, votesUncheckedCreateInput>\n  }\n\n  /**\n   * votes createMany\n   */\n  export type votesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many votes.\n     */\n    data: votesCreateManyInput | votesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * votes createManyAndReturn\n   */\n  export type votesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * The data used to create many votes.\n     */\n    data: votesCreateManyInput | votesCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * votes update\n   */\n  export type votesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a votes.\n     */\n    data: XOR<votesUpdateInput, votesUncheckedUpdateInput>\n    /**\n     * Choose, which votes to update.\n     */\n    where: votesWhereUniqueInput\n  }\n\n  /**\n   * votes updateMany\n   */\n  export type votesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update votes.\n     */\n    data: XOR<votesUpdateManyMutationInput, votesUncheckedUpdateManyInput>\n    /**\n     * Filter which votes to update\n     */\n    where?: votesWhereInput\n    /**\n     * Limit how many votes to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * votes updateManyAndReturn\n   */\n  export type votesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * The data used to update votes.\n     */\n    data: XOR<votesUpdateManyMutationInput, votesUncheckedUpdateManyInput>\n    /**\n     * Filter which votes to update\n     */\n    where?: votesWhereInput\n    /**\n     * Limit how many votes to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * votes upsert\n   */\n  export type votesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the votes to update in case it exists.\n     */\n    where: votesWhereUniqueInput\n    /**\n     * In case the votes found by the `where` argument doesn't exist, create a new votes with this data.\n     */\n    create: XOR<votesCreateInput, votesUncheckedCreateInput>\n    /**\n     * In case the votes was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<votesUpdateInput, votesUncheckedUpdateInput>\n  }\n\n  /**\n   * votes delete\n   */\n  export type votesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n    /**\n     * Filter which votes to delete.\n     */\n    where: votesWhereUniqueInput\n  }\n\n  /**\n   * votes deleteMany\n   */\n  export type votesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which votes to delete\n     */\n    where?: votesWhereInput\n    /**\n     * Limit how many votes to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * votes.post\n   */\n  export type votes$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the posts\n     */\n    select?: postsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the posts\n     */\n    omit?: postsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: postsInclude<ExtArgs> | null\n    where?: postsWhereInput\n  }\n\n  /**\n   * votes.comment\n   */\n  export type votes$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the comments\n     */\n    select?: commentsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the comments\n     */\n    omit?: commentsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: commentsInclude<ExtArgs> | null\n    where?: commentsWhereInput\n  }\n\n  /**\n   * votes without action\n   */\n  export type votesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the votes\n     */\n    select?: votesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the votes\n     */\n    omit?: votesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: votesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Enums\n   */\n\n  export const TransactionIsolationLevel: {\n    ReadUncommitted: 'ReadUncommitted',\n    ReadCommitted: 'ReadCommitted',\n    RepeatableRead: 'RepeatableRead',\n    Serializable: 'Serializable'\n  };\n\n  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\n  export const UsersScalarFieldEnum: {\n    id: 'id',\n    user_role_id: 'user_role_id',\n    username: 'username',\n    email: 'email',\n    bio: 'bio',\n    password_hash: 'password_hash',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    status: 'status'\n  };\n\n  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]\n\n\n  export const User_rolesScalarFieldEnum: {\n    id: 'id',\n    name: 'name',\n    description: 'description'\n  };\n\n  export type User_rolesScalarFieldEnum = (typeof User_rolesScalarFieldEnum)[keyof typeof User_rolesScalarFieldEnum]\n\n\n  export const CategoriesScalarFieldEnum: {\n    id: 'id',\n    name: 'name',\n    description: 'description',\n    created_at: 'created_at'\n  };\n\n  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]\n\n\n  export const PostsScalarFieldEnum: {\n    id: 'id',\n    user_id: 'user_id',\n    category_id: 'category_id',\n    title: 'title',\n    content: 'content',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type PostsScalarFieldEnum = (typeof PostsScalarFieldEnum)[keyof typeof PostsScalarFieldEnum]\n\n\n  export const CommentsScalarFieldEnum: {\n    id: 'id',\n    user_id: 'user_id',\n    post_id: 'post_id',\n    parent_id: 'parent_id',\n    content: 'content',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]\n\n\n  export const VotesScalarFieldEnum: {\n    id: 'id',\n    user_id: 'user_id',\n    post_id: 'post_id',\n    comment_id: 'comment_id',\n    value: 'value',\n    created_at: 'created_at'\n  };\n\n  export type VotesScalarFieldEnum = (typeof VotesScalarFieldEnum)[keyof typeof VotesScalarFieldEnum]\n\n\n  export const SortOrder: {\n    asc: 'asc',\n    desc: 'desc'\n  };\n\n  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\n  export const QueryMode: {\n    default: 'default',\n    insensitive: 'insensitive'\n  };\n\n  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\n  export const NullsOrder: {\n    first: 'first',\n    last: 'last'\n  };\n\n  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n  /**\n   * Field references\n   */\n\n\n  /**\n   * Reference to a field of type 'String'\n   */\n  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n  /**\n   * Reference to a field of type 'String[]'\n   */\n  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime'\n   */\n  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime[]'\n   */\n  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int'\n   */\n  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int[]'\n   */\n  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Float'\n   */\n  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>\n    \n\n\n  /**\n   * Reference to a field of type 'Float[]'\n   */\n  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>\n    \n  /**\n   * Deep Input Types\n   */\n\n\n  export type usersWhereInput = {\n    AND?: usersWhereInput | usersWhereInput[]\n    OR?: usersWhereInput[]\n    NOT?: usersWhereInput | usersWhereInput[]\n    id?: UuidFilter<\"users\"> | string\n    user_role_id?: UuidFilter<\"users\"> | string\n    username?: StringFilter<\"users\"> | string\n    email?: StringFilter<\"users\"> | string\n    bio?: StringNullableFilter<\"users\"> | string | null\n    password_hash?: StringFilter<\"users\"> | string\n    created_at?: DateTimeFilter<\"users\"> | Date | string\n    updated_at?: DateTimeFilter<\"users\"> | Date | string\n    status?: StringFilter<\"users\"> | string\n    role?: XOR<User_rolesScalarRelationFilter, user_rolesWhereInput>\n    posts?: PostsListRelationFilter\n    comments?: CommentsListRelationFilter\n    votes?: VotesListRelationFilter\n  }\n\n  export type usersOrderByWithRelationInput = {\n    id?: SortOrder\n    user_role_id?: SortOrder\n    username?: SortOrder\n    email?: SortOrder\n    bio?: SortOrderInput | SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    status?: SortOrder\n    role?: user_rolesOrderByWithRelationInput\n    posts?: postsOrderByRelationAggregateInput\n    comments?: commentsOrderByRelationAggregateInput\n    votes?: votesOrderByRelationAggregateInput\n  }\n\n  export type usersWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    username?: string\n    email?: string\n    AND?: usersWhereInput | usersWhereInput[]\n    OR?: usersWhereInput[]\n    NOT?: usersWhereInput | usersWhereInput[]\n    user_role_id?: UuidFilter<\"users\"> | string\n    bio?: StringNullableFilter<\"users\"> | string | null\n    password_hash?: StringFilter<\"users\"> | string\n    created_at?: DateTimeFilter<\"users\"> | Date | string\n    updated_at?: DateTimeFilter<\"users\"> | Date | string\n    status?: StringFilter<\"users\"> | string\n    role?: XOR<User_rolesScalarRelationFilter, user_rolesWhereInput>\n    posts?: PostsListRelationFilter\n    comments?: CommentsListRelationFilter\n    votes?: VotesListRelationFilter\n  }, \"id\" | \"username\" | \"email\">\n\n  export type usersOrderByWithAggregationInput = {\n    id?: SortOrder\n    user_role_id?: SortOrder\n    username?: SortOrder\n    email?: SortOrder\n    bio?: SortOrderInput | SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    status?: SortOrder\n    _count?: usersCountOrderByAggregateInput\n    _max?: usersMaxOrderByAggregateInput\n    _min?: usersMinOrderByAggregateInput\n  }\n\n  export type usersScalarWhereWithAggregatesInput = {\n    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]\n    OR?: usersScalarWhereWithAggregatesInput[]\n    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"users\"> | string\n    user_role_id?: UuidWithAggregatesFilter<\"users\"> | string\n    username?: StringWithAggregatesFilter<\"users\"> | string\n    email?: StringWithAggregatesFilter<\"users\"> | string\n    bio?: StringNullableWithAggregatesFilter<\"users\"> | string | null\n    password_hash?: StringWithAggregatesFilter<\"users\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"users\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"users\"> | Date | string\n    status?: StringWithAggregatesFilter<\"users\"> | string\n  }\n\n  export type user_rolesWhereInput = {\n    AND?: user_rolesWhereInput | user_rolesWhereInput[]\n    OR?: user_rolesWhereInput[]\n    NOT?: user_rolesWhereInput | user_rolesWhereInput[]\n    id?: UuidFilter<\"user_roles\"> | string\n    name?: StringFilter<\"user_roles\"> | string\n    description?: StringFilter<\"user_roles\"> | string\n    users?: UsersListRelationFilter\n  }\n\n  export type user_rolesOrderByWithRelationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    users?: usersOrderByRelationAggregateInput\n  }\n\n  export type user_rolesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    name?: string\n    AND?: user_rolesWhereInput | user_rolesWhereInput[]\n    OR?: user_rolesWhereInput[]\n    NOT?: user_rolesWhereInput | user_rolesWhereInput[]\n    description?: StringFilter<\"user_roles\"> | string\n    users?: UsersListRelationFilter\n  }, \"id\" | \"name\">\n\n  export type user_rolesOrderByWithAggregationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    _count?: user_rolesCountOrderByAggregateInput\n    _max?: user_rolesMaxOrderByAggregateInput\n    _min?: user_rolesMinOrderByAggregateInput\n  }\n\n  export type user_rolesScalarWhereWithAggregatesInput = {\n    AND?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]\n    OR?: user_rolesScalarWhereWithAggregatesInput[]\n    NOT?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"user_roles\"> | string\n    name?: StringWithAggregatesFilter<\"user_roles\"> | string\n    description?: StringWithAggregatesFilter<\"user_roles\"> | string\n  }\n\n  export type categoriesWhereInput = {\n    AND?: categoriesWhereInput | categoriesWhereInput[]\n    OR?: categoriesWhereInput[]\n    NOT?: categoriesWhereInput | categoriesWhereInput[]\n    id?: UuidFilter<\"categories\"> | string\n    name?: StringFilter<\"categories\"> | string\n    description?: StringFilter<\"categories\"> | string\n    created_at?: DateTimeFilter<\"categories\"> | Date | string\n    posts?: PostsListRelationFilter\n  }\n\n  export type categoriesOrderByWithRelationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    posts?: postsOrderByRelationAggregateInput\n  }\n\n  export type categoriesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    name?: string\n    AND?: categoriesWhereInput | categoriesWhereInput[]\n    OR?: categoriesWhereInput[]\n    NOT?: categoriesWhereInput | categoriesWhereInput[]\n    description?: StringFilter<\"categories\"> | string\n    created_at?: DateTimeFilter<\"categories\"> | Date | string\n    posts?: PostsListRelationFilter\n  }, \"id\" | \"name\">\n\n  export type categoriesOrderByWithAggregationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n    _count?: categoriesCountOrderByAggregateInput\n    _max?: categoriesMaxOrderByAggregateInput\n    _min?: categoriesMinOrderByAggregateInput\n  }\n\n  export type categoriesScalarWhereWithAggregatesInput = {\n    AND?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]\n    OR?: categoriesScalarWhereWithAggregatesInput[]\n    NOT?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"categories\"> | string\n    name?: StringWithAggregatesFilter<\"categories\"> | string\n    description?: StringWithAggregatesFilter<\"categories\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"categories\"> | Date | string\n  }\n\n  export type postsWhereInput = {\n    AND?: postsWhereInput | postsWhereInput[]\n    OR?: postsWhereInput[]\n    NOT?: postsWhereInput | postsWhereInput[]\n    id?: UuidFilter<\"posts\"> | string\n    user_id?: UuidFilter<\"posts\"> | string\n    category_id?: UuidFilter<\"posts\"> | string\n    title?: StringFilter<\"posts\"> | string\n    content?: StringFilter<\"posts\"> | string\n    created_at?: DateTimeFilter<\"posts\"> | Date | string\n    updated_at?: DateTimeFilter<\"posts\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"posts\"> | Date | string | null\n    author?: XOR<UsersScalarRelationFilter, usersWhereInput>\n    category?: XOR<CategoriesScalarRelationFilter, categoriesWhereInput>\n    comments?: CommentsListRelationFilter\n    votes?: VotesListRelationFilter\n  }\n\n  export type postsOrderByWithRelationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    category_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    author?: usersOrderByWithRelationInput\n    category?: categoriesOrderByWithRelationInput\n    comments?: commentsOrderByRelationAggregateInput\n    votes?: votesOrderByRelationAggregateInput\n  }\n\n  export type postsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: postsWhereInput | postsWhereInput[]\n    OR?: postsWhereInput[]\n    NOT?: postsWhereInput | postsWhereInput[]\n    user_id?: UuidFilter<\"posts\"> | string\n    category_id?: UuidFilter<\"posts\"> | string\n    title?: StringFilter<\"posts\"> | string\n    content?: StringFilter<\"posts\"> | string\n    created_at?: DateTimeFilter<\"posts\"> | Date | string\n    updated_at?: DateTimeFilter<\"posts\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"posts\"> | Date | string | null\n    author?: XOR<UsersScalarRelationFilter, usersWhereInput>\n    category?: XOR<CategoriesScalarRelationFilter, categoriesWhereInput>\n    comments?: CommentsListRelationFilter\n    votes?: VotesListRelationFilter\n  }, \"id\">\n\n  export type postsOrderByWithAggregationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    category_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: postsCountOrderByAggregateInput\n    _max?: postsMaxOrderByAggregateInput\n    _min?: postsMinOrderByAggregateInput\n  }\n\n  export type postsScalarWhereWithAggregatesInput = {\n    AND?: postsScalarWhereWithAggregatesInput | postsScalarWhereWithAggregatesInput[]\n    OR?: postsScalarWhereWithAggregatesInput[]\n    NOT?: postsScalarWhereWithAggregatesInput | postsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"posts\"> | string\n    user_id?: UuidWithAggregatesFilter<\"posts\"> | string\n    category_id?: UuidWithAggregatesFilter<\"posts\"> | string\n    title?: StringWithAggregatesFilter<\"posts\"> | string\n    content?: StringWithAggregatesFilter<\"posts\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"posts\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"posts\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"posts\"> | Date | string | null\n  }\n\n  export type commentsWhereInput = {\n    AND?: commentsWhereInput | commentsWhereInput[]\n    OR?: commentsWhereInput[]\n    NOT?: commentsWhereInput | commentsWhereInput[]\n    id?: UuidFilter<\"comments\"> | string\n    user_id?: UuidFilter<\"comments\"> | string\n    post_id?: UuidFilter<\"comments\"> | string\n    parent_id?: UuidNullableFilter<\"comments\"> | string | null\n    content?: StringFilter<\"comments\"> | string\n    created_at?: DateTimeFilter<\"comments\"> | Date | string\n    updated_at?: DateTimeFilter<\"comments\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"comments\"> | Date | string | null\n    author?: XOR<UsersScalarRelationFilter, usersWhereInput>\n    post?: XOR<PostsScalarRelationFilter, postsWhereInput>\n    parent?: XOR<CommentsNullableScalarRelationFilter, commentsWhereInput> | null\n    recursive?: CommentsListRelationFilter\n    votes?: VotesListRelationFilter\n  }\n\n  export type commentsOrderByWithRelationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    parent_id?: SortOrderInput | SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    author?: usersOrderByWithRelationInput\n    post?: postsOrderByWithRelationInput\n    parent?: commentsOrderByWithRelationInput\n    recursive?: commentsOrderByRelationAggregateInput\n    votes?: votesOrderByRelationAggregateInput\n  }\n\n  export type commentsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: commentsWhereInput | commentsWhereInput[]\n    OR?: commentsWhereInput[]\n    NOT?: commentsWhereInput | commentsWhereInput[]\n    user_id?: UuidFilter<\"comments\"> | string\n    post_id?: UuidFilter<\"comments\"> | string\n    parent_id?: UuidNullableFilter<\"comments\"> | string | null\n    content?: StringFilter<\"comments\"> | string\n    created_at?: DateTimeFilter<\"comments\"> | Date | string\n    updated_at?: DateTimeFilter<\"comments\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"comments\"> | Date | string | null\n    author?: XOR<UsersScalarRelationFilter, usersWhereInput>\n    post?: XOR<PostsScalarRelationFilter, postsWhereInput>\n    parent?: XOR<CommentsNullableScalarRelationFilter, commentsWhereInput> | null\n    recursive?: CommentsListRelationFilter\n    votes?: VotesListRelationFilter\n  }, \"id\">\n\n  export type commentsOrderByWithAggregationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    parent_id?: SortOrderInput | SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: commentsCountOrderByAggregateInput\n    _max?: commentsMaxOrderByAggregateInput\n    _min?: commentsMinOrderByAggregateInput\n  }\n\n  export type commentsScalarWhereWithAggregatesInput = {\n    AND?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]\n    OR?: commentsScalarWhereWithAggregatesInput[]\n    NOT?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"comments\"> | string\n    user_id?: UuidWithAggregatesFilter<\"comments\"> | string\n    post_id?: UuidWithAggregatesFilter<\"comments\"> | string\n    parent_id?: UuidNullableWithAggregatesFilter<\"comments\"> | string | null\n    content?: StringWithAggregatesFilter<\"comments\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"comments\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"comments\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"comments\"> | Date | string | null\n  }\n\n  export type votesWhereInput = {\n    AND?: votesWhereInput | votesWhereInput[]\n    OR?: votesWhereInput[]\n    NOT?: votesWhereInput | votesWhereInput[]\n    id?: UuidFilter<\"votes\"> | string\n    user_id?: UuidFilter<\"votes\"> | string\n    post_id?: UuidNullableFilter<\"votes\"> | string | null\n    comment_id?: UuidNullableFilter<\"votes\"> | string | null\n    value?: IntFilter<\"votes\"> | number\n    created_at?: DateTimeFilter<\"votes\"> | Date | string\n    user?: XOR<UsersScalarRelationFilter, usersWhereInput>\n    post?: XOR<PostsNullableScalarRelationFilter, postsWhereInput> | null\n    comment?: XOR<CommentsNullableScalarRelationFilter, commentsWhereInput> | null\n  }\n\n  export type votesOrderByWithRelationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrderInput | SortOrder\n    comment_id?: SortOrderInput | SortOrder\n    value?: SortOrder\n    created_at?: SortOrder\n    user?: usersOrderByWithRelationInput\n    post?: postsOrderByWithRelationInput\n    comment?: commentsOrderByWithRelationInput\n  }\n\n  export type votesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    user_id_post_id?: votesUser_idPost_idCompoundUniqueInput\n    user_id_comment_id?: votesUser_idComment_idCompoundUniqueInput\n    AND?: votesWhereInput | votesWhereInput[]\n    OR?: votesWhereInput[]\n    NOT?: votesWhereInput | votesWhereInput[]\n    user_id?: UuidFilter<\"votes\"> | string\n    post_id?: UuidNullableFilter<\"votes\"> | string | null\n    comment_id?: UuidNullableFilter<\"votes\"> | string | null\n    value?: IntFilter<\"votes\"> | number\n    created_at?: DateTimeFilter<\"votes\"> | Date | string\n    user?: XOR<UsersScalarRelationFilter, usersWhereInput>\n    post?: XOR<PostsNullableScalarRelationFilter, postsWhereInput> | null\n    comment?: XOR<CommentsNullableScalarRelationFilter, commentsWhereInput> | null\n  }, \"id\" | \"user_id_post_id\" | \"user_id_comment_id\">\n\n  export type votesOrderByWithAggregationInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrderInput | SortOrder\n    comment_id?: SortOrderInput | SortOrder\n    value?: SortOrder\n    created_at?: SortOrder\n    _count?: votesCountOrderByAggregateInput\n    _avg?: votesAvgOrderByAggregateInput\n    _max?: votesMaxOrderByAggregateInput\n    _min?: votesMinOrderByAggregateInput\n    _sum?: votesSumOrderByAggregateInput\n  }\n\n  export type votesScalarWhereWithAggregatesInput = {\n    AND?: votesScalarWhereWithAggregatesInput | votesScalarWhereWithAggregatesInput[]\n    OR?: votesScalarWhereWithAggregatesInput[]\n    NOT?: votesScalarWhereWithAggregatesInput | votesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"votes\"> | string\n    user_id?: UuidWithAggregatesFilter<\"votes\"> | string\n    post_id?: UuidNullableWithAggregatesFilter<\"votes\"> | string | null\n    comment_id?: UuidNullableWithAggregatesFilter<\"votes\"> | string | null\n    value?: IntWithAggregatesFilter<\"votes\"> | number\n    created_at?: DateTimeWithAggregatesFilter<\"votes\"> | Date | string\n  }\n\n  export type usersCreateInput = {\n    id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    role: user_rolesCreateNestedOneWithoutUsersInput\n    posts?: postsCreateNestedManyWithoutAuthorInput\n    comments?: commentsCreateNestedManyWithoutAuthorInput\n    votes?: votesCreateNestedManyWithoutUserInput\n  }\n\n  export type usersUncheckedCreateInput = {\n    id: string\n    user_role_id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    posts?: postsUncheckedCreateNestedManyWithoutAuthorInput\n    comments?: commentsUncheckedCreateNestedManyWithoutAuthorInput\n    votes?: votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type usersUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    role?: user_rolesUpdateOneRequiredWithoutUsersNestedInput\n    posts?: postsUpdateManyWithoutAuthorNestedInput\n    comments?: commentsUpdateManyWithoutAuthorNestedInput\n    votes?: votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type usersUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_role_id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    posts?: postsUncheckedUpdateManyWithoutAuthorNestedInput\n    comments?: commentsUncheckedUpdateManyWithoutAuthorNestedInput\n    votes?: votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type usersCreateManyInput = {\n    id: string\n    user_role_id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n  }\n\n  export type usersUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type usersUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_role_id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type user_rolesCreateInput = {\n    id: string\n    name: string\n    description: string\n    users?: usersCreateNestedManyWithoutRoleInput\n  }\n\n  export type user_rolesUncheckedCreateInput = {\n    id: string\n    name: string\n    description: string\n    users?: usersUncheckedCreateNestedManyWithoutRoleInput\n  }\n\n  export type user_rolesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    users?: usersUpdateManyWithoutRoleNestedInput\n  }\n\n  export type user_rolesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    users?: usersUncheckedUpdateManyWithoutRoleNestedInput\n  }\n\n  export type user_rolesCreateManyInput = {\n    id: string\n    name: string\n    description: string\n  }\n\n  export type user_rolesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type user_rolesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type categoriesCreateInput = {\n    id: string\n    name: string\n    description: string\n    created_at: Date | string\n    posts?: postsCreateNestedManyWithoutCategoryInput\n  }\n\n  export type categoriesUncheckedCreateInput = {\n    id: string\n    name: string\n    description: string\n    created_at: Date | string\n    posts?: postsUncheckedCreateNestedManyWithoutCategoryInput\n  }\n\n  export type categoriesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    posts?: postsUpdateManyWithoutCategoryNestedInput\n  }\n\n  export type categoriesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    posts?: postsUncheckedUpdateManyWithoutCategoryNestedInput\n  }\n\n  export type categoriesCreateManyInput = {\n    id: string\n    name: string\n    description: string\n    created_at: Date | string\n  }\n\n  export type categoriesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type categoriesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type postsCreateInput = {\n    id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutPostsInput\n    category: categoriesCreateNestedOneWithoutPostsInput\n    comments?: commentsCreateNestedManyWithoutPostInput\n    votes?: votesCreateNestedManyWithoutPostInput\n  }\n\n  export type postsUncheckedCreateInput = {\n    id: string\n    user_id: string\n    category_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    comments?: commentsUncheckedCreateNestedManyWithoutPostInput\n    votes?: votesUncheckedCreateNestedManyWithoutPostInput\n  }\n\n  export type postsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutPostsNestedInput\n    category?: categoriesUpdateOneRequiredWithoutPostsNestedInput\n    comments?: commentsUpdateManyWithoutPostNestedInput\n    votes?: votesUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    category_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    comments?: commentsUncheckedUpdateManyWithoutPostNestedInput\n    votes?: votesUncheckedUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsCreateManyInput = {\n    id: string\n    user_id: string\n    category_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type postsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type postsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    category_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type commentsCreateInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutCommentsInput\n    post: postsCreateNestedOneWithoutCommentsInput\n    parent?: commentsCreateNestedOneWithoutRecursiveInput\n    recursive?: commentsCreateNestedManyWithoutParentInput\n    votes?: votesCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsUncheckedCreateInput = {\n    id: string\n    user_id: string\n    post_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    recursive?: commentsUncheckedCreateNestedManyWithoutParentInput\n    votes?: votesUncheckedCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutCommentsNestedInput\n    post?: postsUpdateOneRequiredWithoutCommentsNestedInput\n    parent?: commentsUpdateOneWithoutRecursiveNestedInput\n    recursive?: commentsUpdateManyWithoutParentNestedInput\n    votes?: votesUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    recursive?: commentsUncheckedUpdateManyWithoutParentNestedInput\n    votes?: votesUncheckedUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsCreateManyInput = {\n    id: string\n    user_id: string\n    post_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type commentsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type commentsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type votesCreateInput = {\n    id: string\n    value: number\n    created_at: Date | string\n    user: usersCreateNestedOneWithoutVotesInput\n    post?: postsCreateNestedOneWithoutVotesInput\n    comment?: commentsCreateNestedOneWithoutVotesInput\n  }\n\n  export type votesUncheckedCreateInput = {\n    id: string\n    user_id: string\n    post_id?: string | null\n    comment_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type votesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: usersUpdateOneRequiredWithoutVotesNestedInput\n    post?: postsUpdateOneWithoutVotesNestedInput\n    comment?: commentsUpdateOneWithoutVotesNestedInput\n  }\n\n  export type votesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: NullableStringFieldUpdateOperationsInput | string | null\n    comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type votesCreateManyInput = {\n    id: string\n    user_id: string\n    post_id?: string | null\n    comment_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type votesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type votesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: NullableStringFieldUpdateOperationsInput | string | null\n    comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type UuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type StringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type StringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type DateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type User_rolesScalarRelationFilter = {\n    is?: user_rolesWhereInput\n    isNot?: user_rolesWhereInput\n  }\n\n  export type PostsListRelationFilter = {\n    every?: postsWhereInput\n    some?: postsWhereInput\n    none?: postsWhereInput\n  }\n\n  export type CommentsListRelationFilter = {\n    every?: commentsWhereInput\n    some?: commentsWhereInput\n    none?: commentsWhereInput\n  }\n\n  export type VotesListRelationFilter = {\n    every?: votesWhereInput\n    some?: votesWhereInput\n    none?: votesWhereInput\n  }\n\n  export type SortOrderInput = {\n    sort: SortOrder\n    nulls?: NullsOrder\n  }\n\n  export type postsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type commentsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type votesOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type usersCountOrderByAggregateInput = {\n    id?: SortOrder\n    user_role_id?: SortOrder\n    username?: SortOrder\n    email?: SortOrder\n    bio?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    status?: SortOrder\n  }\n\n  export type usersMaxOrderByAggregateInput = {\n    id?: SortOrder\n    user_role_id?: SortOrder\n    username?: SortOrder\n    email?: SortOrder\n    bio?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    status?: SortOrder\n  }\n\n  export type usersMinOrderByAggregateInput = {\n    id?: SortOrder\n    user_role_id?: SortOrder\n    username?: SortOrder\n    email?: SortOrder\n    bio?: SortOrder\n    password_hash?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    status?: SortOrder\n  }\n\n  export type UuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type UsersListRelationFilter = {\n    every?: usersWhereInput\n    some?: usersWhereInput\n    none?: usersWhereInput\n  }\n\n  export type usersOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type user_rolesCountOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n  }\n\n  export type user_rolesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n  }\n\n  export type user_rolesMinOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n  }\n\n  export type categoriesCountOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type categoriesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type categoriesMinOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    description?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type DateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type UsersScalarRelationFilter = {\n    is?: usersWhereInput\n    isNot?: usersWhereInput\n  }\n\n  export type CategoriesScalarRelationFilter = {\n    is?: categoriesWhereInput\n    isNot?: categoriesWhereInput\n  }\n\n  export type postsCountOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    category_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type postsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    category_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type postsMinOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    category_id?: SortOrder\n    title?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type UuidNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type PostsScalarRelationFilter = {\n    is?: postsWhereInput\n    isNot?: postsWhereInput\n  }\n\n  export type CommentsNullableScalarRelationFilter = {\n    is?: commentsWhereInput | null\n    isNot?: commentsWhereInput | null\n  }\n\n  export type commentsCountOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    parent_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type commentsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    parent_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type commentsMinOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    parent_id?: SortOrder\n    content?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type IntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type PostsNullableScalarRelationFilter = {\n    is?: postsWhereInput | null\n    isNot?: postsWhereInput | null\n  }\n\n  export type votesUser_idPost_idCompoundUniqueInput = {\n    user_id: string\n    post_id: string\n  }\n\n  export type votesUser_idComment_idCompoundUniqueInput = {\n    user_id: string\n    comment_id: string\n  }\n\n  export type votesCountOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    comment_id?: SortOrder\n    value?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type votesAvgOrderByAggregateInput = {\n    value?: SortOrder\n  }\n\n  export type votesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    comment_id?: SortOrder\n    value?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type votesMinOrderByAggregateInput = {\n    id?: SortOrder\n    user_id?: SortOrder\n    post_id?: SortOrder\n    comment_id?: SortOrder\n    value?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type votesSumOrderByAggregateInput = {\n    value?: SortOrder\n  }\n\n  export type IntWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedIntFilter<$PrismaModel>\n    _min?: NestedIntFilter<$PrismaModel>\n    _max?: NestedIntFilter<$PrismaModel>\n  }\n\n  export type user_rolesCreateNestedOneWithoutUsersInput = {\n    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>\n    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput\n    connect?: user_rolesWhereUniqueInput\n  }\n\n  export type postsCreateNestedManyWithoutAuthorInput = {\n    create?: XOR<postsCreateWithoutAuthorInput, postsUncheckedCreateWithoutAuthorInput> | postsCreateWithoutAuthorInput[] | postsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutAuthorInput | postsCreateOrConnectWithoutAuthorInput[]\n    createMany?: postsCreateManyAuthorInputEnvelope\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n  }\n\n  export type commentsCreateNestedManyWithoutAuthorInput = {\n    create?: XOR<commentsCreateWithoutAuthorInput, commentsUncheckedCreateWithoutAuthorInput> | commentsCreateWithoutAuthorInput[] | commentsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutAuthorInput | commentsCreateOrConnectWithoutAuthorInput[]\n    createMany?: commentsCreateManyAuthorInputEnvelope\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n  }\n\n  export type votesCreateNestedManyWithoutUserInput = {\n    create?: XOR<votesCreateWithoutUserInput, votesUncheckedCreateWithoutUserInput> | votesCreateWithoutUserInput[] | votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutUserInput | votesCreateOrConnectWithoutUserInput[]\n    createMany?: votesCreateManyUserInputEnvelope\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n  }\n\n  export type postsUncheckedCreateNestedManyWithoutAuthorInput = {\n    create?: XOR<postsCreateWithoutAuthorInput, postsUncheckedCreateWithoutAuthorInput> | postsCreateWithoutAuthorInput[] | postsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutAuthorInput | postsCreateOrConnectWithoutAuthorInput[]\n    createMany?: postsCreateManyAuthorInputEnvelope\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n  }\n\n  export type commentsUncheckedCreateNestedManyWithoutAuthorInput = {\n    create?: XOR<commentsCreateWithoutAuthorInput, commentsUncheckedCreateWithoutAuthorInput> | commentsCreateWithoutAuthorInput[] | commentsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutAuthorInput | commentsCreateOrConnectWithoutAuthorInput[]\n    createMany?: commentsCreateManyAuthorInputEnvelope\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n  }\n\n  export type votesUncheckedCreateNestedManyWithoutUserInput = {\n    create?: XOR<votesCreateWithoutUserInput, votesUncheckedCreateWithoutUserInput> | votesCreateWithoutUserInput[] | votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutUserInput | votesCreateOrConnectWithoutUserInput[]\n    createMany?: votesCreateManyUserInputEnvelope\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n  }\n\n  export type StringFieldUpdateOperationsInput = {\n    set?: string\n  }\n\n  export type NullableStringFieldUpdateOperationsInput = {\n    set?: string | null\n  }\n\n  export type DateTimeFieldUpdateOperationsInput = {\n    set?: Date | string\n  }\n\n  export type user_rolesUpdateOneRequiredWithoutUsersNestedInput = {\n    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>\n    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput\n    upsert?: user_rolesUpsertWithoutUsersInput\n    connect?: user_rolesWhereUniqueInput\n    update?: XOR<XOR<user_rolesUpdateToOneWithWhereWithoutUsersInput, user_rolesUpdateWithoutUsersInput>, user_rolesUncheckedUpdateWithoutUsersInput>\n  }\n\n  export type postsUpdateManyWithoutAuthorNestedInput = {\n    create?: XOR<postsCreateWithoutAuthorInput, postsUncheckedCreateWithoutAuthorInput> | postsCreateWithoutAuthorInput[] | postsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutAuthorInput | postsCreateOrConnectWithoutAuthorInput[]\n    upsert?: postsUpsertWithWhereUniqueWithoutAuthorInput | postsUpsertWithWhereUniqueWithoutAuthorInput[]\n    createMany?: postsCreateManyAuthorInputEnvelope\n    set?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    update?: postsUpdateWithWhereUniqueWithoutAuthorInput | postsUpdateWithWhereUniqueWithoutAuthorInput[]\n    updateMany?: postsUpdateManyWithWhereWithoutAuthorInput | postsUpdateManyWithWhereWithoutAuthorInput[]\n    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]\n  }\n\n  export type commentsUpdateManyWithoutAuthorNestedInput = {\n    create?: XOR<commentsCreateWithoutAuthorInput, commentsUncheckedCreateWithoutAuthorInput> | commentsCreateWithoutAuthorInput[] | commentsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutAuthorInput | commentsCreateOrConnectWithoutAuthorInput[]\n    upsert?: commentsUpsertWithWhereUniqueWithoutAuthorInput | commentsUpsertWithWhereUniqueWithoutAuthorInput[]\n    createMany?: commentsCreateManyAuthorInputEnvelope\n    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    update?: commentsUpdateWithWhereUniqueWithoutAuthorInput | commentsUpdateWithWhereUniqueWithoutAuthorInput[]\n    updateMany?: commentsUpdateManyWithWhereWithoutAuthorInput | commentsUpdateManyWithWhereWithoutAuthorInput[]\n    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]\n  }\n\n  export type votesUpdateManyWithoutUserNestedInput = {\n    create?: XOR<votesCreateWithoutUserInput, votesUncheckedCreateWithoutUserInput> | votesCreateWithoutUserInput[] | votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutUserInput | votesCreateOrConnectWithoutUserInput[]\n    upsert?: votesUpsertWithWhereUniqueWithoutUserInput | votesUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: votesCreateManyUserInputEnvelope\n    set?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    update?: votesUpdateWithWhereUniqueWithoutUserInput | votesUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: votesUpdateManyWithWhereWithoutUserInput | votesUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]\n  }\n\n  export type postsUncheckedUpdateManyWithoutAuthorNestedInput = {\n    create?: XOR<postsCreateWithoutAuthorInput, postsUncheckedCreateWithoutAuthorInput> | postsCreateWithoutAuthorInput[] | postsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutAuthorInput | postsCreateOrConnectWithoutAuthorInput[]\n    upsert?: postsUpsertWithWhereUniqueWithoutAuthorInput | postsUpsertWithWhereUniqueWithoutAuthorInput[]\n    createMany?: postsCreateManyAuthorInputEnvelope\n    set?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    update?: postsUpdateWithWhereUniqueWithoutAuthorInput | postsUpdateWithWhereUniqueWithoutAuthorInput[]\n    updateMany?: postsUpdateManyWithWhereWithoutAuthorInput | postsUpdateManyWithWhereWithoutAuthorInput[]\n    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]\n  }\n\n  export type commentsUncheckedUpdateManyWithoutAuthorNestedInput = {\n    create?: XOR<commentsCreateWithoutAuthorInput, commentsUncheckedCreateWithoutAuthorInput> | commentsCreateWithoutAuthorInput[] | commentsUncheckedCreateWithoutAuthorInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutAuthorInput | commentsCreateOrConnectWithoutAuthorInput[]\n    upsert?: commentsUpsertWithWhereUniqueWithoutAuthorInput | commentsUpsertWithWhereUniqueWithoutAuthorInput[]\n    createMany?: commentsCreateManyAuthorInputEnvelope\n    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    update?: commentsUpdateWithWhereUniqueWithoutAuthorInput | commentsUpdateWithWhereUniqueWithoutAuthorInput[]\n    updateMany?: commentsUpdateManyWithWhereWithoutAuthorInput | commentsUpdateManyWithWhereWithoutAuthorInput[]\n    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]\n  }\n\n  export type votesUncheckedUpdateManyWithoutUserNestedInput = {\n    create?: XOR<votesCreateWithoutUserInput, votesUncheckedCreateWithoutUserInput> | votesCreateWithoutUserInput[] | votesUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutUserInput | votesCreateOrConnectWithoutUserInput[]\n    upsert?: votesUpsertWithWhereUniqueWithoutUserInput | votesUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: votesCreateManyUserInputEnvelope\n    set?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    update?: votesUpdateWithWhereUniqueWithoutUserInput | votesUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: votesUpdateManyWithWhereWithoutUserInput | votesUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]\n  }\n\n  export type usersCreateNestedManyWithoutRoleInput = {\n    create?: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput> | usersCreateWithoutRoleInput[] | usersUncheckedCreateWithoutRoleInput[]\n    connectOrCreate?: usersCreateOrConnectWithoutRoleInput | usersCreateOrConnectWithoutRoleInput[]\n    createMany?: usersCreateManyRoleInputEnvelope\n    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]\n  }\n\n  export type usersUncheckedCreateNestedManyWithoutRoleInput = {\n    create?: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput> | usersCreateWithoutRoleInput[] | usersUncheckedCreateWithoutRoleInput[]\n    connectOrCreate?: usersCreateOrConnectWithoutRoleInput | usersCreateOrConnectWithoutRoleInput[]\n    createMany?: usersCreateManyRoleInputEnvelope\n    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]\n  }\n\n  export type usersUpdateManyWithoutRoleNestedInput = {\n    create?: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput> | usersCreateWithoutRoleInput[] | usersUncheckedCreateWithoutRoleInput[]\n    connectOrCreate?: usersCreateOrConnectWithoutRoleInput | usersCreateOrConnectWithoutRoleInput[]\n    upsert?: usersUpsertWithWhereUniqueWithoutRoleInput | usersUpsertWithWhereUniqueWithoutRoleInput[]\n    createMany?: usersCreateManyRoleInputEnvelope\n    set?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    update?: usersUpdateWithWhereUniqueWithoutRoleInput | usersUpdateWithWhereUniqueWithoutRoleInput[]\n    updateMany?: usersUpdateManyWithWhereWithoutRoleInput | usersUpdateManyWithWhereWithoutRoleInput[]\n    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]\n  }\n\n  export type usersUncheckedUpdateManyWithoutRoleNestedInput = {\n    create?: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput> | usersCreateWithoutRoleInput[] | usersUncheckedCreateWithoutRoleInput[]\n    connectOrCreate?: usersCreateOrConnectWithoutRoleInput | usersCreateOrConnectWithoutRoleInput[]\n    upsert?: usersUpsertWithWhereUniqueWithoutRoleInput | usersUpsertWithWhereUniqueWithoutRoleInput[]\n    createMany?: usersCreateManyRoleInputEnvelope\n    set?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]\n    update?: usersUpdateWithWhereUniqueWithoutRoleInput | usersUpdateWithWhereUniqueWithoutRoleInput[]\n    updateMany?: usersUpdateManyWithWhereWithoutRoleInput | usersUpdateManyWithWhereWithoutRoleInput[]\n    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]\n  }\n\n  export type postsCreateNestedManyWithoutCategoryInput = {\n    create?: XOR<postsCreateWithoutCategoryInput, postsUncheckedCreateWithoutCategoryInput> | postsCreateWithoutCategoryInput[] | postsUncheckedCreateWithoutCategoryInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutCategoryInput | postsCreateOrConnectWithoutCategoryInput[]\n    createMany?: postsCreateManyCategoryInputEnvelope\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n  }\n\n  export type postsUncheckedCreateNestedManyWithoutCategoryInput = {\n    create?: XOR<postsCreateWithoutCategoryInput, postsUncheckedCreateWithoutCategoryInput> | postsCreateWithoutCategoryInput[] | postsUncheckedCreateWithoutCategoryInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutCategoryInput | postsCreateOrConnectWithoutCategoryInput[]\n    createMany?: postsCreateManyCategoryInputEnvelope\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n  }\n\n  export type postsUpdateManyWithoutCategoryNestedInput = {\n    create?: XOR<postsCreateWithoutCategoryInput, postsUncheckedCreateWithoutCategoryInput> | postsCreateWithoutCategoryInput[] | postsUncheckedCreateWithoutCategoryInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutCategoryInput | postsCreateOrConnectWithoutCategoryInput[]\n    upsert?: postsUpsertWithWhereUniqueWithoutCategoryInput | postsUpsertWithWhereUniqueWithoutCategoryInput[]\n    createMany?: postsCreateManyCategoryInputEnvelope\n    set?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    update?: postsUpdateWithWhereUniqueWithoutCategoryInput | postsUpdateWithWhereUniqueWithoutCategoryInput[]\n    updateMany?: postsUpdateManyWithWhereWithoutCategoryInput | postsUpdateManyWithWhereWithoutCategoryInput[]\n    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]\n  }\n\n  export type postsUncheckedUpdateManyWithoutCategoryNestedInput = {\n    create?: XOR<postsCreateWithoutCategoryInput, postsUncheckedCreateWithoutCategoryInput> | postsCreateWithoutCategoryInput[] | postsUncheckedCreateWithoutCategoryInput[]\n    connectOrCreate?: postsCreateOrConnectWithoutCategoryInput | postsCreateOrConnectWithoutCategoryInput[]\n    upsert?: postsUpsertWithWhereUniqueWithoutCategoryInput | postsUpsertWithWhereUniqueWithoutCategoryInput[]\n    createMany?: postsCreateManyCategoryInputEnvelope\n    set?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]\n    update?: postsUpdateWithWhereUniqueWithoutCategoryInput | postsUpdateWithWhereUniqueWithoutCategoryInput[]\n    updateMany?: postsUpdateManyWithWhereWithoutCategoryInput | postsUpdateManyWithWhereWithoutCategoryInput[]\n    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]\n  }\n\n  export type usersCreateNestedOneWithoutPostsInput = {\n    create?: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>\n    connectOrCreate?: usersCreateOrConnectWithoutPostsInput\n    connect?: usersWhereUniqueInput\n  }\n\n  export type categoriesCreateNestedOneWithoutPostsInput = {\n    create?: XOR<categoriesCreateWithoutPostsInput, categoriesUncheckedCreateWithoutPostsInput>\n    connectOrCreate?: categoriesCreateOrConnectWithoutPostsInput\n    connect?: categoriesWhereUniqueInput\n  }\n\n  export type commentsCreateNestedManyWithoutPostInput = {\n    create?: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput> | commentsCreateWithoutPostInput[] | commentsUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutPostInput | commentsCreateOrConnectWithoutPostInput[]\n    createMany?: commentsCreateManyPostInputEnvelope\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n  }\n\n  export type votesCreateNestedManyWithoutPostInput = {\n    create?: XOR<votesCreateWithoutPostInput, votesUncheckedCreateWithoutPostInput> | votesCreateWithoutPostInput[] | votesUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutPostInput | votesCreateOrConnectWithoutPostInput[]\n    createMany?: votesCreateManyPostInputEnvelope\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n  }\n\n  export type commentsUncheckedCreateNestedManyWithoutPostInput = {\n    create?: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput> | commentsCreateWithoutPostInput[] | commentsUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutPostInput | commentsCreateOrConnectWithoutPostInput[]\n    createMany?: commentsCreateManyPostInputEnvelope\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n  }\n\n  export type votesUncheckedCreateNestedManyWithoutPostInput = {\n    create?: XOR<votesCreateWithoutPostInput, votesUncheckedCreateWithoutPostInput> | votesCreateWithoutPostInput[] | votesUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutPostInput | votesCreateOrConnectWithoutPostInput[]\n    createMany?: votesCreateManyPostInputEnvelope\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n  }\n\n  export type NullableDateTimeFieldUpdateOperationsInput = {\n    set?: Date | string | null\n  }\n\n  export type usersUpdateOneRequiredWithoutPostsNestedInput = {\n    create?: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>\n    connectOrCreate?: usersCreateOrConnectWithoutPostsInput\n    upsert?: usersUpsertWithoutPostsInput\n    connect?: usersWhereUniqueInput\n    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPostsInput, usersUpdateWithoutPostsInput>, usersUncheckedUpdateWithoutPostsInput>\n  }\n\n  export type categoriesUpdateOneRequiredWithoutPostsNestedInput = {\n    create?: XOR<categoriesCreateWithoutPostsInput, categoriesUncheckedCreateWithoutPostsInput>\n    connectOrCreate?: categoriesCreateOrConnectWithoutPostsInput\n    upsert?: categoriesUpsertWithoutPostsInput\n    connect?: categoriesWhereUniqueInput\n    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutPostsInput, categoriesUpdateWithoutPostsInput>, categoriesUncheckedUpdateWithoutPostsInput>\n  }\n\n  export type commentsUpdateManyWithoutPostNestedInput = {\n    create?: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput> | commentsCreateWithoutPostInput[] | commentsUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutPostInput | commentsCreateOrConnectWithoutPostInput[]\n    upsert?: commentsUpsertWithWhereUniqueWithoutPostInput | commentsUpsertWithWhereUniqueWithoutPostInput[]\n    createMany?: commentsCreateManyPostInputEnvelope\n    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    update?: commentsUpdateWithWhereUniqueWithoutPostInput | commentsUpdateWithWhereUniqueWithoutPostInput[]\n    updateMany?: commentsUpdateManyWithWhereWithoutPostInput | commentsUpdateManyWithWhereWithoutPostInput[]\n    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]\n  }\n\n  export type votesUpdateManyWithoutPostNestedInput = {\n    create?: XOR<votesCreateWithoutPostInput, votesUncheckedCreateWithoutPostInput> | votesCreateWithoutPostInput[] | votesUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutPostInput | votesCreateOrConnectWithoutPostInput[]\n    upsert?: votesUpsertWithWhereUniqueWithoutPostInput | votesUpsertWithWhereUniqueWithoutPostInput[]\n    createMany?: votesCreateManyPostInputEnvelope\n    set?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    update?: votesUpdateWithWhereUniqueWithoutPostInput | votesUpdateWithWhereUniqueWithoutPostInput[]\n    updateMany?: votesUpdateManyWithWhereWithoutPostInput | votesUpdateManyWithWhereWithoutPostInput[]\n    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]\n  }\n\n  export type commentsUncheckedUpdateManyWithoutPostNestedInput = {\n    create?: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput> | commentsCreateWithoutPostInput[] | commentsUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutPostInput | commentsCreateOrConnectWithoutPostInput[]\n    upsert?: commentsUpsertWithWhereUniqueWithoutPostInput | commentsUpsertWithWhereUniqueWithoutPostInput[]\n    createMany?: commentsCreateManyPostInputEnvelope\n    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    update?: commentsUpdateWithWhereUniqueWithoutPostInput | commentsUpdateWithWhereUniqueWithoutPostInput[]\n    updateMany?: commentsUpdateManyWithWhereWithoutPostInput | commentsUpdateManyWithWhereWithoutPostInput[]\n    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]\n  }\n\n  export type votesUncheckedUpdateManyWithoutPostNestedInput = {\n    create?: XOR<votesCreateWithoutPostInput, votesUncheckedCreateWithoutPostInput> | votesCreateWithoutPostInput[] | votesUncheckedCreateWithoutPostInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutPostInput | votesCreateOrConnectWithoutPostInput[]\n    upsert?: votesUpsertWithWhereUniqueWithoutPostInput | votesUpsertWithWhereUniqueWithoutPostInput[]\n    createMany?: votesCreateManyPostInputEnvelope\n    set?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    update?: votesUpdateWithWhereUniqueWithoutPostInput | votesUpdateWithWhereUniqueWithoutPostInput[]\n    updateMany?: votesUpdateManyWithWhereWithoutPostInput | votesUpdateManyWithWhereWithoutPostInput[]\n    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]\n  }\n\n  export type usersCreateNestedOneWithoutCommentsInput = {\n    create?: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>\n    connectOrCreate?: usersCreateOrConnectWithoutCommentsInput\n    connect?: usersWhereUniqueInput\n  }\n\n  export type postsCreateNestedOneWithoutCommentsInput = {\n    create?: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>\n    connectOrCreate?: postsCreateOrConnectWithoutCommentsInput\n    connect?: postsWhereUniqueInput\n  }\n\n  export type commentsCreateNestedOneWithoutRecursiveInput = {\n    create?: XOR<commentsCreateWithoutRecursiveInput, commentsUncheckedCreateWithoutRecursiveInput>\n    connectOrCreate?: commentsCreateOrConnectWithoutRecursiveInput\n    connect?: commentsWhereUniqueInput\n  }\n\n  export type commentsCreateNestedManyWithoutParentInput = {\n    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]\n    createMany?: commentsCreateManyParentInputEnvelope\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n  }\n\n  export type votesCreateNestedManyWithoutCommentInput = {\n    create?: XOR<votesCreateWithoutCommentInput, votesUncheckedCreateWithoutCommentInput> | votesCreateWithoutCommentInput[] | votesUncheckedCreateWithoutCommentInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutCommentInput | votesCreateOrConnectWithoutCommentInput[]\n    createMany?: votesCreateManyCommentInputEnvelope\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n  }\n\n  export type commentsUncheckedCreateNestedManyWithoutParentInput = {\n    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]\n    createMany?: commentsCreateManyParentInputEnvelope\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n  }\n\n  export type votesUncheckedCreateNestedManyWithoutCommentInput = {\n    create?: XOR<votesCreateWithoutCommentInput, votesUncheckedCreateWithoutCommentInput> | votesCreateWithoutCommentInput[] | votesUncheckedCreateWithoutCommentInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutCommentInput | votesCreateOrConnectWithoutCommentInput[]\n    createMany?: votesCreateManyCommentInputEnvelope\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n  }\n\n  export type usersUpdateOneRequiredWithoutCommentsNestedInput = {\n    create?: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>\n    connectOrCreate?: usersCreateOrConnectWithoutCommentsInput\n    upsert?: usersUpsertWithoutCommentsInput\n    connect?: usersWhereUniqueInput\n    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCommentsInput, usersUpdateWithoutCommentsInput>, usersUncheckedUpdateWithoutCommentsInput>\n  }\n\n  export type postsUpdateOneRequiredWithoutCommentsNestedInput = {\n    create?: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>\n    connectOrCreate?: postsCreateOrConnectWithoutCommentsInput\n    upsert?: postsUpsertWithoutCommentsInput\n    connect?: postsWhereUniqueInput\n    update?: XOR<XOR<postsUpdateToOneWithWhereWithoutCommentsInput, postsUpdateWithoutCommentsInput>, postsUncheckedUpdateWithoutCommentsInput>\n  }\n\n  export type commentsUpdateOneWithoutRecursiveNestedInput = {\n    create?: XOR<commentsCreateWithoutRecursiveInput, commentsUncheckedCreateWithoutRecursiveInput>\n    connectOrCreate?: commentsCreateOrConnectWithoutRecursiveInput\n    upsert?: commentsUpsertWithoutRecursiveInput\n    disconnect?: commentsWhereInput | boolean\n    delete?: commentsWhereInput | boolean\n    connect?: commentsWhereUniqueInput\n    update?: XOR<XOR<commentsUpdateToOneWithWhereWithoutRecursiveInput, commentsUpdateWithoutRecursiveInput>, commentsUncheckedUpdateWithoutRecursiveInput>\n  }\n\n  export type commentsUpdateManyWithoutParentNestedInput = {\n    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]\n    upsert?: commentsUpsertWithWhereUniqueWithoutParentInput | commentsUpsertWithWhereUniqueWithoutParentInput[]\n    createMany?: commentsCreateManyParentInputEnvelope\n    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    update?: commentsUpdateWithWhereUniqueWithoutParentInput | commentsUpdateWithWhereUniqueWithoutParentInput[]\n    updateMany?: commentsUpdateManyWithWhereWithoutParentInput | commentsUpdateManyWithWhereWithoutParentInput[]\n    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]\n  }\n\n  export type votesUpdateManyWithoutCommentNestedInput = {\n    create?: XOR<votesCreateWithoutCommentInput, votesUncheckedCreateWithoutCommentInput> | votesCreateWithoutCommentInput[] | votesUncheckedCreateWithoutCommentInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutCommentInput | votesCreateOrConnectWithoutCommentInput[]\n    upsert?: votesUpsertWithWhereUniqueWithoutCommentInput | votesUpsertWithWhereUniqueWithoutCommentInput[]\n    createMany?: votesCreateManyCommentInputEnvelope\n    set?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    update?: votesUpdateWithWhereUniqueWithoutCommentInput | votesUpdateWithWhereUniqueWithoutCommentInput[]\n    updateMany?: votesUpdateManyWithWhereWithoutCommentInput | votesUpdateManyWithWhereWithoutCommentInput[]\n    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]\n  }\n\n  export type commentsUncheckedUpdateManyWithoutParentNestedInput = {\n    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]\n    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]\n    upsert?: commentsUpsertWithWhereUniqueWithoutParentInput | commentsUpsertWithWhereUniqueWithoutParentInput[]\n    createMany?: commentsCreateManyParentInputEnvelope\n    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]\n    update?: commentsUpdateWithWhereUniqueWithoutParentInput | commentsUpdateWithWhereUniqueWithoutParentInput[]\n    updateMany?: commentsUpdateManyWithWhereWithoutParentInput | commentsUpdateManyWithWhereWithoutParentInput[]\n    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]\n  }\n\n  export type votesUncheckedUpdateManyWithoutCommentNestedInput = {\n    create?: XOR<votesCreateWithoutCommentInput, votesUncheckedCreateWithoutCommentInput> | votesCreateWithoutCommentInput[] | votesUncheckedCreateWithoutCommentInput[]\n    connectOrCreate?: votesCreateOrConnectWithoutCommentInput | votesCreateOrConnectWithoutCommentInput[]\n    upsert?: votesUpsertWithWhereUniqueWithoutCommentInput | votesUpsertWithWhereUniqueWithoutCommentInput[]\n    createMany?: votesCreateManyCommentInputEnvelope\n    set?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    disconnect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    delete?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    connect?: votesWhereUniqueInput | votesWhereUniqueInput[]\n    update?: votesUpdateWithWhereUniqueWithoutCommentInput | votesUpdateWithWhereUniqueWithoutCommentInput[]\n    updateMany?: votesUpdateManyWithWhereWithoutCommentInput | votesUpdateManyWithWhereWithoutCommentInput[]\n    deleteMany?: votesScalarWhereInput | votesScalarWhereInput[]\n  }\n\n  export type usersCreateNestedOneWithoutVotesInput = {\n    create?: XOR<usersCreateWithoutVotesInput, usersUncheckedCreateWithoutVotesInput>\n    connectOrCreate?: usersCreateOrConnectWithoutVotesInput\n    connect?: usersWhereUniqueInput\n  }\n\n  export type postsCreateNestedOneWithoutVotesInput = {\n    create?: XOR<postsCreateWithoutVotesInput, postsUncheckedCreateWithoutVotesInput>\n    connectOrCreate?: postsCreateOrConnectWithoutVotesInput\n    connect?: postsWhereUniqueInput\n  }\n\n  export type commentsCreateNestedOneWithoutVotesInput = {\n    create?: XOR<commentsCreateWithoutVotesInput, commentsUncheckedCreateWithoutVotesInput>\n    connectOrCreate?: commentsCreateOrConnectWithoutVotesInput\n    connect?: commentsWhereUniqueInput\n  }\n\n  export type IntFieldUpdateOperationsInput = {\n    set?: number\n    increment?: number\n    decrement?: number\n    multiply?: number\n    divide?: number\n  }\n\n  export type usersUpdateOneRequiredWithoutVotesNestedInput = {\n    create?: XOR<usersCreateWithoutVotesInput, usersUncheckedCreateWithoutVotesInput>\n    connectOrCreate?: usersCreateOrConnectWithoutVotesInput\n    upsert?: usersUpsertWithoutVotesInput\n    connect?: usersWhereUniqueInput\n    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutVotesInput, usersUpdateWithoutVotesInput>, usersUncheckedUpdateWithoutVotesInput>\n  }\n\n  export type postsUpdateOneWithoutVotesNestedInput = {\n    create?: XOR<postsCreateWithoutVotesInput, postsUncheckedCreateWithoutVotesInput>\n    connectOrCreate?: postsCreateOrConnectWithoutVotesInput\n    upsert?: postsUpsertWithoutVotesInput\n    disconnect?: postsWhereInput | boolean\n    delete?: postsWhereInput | boolean\n    connect?: postsWhereUniqueInput\n    update?: XOR<XOR<postsUpdateToOneWithWhereWithoutVotesInput, postsUpdateWithoutVotesInput>, postsUncheckedUpdateWithoutVotesInput>\n  }\n\n  export type commentsUpdateOneWithoutVotesNestedInput = {\n    create?: XOR<commentsCreateWithoutVotesInput, commentsUncheckedCreateWithoutVotesInput>\n    connectOrCreate?: commentsCreateOrConnectWithoutVotesInput\n    upsert?: commentsUpsertWithoutVotesInput\n    disconnect?: commentsWhereInput | boolean\n    delete?: commentsWhereInput | boolean\n    connect?: commentsWhereUniqueInput\n    update?: XOR<XOR<commentsUpdateToOneWithWhereWithoutVotesInput, commentsUpdateWithoutVotesInput>, commentsUncheckedUpdateWithoutVotesInput>\n  }\n\n  export type NestedUuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedDateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedIntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type NestedIntNullableFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type NestedUuidNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedIntFilter<$PrismaModel>\n    _min?: NestedIntFilter<$PrismaModel>\n    _max?: NestedIntFilter<$PrismaModel>\n  }\n\n  export type NestedFloatFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel>\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatFilter<$PrismaModel> | number\n  }\n\n  export type user_rolesCreateWithoutUsersInput = {\n    id: string\n    name: string\n    description: string\n  }\n\n  export type user_rolesUncheckedCreateWithoutUsersInput = {\n    id: string\n    name: string\n    description: string\n  }\n\n  export type user_rolesCreateOrConnectWithoutUsersInput = {\n    where: user_rolesWhereUniqueInput\n    create: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>\n  }\n\n  export type postsCreateWithoutAuthorInput = {\n    id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    category: categoriesCreateNestedOneWithoutPostsInput\n    comments?: commentsCreateNestedManyWithoutPostInput\n    votes?: votesCreateNestedManyWithoutPostInput\n  }\n\n  export type postsUncheckedCreateWithoutAuthorInput = {\n    id: string\n    category_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    comments?: commentsUncheckedCreateNestedManyWithoutPostInput\n    votes?: votesUncheckedCreateNestedManyWithoutPostInput\n  }\n\n  export type postsCreateOrConnectWithoutAuthorInput = {\n    where: postsWhereUniqueInput\n    create: XOR<postsCreateWithoutAuthorInput, postsUncheckedCreateWithoutAuthorInput>\n  }\n\n  export type postsCreateManyAuthorInputEnvelope = {\n    data: postsCreateManyAuthorInput | postsCreateManyAuthorInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type commentsCreateWithoutAuthorInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    post: postsCreateNestedOneWithoutCommentsInput\n    parent?: commentsCreateNestedOneWithoutRecursiveInput\n    recursive?: commentsCreateNestedManyWithoutParentInput\n    votes?: votesCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsUncheckedCreateWithoutAuthorInput = {\n    id: string\n    post_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    recursive?: commentsUncheckedCreateNestedManyWithoutParentInput\n    votes?: votesUncheckedCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsCreateOrConnectWithoutAuthorInput = {\n    where: commentsWhereUniqueInput\n    create: XOR<commentsCreateWithoutAuthorInput, commentsUncheckedCreateWithoutAuthorInput>\n  }\n\n  export type commentsCreateManyAuthorInputEnvelope = {\n    data: commentsCreateManyAuthorInput | commentsCreateManyAuthorInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type votesCreateWithoutUserInput = {\n    id: string\n    value: number\n    created_at: Date | string\n    post?: postsCreateNestedOneWithoutVotesInput\n    comment?: commentsCreateNestedOneWithoutVotesInput\n  }\n\n  export type votesUncheckedCreateWithoutUserInput = {\n    id: string\n    post_id?: string | null\n    comment_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type votesCreateOrConnectWithoutUserInput = {\n    where: votesWhereUniqueInput\n    create: XOR<votesCreateWithoutUserInput, votesUncheckedCreateWithoutUserInput>\n  }\n\n  export type votesCreateManyUserInputEnvelope = {\n    data: votesCreateManyUserInput | votesCreateManyUserInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type user_rolesUpsertWithoutUsersInput = {\n    update: XOR<user_rolesUpdateWithoutUsersInput, user_rolesUncheckedUpdateWithoutUsersInput>\n    create: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>\n    where?: user_rolesWhereInput\n  }\n\n  export type user_rolesUpdateToOneWithWhereWithoutUsersInput = {\n    where?: user_rolesWhereInput\n    data: XOR<user_rolesUpdateWithoutUsersInput, user_rolesUncheckedUpdateWithoutUsersInput>\n  }\n\n  export type user_rolesUpdateWithoutUsersInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type user_rolesUncheckedUpdateWithoutUsersInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type postsUpsertWithWhereUniqueWithoutAuthorInput = {\n    where: postsWhereUniqueInput\n    update: XOR<postsUpdateWithoutAuthorInput, postsUncheckedUpdateWithoutAuthorInput>\n    create: XOR<postsCreateWithoutAuthorInput, postsUncheckedCreateWithoutAuthorInput>\n  }\n\n  export type postsUpdateWithWhereUniqueWithoutAuthorInput = {\n    where: postsWhereUniqueInput\n    data: XOR<postsUpdateWithoutAuthorInput, postsUncheckedUpdateWithoutAuthorInput>\n  }\n\n  export type postsUpdateManyWithWhereWithoutAuthorInput = {\n    where: postsScalarWhereInput\n    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyWithoutAuthorInput>\n  }\n\n  export type postsScalarWhereInput = {\n    AND?: postsScalarWhereInput | postsScalarWhereInput[]\n    OR?: postsScalarWhereInput[]\n    NOT?: postsScalarWhereInput | postsScalarWhereInput[]\n    id?: UuidFilter<\"posts\"> | string\n    user_id?: UuidFilter<\"posts\"> | string\n    category_id?: UuidFilter<\"posts\"> | string\n    title?: StringFilter<\"posts\"> | string\n    content?: StringFilter<\"posts\"> | string\n    created_at?: DateTimeFilter<\"posts\"> | Date | string\n    updated_at?: DateTimeFilter<\"posts\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"posts\"> | Date | string | null\n  }\n\n  export type commentsUpsertWithWhereUniqueWithoutAuthorInput = {\n    where: commentsWhereUniqueInput\n    update: XOR<commentsUpdateWithoutAuthorInput, commentsUncheckedUpdateWithoutAuthorInput>\n    create: XOR<commentsCreateWithoutAuthorInput, commentsUncheckedCreateWithoutAuthorInput>\n  }\n\n  export type commentsUpdateWithWhereUniqueWithoutAuthorInput = {\n    where: commentsWhereUniqueInput\n    data: XOR<commentsUpdateWithoutAuthorInput, commentsUncheckedUpdateWithoutAuthorInput>\n  }\n\n  export type commentsUpdateManyWithWhereWithoutAuthorInput = {\n    where: commentsScalarWhereInput\n    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutAuthorInput>\n  }\n\n  export type commentsScalarWhereInput = {\n    AND?: commentsScalarWhereInput | commentsScalarWhereInput[]\n    OR?: commentsScalarWhereInput[]\n    NOT?: commentsScalarWhereInput | commentsScalarWhereInput[]\n    id?: UuidFilter<\"comments\"> | string\n    user_id?: UuidFilter<\"comments\"> | string\n    post_id?: UuidFilter<\"comments\"> | string\n    parent_id?: UuidNullableFilter<\"comments\"> | string | null\n    content?: StringFilter<\"comments\"> | string\n    created_at?: DateTimeFilter<\"comments\"> | Date | string\n    updated_at?: DateTimeFilter<\"comments\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"comments\"> | Date | string | null\n  }\n\n  export type votesUpsertWithWhereUniqueWithoutUserInput = {\n    where: votesWhereUniqueInput\n    update: XOR<votesUpdateWithoutUserInput, votesUncheckedUpdateWithoutUserInput>\n    create: XOR<votesCreateWithoutUserInput, votesUncheckedCreateWithoutUserInput>\n  }\n\n  export type votesUpdateWithWhereUniqueWithoutUserInput = {\n    where: votesWhereUniqueInput\n    data: XOR<votesUpdateWithoutUserInput, votesUncheckedUpdateWithoutUserInput>\n  }\n\n  export type votesUpdateManyWithWhereWithoutUserInput = {\n    where: votesScalarWhereInput\n    data: XOR<votesUpdateManyMutationInput, votesUncheckedUpdateManyWithoutUserInput>\n  }\n\n  export type votesScalarWhereInput = {\n    AND?: votesScalarWhereInput | votesScalarWhereInput[]\n    OR?: votesScalarWhereInput[]\n    NOT?: votesScalarWhereInput | votesScalarWhereInput[]\n    id?: UuidFilter<\"votes\"> | string\n    user_id?: UuidFilter<\"votes\"> | string\n    post_id?: UuidNullableFilter<\"votes\"> | string | null\n    comment_id?: UuidNullableFilter<\"votes\"> | string | null\n    value?: IntFilter<\"votes\"> | number\n    created_at?: DateTimeFilter<\"votes\"> | Date | string\n  }\n\n  export type usersCreateWithoutRoleInput = {\n    id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    posts?: postsCreateNestedManyWithoutAuthorInput\n    comments?: commentsCreateNestedManyWithoutAuthorInput\n    votes?: votesCreateNestedManyWithoutUserInput\n  }\n\n  export type usersUncheckedCreateWithoutRoleInput = {\n    id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    posts?: postsUncheckedCreateNestedManyWithoutAuthorInput\n    comments?: commentsUncheckedCreateNestedManyWithoutAuthorInput\n    votes?: votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type usersCreateOrConnectWithoutRoleInput = {\n    where: usersWhereUniqueInput\n    create: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput>\n  }\n\n  export type usersCreateManyRoleInputEnvelope = {\n    data: usersCreateManyRoleInput | usersCreateManyRoleInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type usersUpsertWithWhereUniqueWithoutRoleInput = {\n    where: usersWhereUniqueInput\n    update: XOR<usersUpdateWithoutRoleInput, usersUncheckedUpdateWithoutRoleInput>\n    create: XOR<usersCreateWithoutRoleInput, usersUncheckedCreateWithoutRoleInput>\n  }\n\n  export type usersUpdateWithWhereUniqueWithoutRoleInput = {\n    where: usersWhereUniqueInput\n    data: XOR<usersUpdateWithoutRoleInput, usersUncheckedUpdateWithoutRoleInput>\n  }\n\n  export type usersUpdateManyWithWhereWithoutRoleInput = {\n    where: usersScalarWhereInput\n    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutRoleInput>\n  }\n\n  export type usersScalarWhereInput = {\n    AND?: usersScalarWhereInput | usersScalarWhereInput[]\n    OR?: usersScalarWhereInput[]\n    NOT?: usersScalarWhereInput | usersScalarWhereInput[]\n    id?: UuidFilter<\"users\"> | string\n    user_role_id?: UuidFilter<\"users\"> | string\n    username?: StringFilter<\"users\"> | string\n    email?: StringFilter<\"users\"> | string\n    bio?: StringNullableFilter<\"users\"> | string | null\n    password_hash?: StringFilter<\"users\"> | string\n    created_at?: DateTimeFilter<\"users\"> | Date | string\n    updated_at?: DateTimeFilter<\"users\"> | Date | string\n    status?: StringFilter<\"users\"> | string\n  }\n\n  export type postsCreateWithoutCategoryInput = {\n    id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutPostsInput\n    comments?: commentsCreateNestedManyWithoutPostInput\n    votes?: votesCreateNestedManyWithoutPostInput\n  }\n\n  export type postsUncheckedCreateWithoutCategoryInput = {\n    id: string\n    user_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    comments?: commentsUncheckedCreateNestedManyWithoutPostInput\n    votes?: votesUncheckedCreateNestedManyWithoutPostInput\n  }\n\n  export type postsCreateOrConnectWithoutCategoryInput = {\n    where: postsWhereUniqueInput\n    create: XOR<postsCreateWithoutCategoryInput, postsUncheckedCreateWithoutCategoryInput>\n  }\n\n  export type postsCreateManyCategoryInputEnvelope = {\n    data: postsCreateManyCategoryInput | postsCreateManyCategoryInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type postsUpsertWithWhereUniqueWithoutCategoryInput = {\n    where: postsWhereUniqueInput\n    update: XOR<postsUpdateWithoutCategoryInput, postsUncheckedUpdateWithoutCategoryInput>\n    create: XOR<postsCreateWithoutCategoryInput, postsUncheckedCreateWithoutCategoryInput>\n  }\n\n  export type postsUpdateWithWhereUniqueWithoutCategoryInput = {\n    where: postsWhereUniqueInput\n    data: XOR<postsUpdateWithoutCategoryInput, postsUncheckedUpdateWithoutCategoryInput>\n  }\n\n  export type postsUpdateManyWithWhereWithoutCategoryInput = {\n    where: postsScalarWhereInput\n    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyWithoutCategoryInput>\n  }\n\n  export type usersCreateWithoutPostsInput = {\n    id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    role: user_rolesCreateNestedOneWithoutUsersInput\n    comments?: commentsCreateNestedManyWithoutAuthorInput\n    votes?: votesCreateNestedManyWithoutUserInput\n  }\n\n  export type usersUncheckedCreateWithoutPostsInput = {\n    id: string\n    user_role_id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    comments?: commentsUncheckedCreateNestedManyWithoutAuthorInput\n    votes?: votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type usersCreateOrConnectWithoutPostsInput = {\n    where: usersWhereUniqueInput\n    create: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>\n  }\n\n  export type categoriesCreateWithoutPostsInput = {\n    id: string\n    name: string\n    description: string\n    created_at: Date | string\n  }\n\n  export type categoriesUncheckedCreateWithoutPostsInput = {\n    id: string\n    name: string\n    description: string\n    created_at: Date | string\n  }\n\n  export type categoriesCreateOrConnectWithoutPostsInput = {\n    where: categoriesWhereUniqueInput\n    create: XOR<categoriesCreateWithoutPostsInput, categoriesUncheckedCreateWithoutPostsInput>\n  }\n\n  export type commentsCreateWithoutPostInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutCommentsInput\n    parent?: commentsCreateNestedOneWithoutRecursiveInput\n    recursive?: commentsCreateNestedManyWithoutParentInput\n    votes?: votesCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsUncheckedCreateWithoutPostInput = {\n    id: string\n    user_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    recursive?: commentsUncheckedCreateNestedManyWithoutParentInput\n    votes?: votesUncheckedCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsCreateOrConnectWithoutPostInput = {\n    where: commentsWhereUniqueInput\n    create: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput>\n  }\n\n  export type commentsCreateManyPostInputEnvelope = {\n    data: commentsCreateManyPostInput | commentsCreateManyPostInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type votesCreateWithoutPostInput = {\n    id: string\n    value: number\n    created_at: Date | string\n    user: usersCreateNestedOneWithoutVotesInput\n    comment?: commentsCreateNestedOneWithoutVotesInput\n  }\n\n  export type votesUncheckedCreateWithoutPostInput = {\n    id: string\n    user_id: string\n    comment_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type votesCreateOrConnectWithoutPostInput = {\n    where: votesWhereUniqueInput\n    create: XOR<votesCreateWithoutPostInput, votesUncheckedCreateWithoutPostInput>\n  }\n\n  export type votesCreateManyPostInputEnvelope = {\n    data: votesCreateManyPostInput | votesCreateManyPostInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type usersUpsertWithoutPostsInput = {\n    update: XOR<usersUpdateWithoutPostsInput, usersUncheckedUpdateWithoutPostsInput>\n    create: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>\n    where?: usersWhereInput\n  }\n\n  export type usersUpdateToOneWithWhereWithoutPostsInput = {\n    where?: usersWhereInput\n    data: XOR<usersUpdateWithoutPostsInput, usersUncheckedUpdateWithoutPostsInput>\n  }\n\n  export type usersUpdateWithoutPostsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    role?: user_rolesUpdateOneRequiredWithoutUsersNestedInput\n    comments?: commentsUpdateManyWithoutAuthorNestedInput\n    votes?: votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type usersUncheckedUpdateWithoutPostsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_role_id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    comments?: commentsUncheckedUpdateManyWithoutAuthorNestedInput\n    votes?: votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type categoriesUpsertWithoutPostsInput = {\n    update: XOR<categoriesUpdateWithoutPostsInput, categoriesUncheckedUpdateWithoutPostsInput>\n    create: XOR<categoriesCreateWithoutPostsInput, categoriesUncheckedCreateWithoutPostsInput>\n    where?: categoriesWhereInput\n  }\n\n  export type categoriesUpdateToOneWithWhereWithoutPostsInput = {\n    where?: categoriesWhereInput\n    data: XOR<categoriesUpdateWithoutPostsInput, categoriesUncheckedUpdateWithoutPostsInput>\n  }\n\n  export type categoriesUpdateWithoutPostsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type categoriesUncheckedUpdateWithoutPostsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type commentsUpsertWithWhereUniqueWithoutPostInput = {\n    where: commentsWhereUniqueInput\n    update: XOR<commentsUpdateWithoutPostInput, commentsUncheckedUpdateWithoutPostInput>\n    create: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput>\n  }\n\n  export type commentsUpdateWithWhereUniqueWithoutPostInput = {\n    where: commentsWhereUniqueInput\n    data: XOR<commentsUpdateWithoutPostInput, commentsUncheckedUpdateWithoutPostInput>\n  }\n\n  export type commentsUpdateManyWithWhereWithoutPostInput = {\n    where: commentsScalarWhereInput\n    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutPostInput>\n  }\n\n  export type votesUpsertWithWhereUniqueWithoutPostInput = {\n    where: votesWhereUniqueInput\n    update: XOR<votesUpdateWithoutPostInput, votesUncheckedUpdateWithoutPostInput>\n    create: XOR<votesCreateWithoutPostInput, votesUncheckedCreateWithoutPostInput>\n  }\n\n  export type votesUpdateWithWhereUniqueWithoutPostInput = {\n    where: votesWhereUniqueInput\n    data: XOR<votesUpdateWithoutPostInput, votesUncheckedUpdateWithoutPostInput>\n  }\n\n  export type votesUpdateManyWithWhereWithoutPostInput = {\n    where: votesScalarWhereInput\n    data: XOR<votesUpdateManyMutationInput, votesUncheckedUpdateManyWithoutPostInput>\n  }\n\n  export type usersCreateWithoutCommentsInput = {\n    id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    role: user_rolesCreateNestedOneWithoutUsersInput\n    posts?: postsCreateNestedManyWithoutAuthorInput\n    votes?: votesCreateNestedManyWithoutUserInput\n  }\n\n  export type usersUncheckedCreateWithoutCommentsInput = {\n    id: string\n    user_role_id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    posts?: postsUncheckedCreateNestedManyWithoutAuthorInput\n    votes?: votesUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type usersCreateOrConnectWithoutCommentsInput = {\n    where: usersWhereUniqueInput\n    create: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>\n  }\n\n  export type postsCreateWithoutCommentsInput = {\n    id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutPostsInput\n    category: categoriesCreateNestedOneWithoutPostsInput\n    votes?: votesCreateNestedManyWithoutPostInput\n  }\n\n  export type postsUncheckedCreateWithoutCommentsInput = {\n    id: string\n    user_id: string\n    category_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    votes?: votesUncheckedCreateNestedManyWithoutPostInput\n  }\n\n  export type postsCreateOrConnectWithoutCommentsInput = {\n    where: postsWhereUniqueInput\n    create: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>\n  }\n\n  export type commentsCreateWithoutRecursiveInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutCommentsInput\n    post: postsCreateNestedOneWithoutCommentsInput\n    parent?: commentsCreateNestedOneWithoutRecursiveInput\n    votes?: votesCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsUncheckedCreateWithoutRecursiveInput = {\n    id: string\n    user_id: string\n    post_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    votes?: votesUncheckedCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsCreateOrConnectWithoutRecursiveInput = {\n    where: commentsWhereUniqueInput\n    create: XOR<commentsCreateWithoutRecursiveInput, commentsUncheckedCreateWithoutRecursiveInput>\n  }\n\n  export type commentsCreateWithoutParentInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutCommentsInput\n    post: postsCreateNestedOneWithoutCommentsInput\n    recursive?: commentsCreateNestedManyWithoutParentInput\n    votes?: votesCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsUncheckedCreateWithoutParentInput = {\n    id: string\n    user_id: string\n    post_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    recursive?: commentsUncheckedCreateNestedManyWithoutParentInput\n    votes?: votesUncheckedCreateNestedManyWithoutCommentInput\n  }\n\n  export type commentsCreateOrConnectWithoutParentInput = {\n    where: commentsWhereUniqueInput\n    create: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput>\n  }\n\n  export type commentsCreateManyParentInputEnvelope = {\n    data: commentsCreateManyParentInput | commentsCreateManyParentInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type votesCreateWithoutCommentInput = {\n    id: string\n    value: number\n    created_at: Date | string\n    user: usersCreateNestedOneWithoutVotesInput\n    post?: postsCreateNestedOneWithoutVotesInput\n  }\n\n  export type votesUncheckedCreateWithoutCommentInput = {\n    id: string\n    user_id: string\n    post_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type votesCreateOrConnectWithoutCommentInput = {\n    where: votesWhereUniqueInput\n    create: XOR<votesCreateWithoutCommentInput, votesUncheckedCreateWithoutCommentInput>\n  }\n\n  export type votesCreateManyCommentInputEnvelope = {\n    data: votesCreateManyCommentInput | votesCreateManyCommentInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type usersUpsertWithoutCommentsInput = {\n    update: XOR<usersUpdateWithoutCommentsInput, usersUncheckedUpdateWithoutCommentsInput>\n    create: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>\n    where?: usersWhereInput\n  }\n\n  export type usersUpdateToOneWithWhereWithoutCommentsInput = {\n    where?: usersWhereInput\n    data: XOR<usersUpdateWithoutCommentsInput, usersUncheckedUpdateWithoutCommentsInput>\n  }\n\n  export type usersUpdateWithoutCommentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    role?: user_rolesUpdateOneRequiredWithoutUsersNestedInput\n    posts?: postsUpdateManyWithoutAuthorNestedInput\n    votes?: votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type usersUncheckedUpdateWithoutCommentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_role_id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    posts?: postsUncheckedUpdateManyWithoutAuthorNestedInput\n    votes?: votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type postsUpsertWithoutCommentsInput = {\n    update: XOR<postsUpdateWithoutCommentsInput, postsUncheckedUpdateWithoutCommentsInput>\n    create: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>\n    where?: postsWhereInput\n  }\n\n  export type postsUpdateToOneWithWhereWithoutCommentsInput = {\n    where?: postsWhereInput\n    data: XOR<postsUpdateWithoutCommentsInput, postsUncheckedUpdateWithoutCommentsInput>\n  }\n\n  export type postsUpdateWithoutCommentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutPostsNestedInput\n    category?: categoriesUpdateOneRequiredWithoutPostsNestedInput\n    votes?: votesUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsUncheckedUpdateWithoutCommentsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    category_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    votes?: votesUncheckedUpdateManyWithoutPostNestedInput\n  }\n\n  export type commentsUpsertWithoutRecursiveInput = {\n    update: XOR<commentsUpdateWithoutRecursiveInput, commentsUncheckedUpdateWithoutRecursiveInput>\n    create: XOR<commentsCreateWithoutRecursiveInput, commentsUncheckedCreateWithoutRecursiveInput>\n    where?: commentsWhereInput\n  }\n\n  export type commentsUpdateToOneWithWhereWithoutRecursiveInput = {\n    where?: commentsWhereInput\n    data: XOR<commentsUpdateWithoutRecursiveInput, commentsUncheckedUpdateWithoutRecursiveInput>\n  }\n\n  export type commentsUpdateWithoutRecursiveInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutCommentsNestedInput\n    post?: postsUpdateOneRequiredWithoutCommentsNestedInput\n    parent?: commentsUpdateOneWithoutRecursiveNestedInput\n    votes?: votesUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateWithoutRecursiveInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    votes?: votesUncheckedUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUpsertWithWhereUniqueWithoutParentInput = {\n    where: commentsWhereUniqueInput\n    update: XOR<commentsUpdateWithoutParentInput, commentsUncheckedUpdateWithoutParentInput>\n    create: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput>\n  }\n\n  export type commentsUpdateWithWhereUniqueWithoutParentInput = {\n    where: commentsWhereUniqueInput\n    data: XOR<commentsUpdateWithoutParentInput, commentsUncheckedUpdateWithoutParentInput>\n  }\n\n  export type commentsUpdateManyWithWhereWithoutParentInput = {\n    where: commentsScalarWhereInput\n    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutParentInput>\n  }\n\n  export type votesUpsertWithWhereUniqueWithoutCommentInput = {\n    where: votesWhereUniqueInput\n    update: XOR<votesUpdateWithoutCommentInput, votesUncheckedUpdateWithoutCommentInput>\n    create: XOR<votesCreateWithoutCommentInput, votesUncheckedCreateWithoutCommentInput>\n  }\n\n  export type votesUpdateWithWhereUniqueWithoutCommentInput = {\n    where: votesWhereUniqueInput\n    data: XOR<votesUpdateWithoutCommentInput, votesUncheckedUpdateWithoutCommentInput>\n  }\n\n  export type votesUpdateManyWithWhereWithoutCommentInput = {\n    where: votesScalarWhereInput\n    data: XOR<votesUpdateManyMutationInput, votesUncheckedUpdateManyWithoutCommentInput>\n  }\n\n  export type usersCreateWithoutVotesInput = {\n    id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    role: user_rolesCreateNestedOneWithoutUsersInput\n    posts?: postsCreateNestedManyWithoutAuthorInput\n    comments?: commentsCreateNestedManyWithoutAuthorInput\n  }\n\n  export type usersUncheckedCreateWithoutVotesInput = {\n    id: string\n    user_role_id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n    posts?: postsUncheckedCreateNestedManyWithoutAuthorInput\n    comments?: commentsUncheckedCreateNestedManyWithoutAuthorInput\n  }\n\n  export type usersCreateOrConnectWithoutVotesInput = {\n    where: usersWhereUniqueInput\n    create: XOR<usersCreateWithoutVotesInput, usersUncheckedCreateWithoutVotesInput>\n  }\n\n  export type postsCreateWithoutVotesInput = {\n    id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutPostsInput\n    category: categoriesCreateNestedOneWithoutPostsInput\n    comments?: commentsCreateNestedManyWithoutPostInput\n  }\n\n  export type postsUncheckedCreateWithoutVotesInput = {\n    id: string\n    user_id: string\n    category_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    comments?: commentsUncheckedCreateNestedManyWithoutPostInput\n  }\n\n  export type postsCreateOrConnectWithoutVotesInput = {\n    where: postsWhereUniqueInput\n    create: XOR<postsCreateWithoutVotesInput, postsUncheckedCreateWithoutVotesInput>\n  }\n\n  export type commentsCreateWithoutVotesInput = {\n    id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    author: usersCreateNestedOneWithoutCommentsInput\n    post: postsCreateNestedOneWithoutCommentsInput\n    parent?: commentsCreateNestedOneWithoutRecursiveInput\n    recursive?: commentsCreateNestedManyWithoutParentInput\n  }\n\n  export type commentsUncheckedCreateWithoutVotesInput = {\n    id: string\n    user_id: string\n    post_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    recursive?: commentsUncheckedCreateNestedManyWithoutParentInput\n  }\n\n  export type commentsCreateOrConnectWithoutVotesInput = {\n    where: commentsWhereUniqueInput\n    create: XOR<commentsCreateWithoutVotesInput, commentsUncheckedCreateWithoutVotesInput>\n  }\n\n  export type usersUpsertWithoutVotesInput = {\n    update: XOR<usersUpdateWithoutVotesInput, usersUncheckedUpdateWithoutVotesInput>\n    create: XOR<usersCreateWithoutVotesInput, usersUncheckedCreateWithoutVotesInput>\n    where?: usersWhereInput\n  }\n\n  export type usersUpdateToOneWithWhereWithoutVotesInput = {\n    where?: usersWhereInput\n    data: XOR<usersUpdateWithoutVotesInput, usersUncheckedUpdateWithoutVotesInput>\n  }\n\n  export type usersUpdateWithoutVotesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    role?: user_rolesUpdateOneRequiredWithoutUsersNestedInput\n    posts?: postsUpdateManyWithoutAuthorNestedInput\n    comments?: commentsUpdateManyWithoutAuthorNestedInput\n  }\n\n  export type usersUncheckedUpdateWithoutVotesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_role_id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    posts?: postsUncheckedUpdateManyWithoutAuthorNestedInput\n    comments?: commentsUncheckedUpdateManyWithoutAuthorNestedInput\n  }\n\n  export type postsUpsertWithoutVotesInput = {\n    update: XOR<postsUpdateWithoutVotesInput, postsUncheckedUpdateWithoutVotesInput>\n    create: XOR<postsCreateWithoutVotesInput, postsUncheckedCreateWithoutVotesInput>\n    where?: postsWhereInput\n  }\n\n  export type postsUpdateToOneWithWhereWithoutVotesInput = {\n    where?: postsWhereInput\n    data: XOR<postsUpdateWithoutVotesInput, postsUncheckedUpdateWithoutVotesInput>\n  }\n\n  export type postsUpdateWithoutVotesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutPostsNestedInput\n    category?: categoriesUpdateOneRequiredWithoutPostsNestedInput\n    comments?: commentsUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsUncheckedUpdateWithoutVotesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    category_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    comments?: commentsUncheckedUpdateManyWithoutPostNestedInput\n  }\n\n  export type commentsUpsertWithoutVotesInput = {\n    update: XOR<commentsUpdateWithoutVotesInput, commentsUncheckedUpdateWithoutVotesInput>\n    create: XOR<commentsCreateWithoutVotesInput, commentsUncheckedCreateWithoutVotesInput>\n    where?: commentsWhereInput\n  }\n\n  export type commentsUpdateToOneWithWhereWithoutVotesInput = {\n    where?: commentsWhereInput\n    data: XOR<commentsUpdateWithoutVotesInput, commentsUncheckedUpdateWithoutVotesInput>\n  }\n\n  export type commentsUpdateWithoutVotesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutCommentsNestedInput\n    post?: postsUpdateOneRequiredWithoutCommentsNestedInput\n    parent?: commentsUpdateOneWithoutRecursiveNestedInput\n    recursive?: commentsUpdateManyWithoutParentNestedInput\n  }\n\n  export type commentsUncheckedUpdateWithoutVotesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    recursive?: commentsUncheckedUpdateManyWithoutParentNestedInput\n  }\n\n  export type postsCreateManyAuthorInput = {\n    id: string\n    category_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type commentsCreateManyAuthorInput = {\n    id: string\n    post_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type votesCreateManyUserInput = {\n    id: string\n    post_id?: string | null\n    comment_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type postsUpdateWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    category?: categoriesUpdateOneRequiredWithoutPostsNestedInput\n    comments?: commentsUpdateManyWithoutPostNestedInput\n    votes?: votesUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsUncheckedUpdateWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    category_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    comments?: commentsUncheckedUpdateManyWithoutPostNestedInput\n    votes?: votesUncheckedUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsUncheckedUpdateManyWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    category_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type commentsUpdateWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    post?: postsUpdateOneRequiredWithoutCommentsNestedInput\n    parent?: commentsUpdateOneWithoutRecursiveNestedInput\n    recursive?: commentsUpdateManyWithoutParentNestedInput\n    votes?: votesUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    recursive?: commentsUncheckedUpdateManyWithoutParentNestedInput\n    votes?: votesUncheckedUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateManyWithoutAuthorInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type votesUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    post?: postsUpdateOneWithoutVotesNestedInput\n    comment?: commentsUpdateOneWithoutVotesNestedInput\n  }\n\n  export type votesUncheckedUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: NullableStringFieldUpdateOperationsInput | string | null\n    comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type votesUncheckedUpdateManyWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    post_id?: NullableStringFieldUpdateOperationsInput | string | null\n    comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type usersCreateManyRoleInput = {\n    id: string\n    username: string\n    email: string\n    bio?: string | null\n    password_hash: string\n    created_at: Date | string\n    updated_at: Date | string\n    status: string\n  }\n\n  export type usersUpdateWithoutRoleInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    posts?: postsUpdateManyWithoutAuthorNestedInput\n    comments?: commentsUpdateManyWithoutAuthorNestedInput\n    votes?: votesUpdateManyWithoutUserNestedInput\n  }\n\n  export type usersUncheckedUpdateWithoutRoleInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n    posts?: postsUncheckedUpdateManyWithoutAuthorNestedInput\n    comments?: commentsUncheckedUpdateManyWithoutAuthorNestedInput\n    votes?: votesUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type usersUncheckedUpdateManyWithoutRoleInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    username?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    bio?: NullableStringFieldUpdateOperationsInput | string | null\n    password_hash?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    status?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type postsCreateManyCategoryInput = {\n    id: string\n    user_id: string\n    title: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type postsUpdateWithoutCategoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutPostsNestedInput\n    comments?: commentsUpdateManyWithoutPostNestedInput\n    votes?: votesUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsUncheckedUpdateWithoutCategoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    comments?: commentsUncheckedUpdateManyWithoutPostNestedInput\n    votes?: votesUncheckedUpdateManyWithoutPostNestedInput\n  }\n\n  export type postsUncheckedUpdateManyWithoutCategoryInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    title?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type commentsCreateManyPostInput = {\n    id: string\n    user_id: string\n    parent_id?: string | null\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type votesCreateManyPostInput = {\n    id: string\n    user_id: string\n    comment_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type commentsUpdateWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutCommentsNestedInput\n    parent?: commentsUpdateOneWithoutRecursiveNestedInput\n    recursive?: commentsUpdateManyWithoutParentNestedInput\n    votes?: votesUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    recursive?: commentsUncheckedUpdateManyWithoutParentNestedInput\n    votes?: votesUncheckedUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateManyWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    parent_id?: NullableStringFieldUpdateOperationsInput | string | null\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type votesUpdateWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: usersUpdateOneRequiredWithoutVotesNestedInput\n    comment?: commentsUpdateOneWithoutVotesNestedInput\n  }\n\n  export type votesUncheckedUpdateWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type votesUncheckedUpdateManyWithoutPostInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    comment_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type commentsCreateManyParentInput = {\n    id: string\n    user_id: string\n    post_id: string\n    content: string\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type votesCreateManyCommentInput = {\n    id: string\n    user_id: string\n    post_id?: string | null\n    value: number\n    created_at: Date | string\n  }\n\n  export type commentsUpdateWithoutParentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    author?: usersUpdateOneRequiredWithoutCommentsNestedInput\n    post?: postsUpdateOneRequiredWithoutCommentsNestedInput\n    recursive?: commentsUpdateManyWithoutParentNestedInput\n    votes?: votesUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateWithoutParentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    recursive?: commentsUncheckedUpdateManyWithoutParentNestedInput\n    votes?: votesUncheckedUpdateManyWithoutCommentNestedInput\n  }\n\n  export type commentsUncheckedUpdateManyWithoutParentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: StringFieldUpdateOperationsInput | string\n    content?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type votesUpdateWithoutCommentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: usersUpdateOneRequiredWithoutVotesNestedInput\n    post?: postsUpdateOneWithoutVotesNestedInput\n  }\n\n  export type votesUncheckedUpdateWithoutCommentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type votesUncheckedUpdateManyWithoutCommentInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    user_id?: StringFieldUpdateOperationsInput | string\n    post_id?: NullableStringFieldUpdateOperationsInput | string | null\n    value?: IntFieldUpdateOperationsInput | number\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n\n\n  /**\n   * Batch Payload for updateMany & deleteMany & createMany\n   */\n\n  export type BatchPayload = {\n    count: number\n  }\n\n  /**\n   * DMMF\n   */\n  export const dmmf: runtime.BaseDMMF\n}",
        "node_modules/.prisma/client/runtime/index-browser.d.ts": "declare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\ndeclare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\ndeclare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\ndeclare type Narrowable = string | number | bigint | boolean | [];\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\ndeclare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\nexport { }\r\n",
        "node_modules/.prisma/client/runtime/library.d.ts": "/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\n/**\r\n * Original `quaint::ValueType` enum tag from Prisma's `quaint`.\r\n * Query arguments marked with this type are sanitized before being sent to the database.\r\n * Notice while a query argument may be `null`, `ArgType` is guaranteed to be defined.\r\n */\r\ndeclare type ArgType = 'Int32' | 'Int64' | 'Float' | 'Double' | 'Text' | 'Enum' | 'EnumArray' | 'Bytes' | 'Boolean' | 'Char' | 'Array' | 'Numeric' | 'Json' | 'Xml' | 'Uuid' | 'DateTime' | 'Date' | 'Time' | 'Unknown';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: CustomDataProxyFetch;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: object;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\n/**\r\n * Custom fetch function for `DataProxyEngine`.\r\n *\r\n * We can't use the actual type of `globalThis.fetch` because this will result\r\n * in API Extractor referencing Node.js type definitions in the `.d.ts` bundle\r\n * for the client runtime. We can only use such types in internal types that\r\n * don't end up exported anywhere.\r\n\r\n * It's also not possible to write a definition of `fetch` that would accept the\r\n * actual `fetch` function from different environments such as Node.js and\r\n * Cloudflare Workers (with their extensions to `RequestInit` and `Response`).\r\n * `fetch` is used in both covariant and contravariant positions in\r\n * `CustomDataProxyFetch`, making it invariant, so we need the exact same type.\r\n * Even if we removed the argument and left `fetch` in covariant position only,\r\n * then for an extension-supplied function to be assignable to `customDataProxyFetch`,\r\n * the platform-specific (or custom) `fetch` function needs to be assignable\r\n * to our `fetch` definition. This, in turn, requires the third-party `Response`\r\n * to be a subtype of our `Response` (which is not a problem, we could declare\r\n * a minimal `Response` type that only includes what we use) *and* requires the\r\n * third-party `RequestInit` to be a supertype of our `RequestInit` (i.e. we\r\n * have to declare all properties any `RequestInit` implementation in existence\r\n * could possibly have), which is not possible.\r\n *\r\n * Since `@prisma/extension-accelerate` redefines the type of\r\n * `__internalParams.customDataProxyFetch` to its own type anyway (probably for\r\n * exactly this reason), our definition is never actually used and is completely\r\n * ignored, so it doesn't matter, and we can just use `unknown` as the type of\r\n * `fetch` here.\r\n */\r\ndeclare type CustomDataProxyFetch = (fetch: unknown) => unknown;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$use\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    fields: string[];\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    fields: string[];\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    middleware?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_3<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _middlewares: MiddlewareHandler<QueryMiddleware>;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        /**\r\n         * Hook a middleware into the client\r\n         * @param middleware to hook\r\n         */\r\n        $use(middleware: QueryMiddleware): void;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: TransactionOptions_2;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: CustomDataProxyFetch;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare class MiddlewareHandler<M extends Function> {\r\n    private _middlewares;\r\n    use(middleware: M): void;\r\n    get(id: number): M | undefined;\r\n    has(id: number): boolean;\r\n    length(): number;\r\n}\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: object[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-pg-worker\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): string;\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddleware = (params: QueryMiddlewareParams, next: (params: QueryMiddlewareParams) => Promise<unknown>) => Promise<unknown>;\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_3<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: CustomDataProxyFetch;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: CustomDataProxyFetch;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: CustomDataProxyFetch;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        TransactionOptions_2 as Options,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2 = {\r\n    maxWait?: number;\r\n    timeout?: number;\r\n    isolationLevel?: IsolationLevel;\r\n};\r\n\r\ndeclare type TransactionOptions_3<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n",
        "node_modules/.prisma/client/wasm.d.ts": "export * from \"./index\"",
        "node_modules/@prisma/client/index.d.ts": "export * from '.prisma/client/default'"
      },
      "document": "# Prisma Markdown\n\n> Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)\n\n- [Core](#core)\n- [Posts](#posts)\n- [Votes](#votes)\n\n## Core\n\n```mermaid\nerDiagram\n\"users\" {\n  String id PK\n  String user_role_id FK\n  String username UK\n  String email UK\n  String bio \"nullable\"\n  String password_hash\n  DateTime created_at\n  DateTime updated_at\n  String status\n}\n\"user_roles\" {\n  String id PK\n  String name UK\n  String description\n}\n\"categories\" {\n  String id PK\n  String name UK\n  String description\n  DateTime created_at\n}\n\"users\" }o--|| \"user_roles\" : role\n```\n\n### `users`\n\nUser information - This implements the 'User' entity from the requirements analysis document (03_data_structure_and_business_rules.md). \n\nRepresents registered members of the discussion board. Each user record holds public profile data and permissions (role and status). For example, Alice with email alice@email.com can be a regular user, moderator, or admin.\n\nKey relationships: references user_roles for permission, and relates to posts, comments, and votes they create.\nSpecial behaviors: emails are unique; passwords are stored securely; role assignment required.\n\nProperties as follows:\n\n- `id`\n  > Primary Key.\n  > Unique identifier for each user.\n- `user_role_id`\n  > Role of the user. Target model's [user_roles.id](#user_roles).\n  > Determines user permissions such as regular member, moderator, or administrator.\n- `username`: Username visible on the platform - Implements profile display requirement. Must be unique and public. For example, 'politicoFan88'.\n- `email`: User's email address - Used for login and notifications. Must be unique. For example, 'user@example.com'.\n- `bio`: Optional short biography - Lets users share info about themselves. For example, 'Economics student, debate enthusiast.'\n- `password_hash`: Hashed password - Implements security requirement. Stores a hashed version of the user password for authentication. Example: long hash string. Not public.\n- `created_at`: Account creation timestamp - Implements auditability. For example, '2024-06-09T10:00:00+09:00'.\n- `updated_at`: Timestamp of last profile update - Implements history/auth traceability. For example, '2024-07-01T12:30:00+09:00'.\n- `status`: Account status - Implements moderation/authentication rules. For example, 'active', 'suspended', or 'banned'.\n\n### `user_roles`\n\nUser role definitions - This implements the role structure outlined in user roles section of the requirements analysis document (02_key_features_and_user_roles.md).\n\nDefines different permissions and capabilities for users. For example, 'member', 'moderator', 'administrator'.\n\nKey relationships: referenced by users table; no direct link to posts or comments.\nSpecial behaviors: role 'name' must be unique.\n\nProperties as follows:\n\n- `id`: Primary Key. Unique identifier for user role.\n- `name`: Role label - Implements user roles requirement. Example: 'member', 'moderator', 'administrator'. Must be unique.\n- `description`: Role description - Gives context about permissions and duties; e.g., 'Can moderate comments and suspend users' for moderators.\n\n### `categories`\n\nDiscussion categories - This covers the 'Category' entity from the requirements document (03_data_structure_and_business_rules.md).\n\nRepresents the main topic divisions organizing posts. For example, 'Politics', 'Economics', 'International Affairs'.\n\nKey relationships: referenced by posts; managed by administrators.\nSpecial behaviors: unique name required, can be suggested by users but created by admin.\n\nProperties as follows:\n\n- `id`: Primary Key. Unique identifier for category.\n- `name`: Category name - Implements content organization and navigation requirement. For example, 'Politics'. Must be unique per category.\n- `description`: Category description - Explains scope. For example, 'Discussion about domestic and international political systems, governance, and related events.'\n- `created_at`: Timestamp when the category was added - Implements audit trail. Example: '2024-06-09T09:00:00+09:00'.\n\n## Posts\n\n```mermaid\nerDiagram\n\"posts\" {\n  String id PK\n  String user_id FK\n  String category_id FK\n  String title\n  String content\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"comments\" {\n  String id PK\n  String user_id FK\n  String post_id FK\n  String parent_id FK \"nullable\"\n  String content\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"comments\" }o--|| \"posts\" : post\n\"comments\" }o--o| \"comments\" : parent\n```\n\n### `posts`\n\nPost entity - This implements the 'Post' entity from the requirements document (see Data Structure and Business Rules, section 1, and Example Scenario). \n\nRepresents discussion topics or articles submitted by users. Provides a core construct to enable users to initiate threads, share analysis, and start community debates. For example, a user posts a discussion about inflation in the 'Economics' category. \n\nKey relationships: Each post belongs to one user (author) and one category. Each post can have many comments and votes. \nSpecial behaviors: A post must be assigned to a category, may be edited/deleted by its author, and is visible to all users. Vote tally and creation metadata are key for surfacing relevant content.\n\nProperties as follows:\n\n- `id`: Primary Key. Unique identifier for each post.\n- `user_id`: Author's [users.id](#users) - Links each post to its authoring user account. Enforces the association between posts and registered users. Required for accountability and profile-related features.\n- `category_id`: Category's [categories.id](#categories) - Associates the post with a topic/category, used for board structure and navigation. Enforces the requirement that every post has a topical context.\n- `title`: Title of the post - Implements the requirement that each post has a headline/subject. Business meaning: summary/subject line visible in post lists and thread views. For example, 'Economic Impact of Inflation in 2025'.\n- `content`: Body content of the post - Implements the rule that posts have main text where users express opinions, share news, analysis, etc. For example, a 400-word analysis of current economic events. Allows rich content or text.\n- `created_at`: Creation timestamp - Implements transparency and audit requirements by recording when the post was created. Business use: shows recency in lists, allows moderation tracking.\n- `updated_at`: Last edited timestamp - Allows tracking of post edits for evidence/history. Enforces business constraint of allowing users to edit posts within the permitted window. For example, updated_at is changed when a user fixes a typo.\n- `deleted_at`: Soft deletion timestamp - Implements moderation rules (see Moderation and User Roles). Posts are not hard deleted but marked with this field if removed for rule violations or by user request. For example, moderators mark spam here for audit/history.\n\n### `comments`\n\nComment entity - This implements the 'Comment' entity from the requirements (see Data Structure and Business Rules section 1, and Example Scenario).\n\nRepresents replies to posts or other comments, allowing for nested conversations and community discussion. For example, a user comments on a post about inflation, or replies to another comment with their opinion.\n\nKey relationships: Each comment is written by a user and is attached either directly to a post or as a nested reply to another comment. Each comment can have multiple votes. Replies form a hierarchy.\nSpecial behaviors: Only registered users can comment. Comments may be deleted/edited by their author within constraints. Vote tally supports surfacing relevant replies. Threaded (self-referential) relations supported.\n\nProperties as follows:\n\n- `id`: Primary Key. Unique identifier for each comment.\n- `user_id`: Author's [users.id](#users) - Indicates the owner/author of the comment. Enforces accountability, links to profile and reputation system. Required for audit and moderation.\n- `post_id`: Parent post's [posts.id](#posts) - The post that this comment is in response to. Implements the association between comments and discussions. Required unless it's a reply to another comment only.\n- `parent_id`: Parent comment's [comments.id](#comments) - Implements threaded/nested replies, allowing for comment hierarchies. Enables conversations to branch. Nullable for top-level comments (direct responses to posts).\n- `content`: Comment body - Implements the rule that each comment consists of user-written text/content. Used for replies, opinions, and ongoing discussion. For example, 'I agree and here’s why...'.\n- `created_at`: Creation timestamp - Implements audit/history requirement for comment posting, tracking the date and time for moderation and display ordering. For example, enables 'most recent first' sorting.\n- `updated_at`: Last edited timestamp - Implements edit history tracking for evidence and transparency. If a user updates their comment, this records when.\n- `deleted_at`: Soft deletion timestamp - Implements moderation controls by marking comments removed (not hard deleted) for evidence/history. Used if comment violates rules, is self-removed, or by moderator action.\n\n## Votes\n\n```mermaid\nerDiagram\n\"votes\" {\n  String id PK\n  String user_id FK\n  String post_id FK \"nullable\"\n  String comment_id FK \"nullable\"\n  Int value\n  DateTime created_at\n}\n```\n\n### `votes`\n\nVote records - This implements the voting/feedback requirements section described in the requirements analysis, enabling users to provide positive or negative feedback on posts and comments in the discussion board. \n\nBusiness purpose: Allows users to upvote or downvote content, surfacing high-quality posts and comments, while discouraging low-quality contributions. Only registered users can cast votes and only one vote per content item per user is allowed, enforcing fairness and preventing manipulation. Used to calculate real-time content ranking and trust metrics.\n\nKey relationships: Votes always belong to a user and point to either a post or a comment. The voted target is mutually exclusive: each row references either a post or a comment, but never both. \n\nSpecial behaviors: Unique constraint ensures one vote per user per post or comment. Cascade deletion if the user or voted content is removed, to maintain data integrity.\n\nProperties as follows:\n\n- `id`: Primary Key. Unique identifier for each vote record.\n- `user_id`: Voter's user reference - Links each vote to the user who cast it. Implements the requirement that only registered users can vote. Business meaning: Tracks voting history and enforces unique voting constraints. Example: User 'U' upvotes a comment, linking the vote to 'U's user_id.\n- `post_id`: Target post's reference - References the post being voted on, if the vote relates to a post (and not a comment). Implements mutual exclusivity rule and enables vote tallies for posts. Example: Voting on a thread increases the tally on the referenced post. Constraint: Only one of post_id or comment_id is non-null per row.\n- `comment_id`: Target comment's reference - References the comment being voted on, if applicable. Implements mutual exclusivity rule as with posts. Example: Voting on a reply records the vote linked to this comment. Only one of post_id or comment_id is set per vote record.\n- `value`: Vote value - Implements the upvote/downvote requirement. Stores +1 for upvote, -1 for downvote. Business meaning: This value is aggregated to produce content rankings. Example: A +1 value indicates an upvote from a user.\n- `created_at`: Vote timestamp - Implements auditing requirements for vote tracking. Stores the date and time the vote was made. Used for analytics and to enforce time-based voting limits, if ever required by policy.\n",
      "diagrams": {
        "Core": "```mermaid\nerDiagram\n\"users\" {\n  String id PK\n  String user_role_id FK\n  String username UK\n  String email UK\n  String bio \"nullable\"\n  String password_hash\n  DateTime created_at\n  DateTime updated_at\n  String status\n}\n\"user_roles\" {\n  String id PK\n  String name UK\n  String description\n}\n\"categories\" {\n  String id PK\n  String name UK\n  String description\n  DateTime created_at\n}\n\"users\" }o--|| \"user_roles\" : role\n```",
        "Posts": "```mermaid\nerDiagram\n\"posts\" {\n  String id PK\n  String user_id FK\n  String category_id FK\n  String title\n  String content\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"comments\" {\n  String id PK\n  String user_id FK\n  String post_id FK\n  String parent_id FK \"nullable\"\n  String content\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n\"comments\" }o--|| \"posts\" : post\n\"comments\" }o--o| \"comments\" : parent\n```",
        "Votes": "```mermaid\nerDiagram\n\"votes\" {\n  String id PK\n  String user_id FK\n  String post_id FK \"nullable\"\n  String comment_id FK \"nullable\"\n  Int value\n  DateTime created_at\n}\n```"
      }
    },
    "step": 0
  },
  {
    "id": "e6c6f565-8ebb-468e-b7bc-8809944ebfee",
    "type": "userMessage",
    "contents": [
      {
        "type": "text",
        "text": "Create the API interface specification.\n"
      }
    ],
    "created_at": "2025-06-09T05:54:27.338Z"
  },
  {
    "type": "interface",
    "id": "8adbaa11-e1a1-4e13-8d24-c6d2acbc5d1f",
    "document": {
      "operations": [
        {
          "specification": "List (search and paginate) all users in the discussion board system. Based on the 'users' table in Prisma, this endpoint allows querying users with optional filters like role, status, createdAt, etc., and supports pagination as well as basic search (username/email). Utilizes full Prisma schema column details and relationship to 'user_roles'.",
          "description": "This operation returns a paginated and filtered list of users registered on the discussion board. Users may be searched by username, email, user role, or status, and results are sorted and paginated according to the provided parameters. The endpoint refers to the users table, whose structure includes fields for username, email, bio, role reference, password hash, timestamps, and status. Filters can help administrators or moderators locate specific accounts, monitor new signups, or audit activity. Security is enforced: only users with moderator or administrator roles can access or use advanced filters.\n\nThe endpoint applies business rules from the requirements, such as hiding sensitive (e.g., password) information, and supports relations to user_roles for displaying or filtering by user type. Pagination and sorting follow best practices for usability and performance. Related endpoints: create (POST), retrieve detail (GET), update (PUT), and delete (DELETE) for users.\n\nError handling ensures invalid queries, unauthorized access, or database issues are managed gracefully, returning clear status codes and messages. Sensitive data, such as password hashes, is never included in responses.",
          "summary": "Retrieve a paginated, filterable list of users (core.users table).",
          "parameters": [],
          "requestBody": {
            "description": "Filtering, sorting, and pagination info for user listing request.",
            "typeName": "IUser.IRequest"
          },
          "responseBody": {
            "description": "A paginated set of user summaries matching the search conditions, with profile and role info (never includes sensitive authentication fields).",
            "typeName": "IPageIUser.ISummary"
          },
          "path": "/core/users",
          "method": "patch"
        },
        {
          "specification": "Get a single user's full details, referencing the 'users' table in the Prisma schema. Returns profile and role info for one specific user by ID. Supports full audit trail and profile viewing needs.",
          "description": "This operation retrieves the full profile and related information for a specific user, identified by their unique user ID. Fields returned follow the schema comments: username, email, bio, status, timestamps, and a reference to their user role. User roles are resolved to human-readable labels where appropriate.\n\nSensitive fields such as password_hash are never returned. This endpoint is typically used by administrators for user management, or by users to view their own account details. Where authorized, moderators may use this endpoint for resolving moderation cases or audits. The data aligns exactly with the users table comments and model.\n\nRelated endpoints include listing (PATCH), creation (POST), update (PUT), and deletion (DELETE) for users. Error handling covers not found, unauthorized, or forbidden cases, always giving appropriate error codes and minimal leak of protected info.",
          "summary": "Retrieve detailed profile info for a specific user (core.users table).",
          "parameters": [
            {
              "name": "id",
              "description": "Target user's ID (UUID).",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Full user profile detail with relevant account and role information, excluding authentication secrets.",
            "typeName": "IUser"
          },
          "path": "/core/users/{id}",
          "method": "get"
        },
        {
          "specification": "Create a new user account in the discussion board, corresponding to the 'users' table. Involves validation of unique usernames/emails and correct user role assignment, following Prisma schema and requirements. Typical use: user registration or admin account creation.",
          "description": "This operation handles new user registration or administrator-created user accounts. It accepts all required and optional fields per the users model: username, email, bio (optional), status, and an associated user_role_id. Passwords are securely hashed before saving, never stored in plain text.\n\nUnique constraints are enforced for both username and email to prevent duplicates. The user role must point to an existing role defined in user_roles. Timestamps for creation and update are handled automatically. Successful creation returns the newly registered user's public profile and role association (never the password hash).\n\nSecurity and validation reflect business rules, e.g., email visibility, profile privacy, and initial status setting. Input errors or duplicates return clear messages and codes. Related endpoints: list (PATCH), read (GET), update (PUT), delete (DELETE).",
          "summary": "Register a new user (core.users table).",
          "parameters": [],
          "requestBody": {
            "description": "Registration info for the new user, including username, email, password, user role, etc.",
            "typeName": "IUser.ICreate"
          },
          "responseBody": {
            "description": "Full profile of the newly created user, including assigned role, minus authentication secrets.",
            "typeName": "IUser"
          },
          "path": "/core/users",
          "method": "post"
        },
        {
          "specification": "Update all editable profile fields for an existing user, mapping to the 'users' table. Typical use cases: user updates their profile, moderators/admins change user roles, update status, or correct information.",
          "description": "Updates an existing user's information, addressing fields in the users schema, such as username, email, bio, role, status, and update timestamp. The input must include the user ID and only permitted fields are updateable. Username/email uniqueness is enforced on update as well. Moderators/administrators can change roles/statuses as permitted by business rules.\n\nThe request never allows direct password updates (managed by a separate dedicated endpoint, or by password reset process for security). All change history is reflected in the updated_at timestamp. Security measures prevent users from editing others' profiles unless authorized; self-edits are limited to certain fields.\n\nRelated endpoints: detail (GET), list (PATCH), create (POST), delete (DELETE). Strict validation and business rule application ensure stability and data quality.",
          "summary": "Update user profile and account fields (core.users table).",
          "parameters": [
            {
              "name": "id",
              "description": "Target user's ID (UUID).",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Editable fields for user update, such as profile details or status/role changes (excludes password updates).",
            "typeName": "IUser.IUpdate"
          },
          "responseBody": {
            "description": "Full, updated user profile after modifications, including associated role info.",
            "typeName": "IUser"
          },
          "path": "/core/users/{id}",
          "method": "put"
        },
        {
          "specification": "Delete a user from the board system, via the 'users' Prisma model. In practice, this may perform a hard or soft delete per business rules (typically soft delete for audit/history).",
          "description": "Deletes a user account with the specified ID. This typically marks the user's status as deleted or suspended and/or sets a deletion flag in audit fields, per the users Prisma schema and moderation rules. Associated content (posts, comments, votes) may be retained for community reference, moderation, or audit logs, as described in requirements.\n\nOnly administrators may perform this action, and a detailed audit trail is kept. Related endpoints are used for restoration or final hard-delete (if policy allows). Errors for not found or forbidden actions are handled appropriately; sensitive information on deleted users is not exposed.",
          "summary": "Softly or fully delete a user (core.users table).",
          "parameters": [
            {
              "name": "id",
              "description": "Target user's ID (UUID).",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Confirmation of successful deletion or status update, with minimal identifying info.",
            "typeName": "IUser.IDeleteResponse"
          },
          "path": "/core/users/{id}",
          "method": "delete"
        },
        {
          "specification": "Retrieve a list of available user roles defined in the 'user_roles' table. Used by administrators and for account registration/profile editing. Supports filtering, sorting, and pagination.",
          "description": "This operation returns a paginated list of user roles available to assign, as defined by the user_roles model. Roles govern permissions across the board (e.g., member, moderator, administrator). Designed for use in registration processes, admin dashboards, or role management panels, enabling filtering by role name or description and ordering of results.\n\nData returned is defined strictly by the Prisma model and schema comments. This operation is auditable and respects business constraints on who may view/assign roles. Related endpoints: single role GET, create (POST), update (PUT), and delete (DELETE).\n\nError cases (e.g., forbidden access) are handled with appropriate status codes. Pagination and search parameters maximize usability and efficiency, especially for large deployments with custom roles.",
          "summary": "List and filter user roles (core.userRoles table).",
          "parameters": [],
          "requestBody": {
            "description": "Filter, search, and pagination info for user roles listing.",
            "typeName": "IUserRole.IRequest"
          },
          "responseBody": {
            "description": "A paginated list of available user roles with label and description.",
            "typeName": "IPageIUserRole"
          },
          "path": "/core/userRoles",
          "method": "patch"
        },
        {
          "specification": "Get details for a single user role from the 'user_roles' table. Primarily for admin role management and during user registration or updates.",
          "description": "Retrieves all details for a single user role, specified by ID. Used in admin panels to display all properties of a role, or in account registration to inform users about the meaning and permissions of each role (as described in schema comments: name, description, etc).\n\nRespects all business rules regarding role assignment and application. Related endpoints: list (PATCH), creation (POST), update (PUT), delete (DELETE). Errors for missing roles or unauthorized actions are handled gracefully, with clear messaging.",
          "summary": "Get a single user role's details (core.userRoles table).",
          "parameters": [
            {
              "name": "id",
              "description": "Target role's ID (UUID).",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Details about the specified user role, including label and full description.",
            "typeName": "IUserRole"
          },
          "path": "/core/userRoles/{id}",
          "method": "get"
        },
        {
          "specification": "Create a new user role in the system, using the 'user_roles' table. For defining permissions such as moderator/admin/member status. Only accessible by administrators.",
          "description": "Creates a new user role based on the schema structure, with fields for name (label) and description. Enforces the uniqueness of the role name and ensures all required information is provided, following the comments and requirements detailed in the Prisma schema.\n\nIntended for administrator setup or customization of new permission levels. Errors are sent in case of duplicate names, missing fields, or insufficient permissions. Successful creation returns the new user role record, suitable for immediate assignment to users.\n\nRelated endpoints: list (PATCH), single GET, update (PUT), and delete (DELETE) for user roles.",
          "summary": "Create a new user role (core.userRoles table).",
          "parameters": [],
          "requestBody": {
            "description": "New user role details, including name and description.",
            "typeName": "IUserRole.ICreate"
          },
          "responseBody": {
            "description": "Details for the created user role, ready for assignment to users.",
            "typeName": "IUserRole"
          },
          "path": "/core/userRoles",
          "method": "post"
        },
        {
          "specification": "Update all editable fields for an existing user role in the 'user_roles' table. Enables administrators to edit the label (name) and description for a role. Used for adjusting or correcting permission sets.",
          "description": "Updates an existing user role's properties (name and/or description). Uniqueness of the name is enforced by Prisma schema rules. Typical in systems where additional roles/policies are introduced or for correcting role definitions.\n\nOnly administrators are permitted to update roles. Change history is tracked and any update is reflected in audit fields. Related endpoints: detail GET, list PATCH, creation POST, and deletion DELETE for user roles.\n\nAny errors due to duplicates, forbidden edits, or missing records generate suitable error codes in response. Endpoint matches structure and intentions described in requirements and schema comments.",
          "summary": "Edit label/description for a user role (core.userRoles table).",
          "parameters": [
            {
              "name": "id",
              "description": "Target role's ID (UUID).",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "New values for user role fields (name/description).",
            "typeName": "IUserRole.IUpdate"
          },
          "responseBody": {
            "description": "Updated role details after successful edit.",
            "typeName": "IUserRole"
          },
          "path": "/core/userRoles/{id}",
          "method": "put"
        },
        {
          "specification": "Delete a user role from the 'user_roles' table. Used by administrators; typically only possible for custom or unused roles (some roles may be protected by business rule).",
          "description": "Deletes a user role identified by its ID. Enforces business and schema rules about which roles can be deleted (e.g., prevents deletion of critical roles if protected by business logic). If the role is in use (referenced by users), operation will fail with a clear error message.\n\nAdministrative rights are required. Detailed audit trails are maintained for changes. Related endpoints: create (POST), list (PATCH), update (PUT), detail (GET). All operations match Prisma schema and requirements. Appropriate handling is provided for not found, forbidden, or dependency errors.",
          "summary": "Delete a user role from the system (core.userRoles table).",
          "parameters": [
            {
              "name": "id",
              "description": "Target role's ID (UUID).",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Confirmation of role deletion or status update; references deleted role.",
            "typeName": "IUserRole.IDeleteResponse"
          },
          "path": "/core/userRoles/{id}",
          "method": "delete"
        },
        {
          "specification": "This operation retrieves a paginated, searchable, and optionally sorted list of discussion categories from the 'categories' table in the Core schema. It supports filtering by category name, description, creation timestamp, and includes pagination controls (page, pageSize) and ordering options (e.g., by name or date created). The endpoint is essential for displaying lists of categories to users, for administrative overviews, or for category suggestion interfaces. It does not expose creation or update metadata beyond the necessary category fields. Only users with proper permissions may access certain administrative search features. Related endpoints include detail retrieval, creation, update, and deletion of single categories.",
          "description": "This API operation returns a list of categories, leveraging the 'categories' table from the database. \n\nThe response is paginated and may be filtered based on optional query parameters such as name, partial matches in description, or created_at window. Secure endpoints may restrict certain filters or result fields to administrators. The main purpose is to allow users to browse or search available discussion categories for post assignment or exploration. \n\nSecurity: Some filtering/search options may be restricted to users with elevated roles, such as administrators or moderators. Regular users typically see all active categories only. \n\nThis endpoint is commonly used in category selection modals, administrative dashboards, and on board homepages. Validation ensures page and pageSize are non-negative, and sortBy field must match a valid column. Error handling will return informative failures for invalid filter parameters or database errors.\n\nThis operation is related to single-category get, create, update, and delete operations, and in large systems may be supplemented by category suggestion/approval flows.",
          "summary": "List and search categories (Core.categories)",
          "parameters": [],
          "requestBody": {
            "description": "Search criteria, pagination, and sorting parameters for categories list query.",
            "typeName": "ICategory.IRequest"
          },
          "responseBody": {
            "description": "Paginated result including array of category summaries and pagination metadata.",
            "typeName": "IPageICategory"
          },
          "path": "/core/categories",
          "method": "patch"
        },
        {
          "specification": "This operation retrieves a single category, identified by its unique UUID, from the 'categories' table in the Core schema. It is used for viewing detailed information about a category, typically for display on category profile pages or administrative management screens. The operation ensures the referenced category exists and returns its complete details.",
          "description": "Retrieves category information for the specified ID from the 'categories' table, including name, description, creation timestamp, and potentially related post count or status if extended.\n\nIf the category does not exist, the API returns a clear error message. Access policies determine visibility of archived or deactivated categories—regular users can only view active categories, while admins may retrieve all states.\n\nThis endpoint is essential for screens displaying category details prior to editing/deleting, or for referencing during post creation/editing workflows. Includes validation of the UUID path parameter. Returns 404 if not found or permission denied.\n\nRelated endpoints: categories list/search (PATCH), create (POST), update (PUT), and delete (DELETE).",
          "summary": "Retrieve specific category by ID (Core.categories)",
          "parameters": [
            {
              "name": "id",
              "description": "Unique ID of the target category",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Full detail of the specified category, including all public fields.",
            "typeName": "ICategory"
          },
          "path": "/core/categories/{id}",
          "method": "get"
        },
        {
          "specification": "This operation creates a new discussion category in the 'categories' table of the Core schema. Typically restricted to administrative users, this endpoint supports the addition of new categories for organizing posts. All submitted data is validated for uniqueness and format compliance before insertion.",
          "description": "Allows creation of a new category topic for the discussion board, by inserting a new record into the 'categories' table in the database. The provided name must be unique among all categories. Description field gives users context. Only authorized users (administrators) are permitted to execute this operation.\n\nInput validation includes ensuring that required fields are present, name does not duplicate existing entries, and description respects length/content rules. On success, the new category is created and returned with full detail including its assigned UUID and creation timestamp.\n\nError handling covers invalid parameters, uniqueness violations, or insufficient permissions. \n\nRelated endpoints: list/search (PATCH), get (GET), update (PUT), and delete (DELETE) for categories.",
          "summary": "Create new category (Core.categories)",
          "parameters": [],
          "requestBody": {
            "description": "Data for new category including unique name and description.",
            "typeName": "ICategory.ICreate"
          },
          "responseBody": {
            "description": "The newly created category with full details.",
            "typeName": "ICategory"
          },
          "path": "/core/categories",
          "method": "post"
        },
        {
          "specification": "This operation updates the details of a specific category (by UUID) in the 'categories' table in the Core schema. Usually accessible to administrators, it allows updating name or description fields, with necessary validation to ensure continued uniqueness of name and data consistency.",
          "description": "Updates an existing category's name or description by changing the relevant fields in the 'categories' table. The category is referenced by its unique UUID path parameter, and the body provides updated data.\n\nThis operation may only be performed by users with appropriate administrative roles. Validation checks include verifying that the new category name does not duplicate any other categories and that all required fields meet formatting rules.\n\nPartial or full updates are supported; fields not included may retain their current values. Business rules may restrict changes if the category is currently associated with posts. On success, the full updated category information is returned.\n\nError handling includes failing if the category does not exist, trying to use a duplicate name, or lacking sufficient rights. Related operations: get, create, delete, and list/search categories.",
          "summary": "Update a category by ID (Core.categories)",
          "parameters": [
            {
              "name": "id",
              "description": "Unique ID of the target category",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Updated name and/or description for the category.",
            "typeName": "ICategory.IUpdate"
          },
          "responseBody": {
            "description": "The updated category details after saving changes.",
            "typeName": "ICategory"
          },
          "path": "/core/categories/{id}",
          "method": "put"
        },
        {
          "specification": "This operation deletes (or marks as deleted) a specific category in the 'categories' table of the Core schema, referenced by its UUID. Typically for use by administrators. Deletion may be soft (recommended), preserving history for audit and reference, or hard, depending on system policy and category usage.",
          "description": "Deletes (or marks as deleted) a category based on its unique ID. This operation usually employs soft-deletion: the category is flagged so it no longer appears in lists or selection menus, but remains in the database for historical tracking and audit purposes. Some implementations may require hard deletion if the category has no posts attached.\n\nPermission to use this operation is typically restricted to administrators. Attempts to delete active categories in use by posts may be rejected or require confirmation. All deletion attempts are logged for audit.\n\nError cases include non-existent category ID, attempts to delete categories linked to live posts, or insufficient permissions. Related endpoints: create, get, update, and list/search categories.",
          "summary": "Delete a category by ID (Core.categories)",
          "parameters": [
            {
              "name": "id",
              "description": "Unique ID of the target category",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Result of the delete operation, such as a confirmation message or status object.",
            "typeName": "ICategory.IDeleteResult"
          },
          "path": "/core/categories/{id}",
          "method": "delete"
        },
        {
          "specification": "This operation retrieves a paginated, searchable, and optionally sorted list of posts from the 'posts' table in the Posts schema. It supports filtering by category, author, date, title/content keywords, and includes pagination and ordering controls. This endpoint is core to board browsing, search results, and feeds. Security, filtering and personalization may vary by user role.",
          "description": "This API operation returns a list of posts (discussion threads or articles) with full support for filtering by category, author, or keywords, as well as sorting and pagination. Non-admin users typically see only non-deleted, non-archived posts, while administrators may have visibility into all post states. Standard search validation is performed for page, pageSize, and sort field inputs.\n\nThe endpoint supports community browsing, category threads, author-centric feeds, and search result pages. It also includes support for keyword-based full-text search on titles and content. Additional metadata such as comment and vote counts may be included per business requirements. Error handling addresses invalid filters, missing results, or backend errors.\n\nRelated to post retrieval (GET), post creation (POST), update (PUT), and delete (DELETE) endpoints, as well as comment and vote-related APIs.",
          "summary": "List and search posts (Posts.posts)",
          "parameters": [],
          "requestBody": {
            "description": "Criteria for searching, paging, and sorting posts.",
            "typeName": "IPost.IRequest"
          },
          "responseBody": {
            "description": "Paginated result of posts with summary data, and metadata for pagination.",
            "typeName": "IPageIPost"
          },
          "path": "/posts/posts",
          "method": "patch"
        },
        {
          "specification": "This operation retrieves a single post, identified by its unique UUID, from the 'posts' table in the Posts schema. The response includes all public fields, including author and category details, and is suitable for post detail pages, preview panels, or administrative tools. Ensures correct permissions and existence before providing detail.",
          "description": "Retrieves full details of a single post, identified by its unique ID. Returns all fields visible to the viewing user, such as title, content, author reference, category reference, creation and update times, etc. Admin users may access deleted posts if required, while normal users only see active posts.\n\nThis API is the primary source of detail for displaying or editing a discussion post. It validates the UUID input, and returns a 404 or permission error if the post does not exist or the user lacks rights.\n\nRelated endpoints: post list/search (PATCH), create (POST), update (PUT), delete (DELETE). Also supports comment and voting APIs.",
          "summary": "Retrieve specific post by ID (Posts.posts)",
          "parameters": [
            {
              "name": "id",
              "description": "Unique ID of the target post",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "All detail fields of the requested post, as permitted by current user role.",
            "typeName": "IPost"
          },
          "path": "/posts/posts/{id}",
          "method": "get"
        },
        {
          "specification": "This operation creates a new post (discussion thread or article) in the 'posts' table in the Posts schema. Only authenticated users can create posts, which must be linked to a category and have a non-empty title and content. This is the core content-creation endpoint for the discussion board.",
          "description": "Allows a user to create a new post by providing required information such as category, title, and content. The new post is assigned to the authoring user and is inserted into the database. Creation may be subject to moderation or review depending on platform policies.\n\nInput validation includes ensuring a valid category reference, unique/valid title, and legitimate content (length, formatting). On success, the API returns the full details of the created post, including assigned UUID, timestamps, and author/category references.\n\nError cases include missing/invalid data, attempts to create a post in non-existent category, or by unauthorized/blocked users. Related endpoints: list/search (PATCH), get (GET), update (PUT), delete (DELETE); plus comment APIs.",
          "summary": "Create a new post (Posts.posts)",
          "parameters": [],
          "requestBody": {
            "description": "All information required for new post: categoryId, title, content.",
            "typeName": "IPost.ICreate"
          },
          "responseBody": {
            "description": "Full detail for the newly created post, including IDs and timestamps.",
            "typeName": "IPost"
          },
          "path": "/posts/posts",
          "method": "post"
        },
        {
          "specification": "This operation updates the details of a specific post (by UUID) in the 'posts' table of the Posts schema. Permitted to the original author or admin, supports updating title, content, or possibly category. Validates updates for uniqueness and policy compliance.",
          "description": "Updates an existing post, referenced by its unique ID. Input may update title, content, and/or category reference. Only the author or an administrator/moderator may perform this operation. All updates are validated for required structure, content, and permission.\n\nPartial updates retain other fields unchanged. History tracking is enabled via timestamps. Changing category may have restrictions if the post has live comments. On success, returns updated post data; on failure, returns validation or permission errors.\n\nRelated endpoints: get, list/search, create, delete for posts. This endpoint supports editing discussion threads after posting.\n",
          "summary": "Update a post by ID (Posts.posts)",
          "parameters": [
            {
              "name": "id",
              "description": "Unique ID of the target post",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Fields to update for post (title, content, category).",
            "typeName": "IPost.IUpdate"
          },
          "responseBody": {
            "description": "The updated post's full details after saving changes.",
            "typeName": "IPost"
          },
          "path": "/posts/posts/{id}",
          "method": "put"
        },
        {
          "specification": "This operation deletes (or marks as deleted) a specific post in the 'posts' table of the Posts schema, referenced by its unique UUID. Used by the original author or admin. Implements soft-delete to comply with audit and policy requirements and preserve discussion history.",
          "description": "Deletes (or marks as deleted) a post record by its ID. Standard implementation is soft-deletion: post remains in database for moderation and audit but is removed from normal views and feeds. Only the original author, admin, or moderator can perform deletion. Attempts to delete posts with active comments or votes may be subject to business rule restrictions or warnings.\n\nAll delete actions are logged. The response provides confirmation or error. Related endpoints: create, get, update, and list/search for posts. Deletion cascades may apply to comments and votes as policy dictates.\n",
          "summary": "Delete a post by ID (Posts.posts)",
          "parameters": [
            {
              "name": "id",
              "description": "Unique ID of the target post",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Result or confirmation of post deletion (success, message, etc.)",
            "typeName": "IPost.IDeleteResult"
          },
          "path": "/posts/posts/{id}",
          "method": "delete"
        },
        {
          "specification": "Implements a list operation (search/pagination/filtering) for comments in the discussion board. This is based on the 'comments' table in the Posts domain (see Prisma schema 'comments'). Supports listing comments, optionally filtered by post, author, date range, or parent comment. Allows for pagination (offset/limit), keyword search, and sorting by creation date. Returns a paged list of comments with their relevant details and metadata.",
          "description": "This API retrieves a paged list of comments from the discussion board. Typically, users or moderators use it to see all comments on a specific thread, all comments by a particular user, or to moderate recent activity.\n\nThe route supports filtering (e.g., by postId, userId, parentId), pagination (offset/limit), full-text search on comment content, and sorting (e.g., newest first). Security considerations include only exposing non-deleted comments by default, unless requested by a privileged moderator/admin. Comment content is filtered to remove inappropriate language if the requester has insufficient privileges.\n\nIt references the 'comments' table (Posts domain). Query performance is optimized via relevant indexes. Related APIs include: create (POST /posts/comments), update (PUT /posts/comments/{id}), retrieve detail (GET /posts/comments/{id}), and delete (DELETE /posts/comments/{id}).\n\nInput validation includes correct types for filters, max page size, and valid sort orders. Error handling covers unauthorized access, malformed filters, and nonexistent references.",
          "summary": "Retrieve a filtered, paginated list of comments (Posts domain, 'comments' table).",
          "parameters": [],
          "requestBody": {
            "description": "Defines filtering, pagination, and sorting criteria for retrieving comments. Fields may include postId, userId, parentId, search, offset, limit, and sort.",
            "typeName": "IComment.IRequest"
          },
          "responseBody": {
            "description": "Paged list of comments matching given filters.",
            "typeName": "IPageIComment"
          },
          "path": "/posts/comments",
          "method": "patch"
        },
        {
          "specification": "Implements a retrieve operation for a single comment from the discussion board (get detail by id). This is based on 'comments' table (Posts domain). Used to get all properties and associations of a particular comment.",
          "description": "This API fetches the detail of a single comment in the discussion board by its unique ID. Common scenarios include users viewing a nested reply, moderators inspecting a reported comment, or when displaying a comment in thread view.\n\nIt returns full details such as content, author, timestamps, post reference, parent comment reference, and vote tallies. The route references the 'comments' table (Posts domain) and is optimized for quick retrieval. It will not return comments marked as deleted unless accessed by a user with sufficient privileges (e.g., moderator or admin).\n\nError handling includes returning appropriate errors for nonexistent, deleted, or unauthorized access. Related APIs: listing (PATCH /posts/comments), update (PUT /posts/comments/{id}), creation (POST /posts/comments), and deletion (DELETE /posts/comments/{id}).",
          "summary": "Fetch detailed information about a single comment (Posts domain, 'comments' table).",
          "parameters": [
            {
              "name": "id",
              "description": "Target comment's ID",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Full comment info, including content, author, timestamps, post and parent references.",
            "typeName": "IComment"
          },
          "path": "/posts/comments/{id}",
          "method": "get"
        },
        {
          "specification": "Implements the creation of a new comment in the discussion board (threaded reply system). This is based on the 'comments' table in Posts domain. A registered user can post a top-level or nested comment, referencing a post and optional parent comment.",
          "description": "This API lets a registered user create a new comment (either as a direct reply to a post or as a nested reply to another comment). Necessary fields include the content, target postId, and optionally a parentId (for replies-to-replies).\n\nInput is validated for minimum/maximum length, appropriate content, and ensuring the parent exists and belongs to the same post. The endpoint checks author authentication and standard anti-abuse policies (e.g., rate limiting). On success, it returns the created comment record with all metadata (author, timestamp, etc.).\n\nBusiness logic from the 'comments' table (Posts domain) is implemented: only registered users may comment; soft deletion rules apply. Related endpoints: retrieval (GET /posts/comments/{id}), update (PUT /posts/comments/{id}), and listing (PATCH /posts/comments).",
          "summary": "Create a new comment (Posts domain, 'comments' table).",
          "parameters": [],
          "requestBody": {
            "description": "New comment data, including content, postId, and optional parentId.",
            "typeName": "IComment.ICreate"
          },
          "responseBody": {
            "description": "The newly created comment record, with full metadata.",
            "typeName": "IComment"
          },
          "path": "/posts/comments",
          "method": "post"
        },
        {
          "specification": "Implements update (edit) of an existing comment in the discussion board (Posts domain, 'comments' table). Allows the original author (or moderator/admin) to modify content or mark as deleted. Can only be performed on non-deleted comments (unless by a moderator).",
          "description": "This API allows an authorized user (typically the comment's original author or a moderator/admin) to update the content or status of a comment. Supported fields for update include content (for editing), and soft deletion flag.\n\nChecks include author authentication, edit time-window (if enforced by policy), and protection against editing after moderation/deletion. Input validation ensures updated content meets platform standards, and references are unaltered (cannot change post or parentId).\n\nThe endpoint references the 'comments' table (Posts domain). On success, returns the updated comment object. Error scenarios include not found, unauthorized modification, or invalid updates. Related APIs: create (POST /posts/comments), retrieve (GET /posts/comments/{id}), delete (DELETE /posts/comments/{id}).",
          "summary": "Update an existing comment's content or deletion status (Posts domain, 'comments' table).",
          "parameters": [
            {
              "name": "id",
              "description": "The target comment's ID to update",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Fields to update in the comment (content and/or soft delete).",
            "typeName": "IComment.IUpdate"
          },
          "responseBody": {
            "description": "The updated comment record.",
            "typeName": "IComment"
          },
          "path": "/posts/comments/{id}",
          "method": "put"
        },
        {
          "specification": "Implements delete (soft deletion) of a comment in the discussion board (Posts domain, 'comments' table). Normally used by the original author or moderator. The record is flagged as deleted, not physically removed.",
          "description": "This API performs a soft deletion (marks as deleted) of a comment identified by its ID. Typical scenarios: the comment's author chooses to remove their reply, or a moderator removes content that violates policy. The comment remains in the database (for auditability), but becomes invisible to regular users and excluded from normal listings.\n\nAuthorization checks enforce only the author, moderator, or admin can perform this. Related error handling includes not found, already deleted, and unauthorized access. Audit logs are typically recorded. Related endpoints: create (POST /posts/comments), update (PUT /posts/comments/{id}), retrieve (GET /posts/comments/{id}), list (PATCH /posts/comments).",
          "summary": "Soft-delete a comment (Posts domain, 'comments' table).",
          "parameters": [
            {
              "name": "id",
              "description": "The comment's ID to delete",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Indicates successful deletion or details if already deleted.",
            "typeName": "IComment.IDeleteResult"
          },
          "path": "/posts/comments/{id}",
          "method": "delete"
        },
        {
          "specification": "Implements list/search with filtering, sorting, and pagination for votes in the discussion board. Based on 'votes' table (Votes domain). Used by admins/moderators to audit voting patterns, or by users to see their own history. Can filter by user, target post, or comment.",
          "description": "This API returns a list of vote records, most commonly used for reviewing moderation history, analytics, or a user's own votes. Supports filtering by userId, postId, or commentId; pagination (offset/limit); sort order (most recent, oldest first). Optionally, can search for patterns if metadata fields exist.\n\nReferences the 'votes' table (Votes domain) and makes use of unique constraints (one vote per user per item) in its filtering logic. Security notes: regular users can only see their own votes, admins/moderators may audit all. Related endpoints: create (POST /votes/votes), update (PUT /votes/votes/{id}), detail (GET /votes/votes/{id}), delete (DELETE /votes/votes/{id}).",
          "summary": "Retrieve a filtered, paginated list of votes (Votes domain, 'votes' table).",
          "parameters": [],
          "requestBody": {
            "description": "Filtering, pagination, and sorting for votes list. Fields: userId, postId, commentId, offset, limit, sort.",
            "typeName": "IVote.IRequest"
          },
          "responseBody": {
            "description": "Paged list of vote records matching given filters.",
            "typeName": "IPageIVote"
          },
          "path": "/votes/votes",
          "method": "patch"
        },
        {
          "specification": "Implements detail-retrieval of a single vote record by its ID (Votes domain, 'votes' table). Used by admins, or for users viewing their own voting history.",
          "description": "Fetches detail for a specific vote, identified by its unique ID. Useful for moderation review or self-audit by a voting user. Information includes which user voted, the value (+1/-1), what post/comment was targeted, and timestamps.\n\nReferences the 'votes' table (Votes domain). Only visible to the vote's owner or those with sufficient privilege. Error handling covers not found, unauthorized access, and malformed IDs. Related endpoints: create (POST /votes/votes), update (PUT /votes/votes/{id}), details (PATCH /votes/votes), delete (DELETE /votes/votes/{id}).",
          "summary": "Retrieve full details for a single vote (Votes domain, 'votes' table).",
          "parameters": [
            {
              "name": "id",
              "description": "Vote record's ID",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Full vote record, including user, content, and metadata.",
            "typeName": "IVote"
          },
          "path": "/votes/votes/{id}",
          "method": "get"
        },
        {
          "specification": "Implements creation of a new vote record in the Votes domain ('votes' table). Used when a user upvotes or downvotes a post or comment. Only registered users may vote; validation ensures only one vote per user per content item, with appropriate mutual exclusivity on postId/commentId.",
          "description": "Lets a user cast a vote—either upvote or downvote—on a post or comment. Input: must include user ID, value (+1/-1), and reference to either a post or a comment (but not both). Performs validation to ensure target exists and user has not already voted. On success, returns created vote record.\n\nVote limit: only one vote per user per content item, enforced via unique constraint. Can be used for voting analytics, user history, and tally calculations. Related endpoints: retrieve (GET /votes/votes/{id}), update (PUT /votes/votes/{id}), delete (DELETE /votes/votes/{id}), list (PATCH /votes/votes).",
          "summary": "Create a new vote (Votes domain, 'votes' table).",
          "parameters": [],
          "requestBody": {
            "description": "Cast a vote on a post or comment: must include value (+1 or -1) and target (postId or commentId).",
            "typeName": "IVote.ICreate"
          },
          "responseBody": {
            "description": "The newly created vote record.",
            "typeName": "IVote"
          },
          "path": "/votes/votes",
          "method": "post"
        },
        {
          "specification": "Implements vote modification (edit) in the Votes domain ('votes' table). Allows a user to change their vote value from +1 to -1 or vice versa. Only the owner or admin can perform edits; reference fields (postId/commentId) are locked after creation. Record must exist and not be deleted.",
          "description": "Lets a user (or moderator/admin) edit an existing vote—typically to change their upvote to downvote or vice versa, or to correct an input error. Only the vote's owner or privileged users may edit. Only value can change; postId or commentId are immutable.\n\nBusiness logic is enforced as per the 'votes' table (Votes domain): only one vote per user/content, mutual exclusivity between postId/commentId, and all references must remain valid. Returns the updated vote on success. Related endpoints: create (POST /votes/votes), retrieve (GET /votes/votes/{id}), list (PATCH /votes/votes), delete (DELETE /votes/votes/{id}).",
          "summary": "Edit an existing vote's value (Votes domain, 'votes' table).",
          "parameters": [
            {
              "name": "id",
              "description": "Vote record's ID to update",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Fields to update in the vote (only value may be changed).",
            "typeName": "IVote.IUpdate"
          },
          "responseBody": {
            "description": "The updated vote record.",
            "typeName": "IVote"
          },
          "path": "/votes/votes/{id}",
          "method": "put"
        },
        {
          "specification": "Implements deletion (removal) of a vote in the Votes domain ('votes' table). Used when a user or moderator wants to retract a vote or clean up invalid input. Removes the record entirely, adjusting content tallies as needed.",
          "description": "This endpoint removes a specific vote by its ID. Common use-cases: a user withdraws their vote or a moderator/admin removes a vote for violating policy. The vote is deleted from the database (hard delete), and any relevant tally is decremented.\n\nAuthorization checks ensure only the vote's owner or privileged roles may perform deletion. Related endpoints: create (POST /votes/votes), update (PUT /votes/votes/{id}), retrieve (GET /votes/votes/{id}), list (PATCH /votes/votes). Audit logging may be triggered for moderation actions.",
          "summary": "Delete a vote record from the database (Votes domain, 'votes' table).",
          "parameters": [
            {
              "name": "id",
              "description": "Vote record's ID to delete",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Indicates success or provides result details of the delete action.",
            "typeName": "IVote.IDeleteResult"
          },
          "path": "/votes/votes/{id}",
          "method": "delete"
        }
      ],
      "components": {
        "schemas": {
          "IPost.ISummary": {
            "type": "object",
            "description": "게시글(포스트)의 요약 정보를 제공하는 타입입니다. 목록 조회, 관계 프로퍼티 등에서 사용됩니다.\n\n게시글의 고유 ID, 제목, 작성자 ID, 카테고리 ID, 생성일, 수정일, 댓글/추천 등 카운트 필수 정보를 담고 있어, 리스트 UI 테이블/카드 등 요약 리스트용으로 활용합니다. 본문 전체나 관계 정보는 포함하지 않습니다.",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "게시글 고유 식별자(UUID). 예: '973c0116-ac2c-4ffb-b38b-7c4c45c7b2df'"
              },
              "user_id": {
                "type": "string",
                "format": "uuid",
                "description": "작성자(user)의 ID(UUID)"
              },
              "category_id": {
                "type": "string",
                "format": "uuid",
                "description": "속한 카테고리의 ID(UUID)"
              },
              "title": {
                "type": "string",
                "description": "게시글 제목"
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "게시글 작성일시(ISO8601)"
              },
              "updated_at": {
                "type": "string",
                "format": "date-time",
                "description": "게시글 마지막 수정 시각(ISO8601)"
              },
              "comment_count": {
                "type": "integer",
                "description": "해당 글의 댓글 개수"
              },
              "vote_count": {
                "type": "integer",
                "description": "해당 글의 추천(투표) 합계"
              }
            },
            "required": [
              "id",
              "user_id",
              "category_id",
              "title",
              "created_at",
              "updated_at",
              "comment_count",
              "vote_count"
            ]
          },
          "IUser.IRequest": {
            "type": "object",
            "properties": {
              "page": {
                "type": "integer",
                "format": "uint32",
                "description": "Page number for user list pagination. Optional field, aligns with standard best practices for paginated APIs.\n\nUsed to retrieve a specific page of user data. Default follows the IPage IRequest definition."
              },
              "limit": {
                "type": "integer",
                "format": "uint32",
                "description": "Number of users per page (for pagination). Optional, defaults to 100 if unspecified as per IPage specification.\n\nRestricts how many user records are returned in each page."
              },
              "role": {
                "type": "string",
                "format": "uuid",
                "description": "Filter by user role (user_roles.id) to return users with a specific role (e.g., member, moderator, administrator).\n\nHelps admins/moderators filter and locate users of a particular type or permission set."
              },
              "status": {
                "type": "string",
                "description": "Filter users by account status (e.g., 'active', 'suspended', 'banned').\n\nEnables moderation and administrative user management by quickly finding users in specific states."
              },
              "search": {
                "type": "string",
                "description": "Search string, matches username or email in user list queries.\n\nSupports quick filtering of users when searching by identifying fields; case-insensitive partial match."
              }
            },
            "description": "User list request/filter parameters, supporting pagination, search, and filtering by role or status.\n\nImplements board requirements around user management and moderation. Based on database and business rules from Core.users and relevant API operation specs.",
            "required": []
          },
          "IUser.ISummary": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "User's unique identifier (UUID).\n\nReferenced from users.id in the database, required for user profile lookups."
              },
              "username": {
                "type": "string",
                "description": "Public username (displayed in the board and visible to all users).\n\nUnique and required; serves as the user's main identifier for discussions, voting, and moderation."
              },
              "bio": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Optional user biography; a short self-description or interests section.\n\nMay be empty; helps other members know basic info about the user."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Optional user biography; a short self-description or interests section.\n\nMay be empty; helps other members know basic info about the user."
              },
              "role": {
                "$ref": "#/components/schemas/IUserRole.ISummary"
              },
              "status": {
                "type": "string",
                "description": "Current user account status (e.g., 'active', 'suspended', 'banned').\n\nReflects moderation, login eligibility, and enforcement of platform rules."
              }
            },
            "description": "Concise user summary as returned in user listing responses. Hides sensitive fields.\n\nIncludes only public profile, role summary, and status info. Used in paginated user lists and admin/member lookup features.",
            "required": [
              "id",
              "username",
              "role",
              "status"
            ]
          },
          "IUserRole.ISummary": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for user role (user_roles.id field).\n\nEnforces referential integrity for permission assignments."
              },
              "name": {
                "type": "string",
                "description": "Short label name for the user role (e.g., 'member', 'moderator', 'administrator').\n\nUsed in dropdowns, labels, admin tools. Required and unique per database schema."
              }
            },
            "description": "Summary/view version of a user role entity. Contains only essential fields (id, name).\n\nUsed for responses where full details are unnecessary but reference is required.",
            "required": [
              "id",
              "name"
            ]
          },
          "IPageIUser.ISummary": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IUser.ISummary"
                },
                "description": "Paginated list of user summaries matching request filters."
              }
            },
            "description": "Paginated user summary list container.\n\nStandardized IPage<T> wrapper for user listings, as per business requirements.",
            "required": [
              "pagination",
              "data"
            ]
          },
          "IUser": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique internal user ID (users.id). Used system-wide to link all user objects, references, and foreign keys.\n\nRequired; generated upon account creation and immutable."
              },
              "user_role_id": {
                "type": "string",
                "format": "uuid",
                "description": "Foreign key to user_roles.id; denotes the active permission set (member, moderator, admin, etc).\n\nRequired at creation; determines access, moderation, and board capabilities."
              },
              "username": {
                "type": "string",
                "description": "Unique public display name; visible to all, and referenced in discussion, voting, and moderation.\n\nDatabase-enforced as unique."
              },
              "email": {
                "type": "string",
                "format": "email",
                "description": "User's email address. Used for login and communication.\n\nNever displayed publicly. Must be unique."
              },
              "bio": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Free-form user biography/self-description.\n\nOptional, enhances social context on the board."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Free-form user biography/self-description.\n\nOptional, enhances social context on the board."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Account creation datetime (with timezone). Used for auditing, ordering, and admin reporting.\n\nImmutable."
              },
              "updated_at": {
                "type": "string",
                "format": "date-time",
                "description": "Most recent profile update timestamp for this user.\n\nUpdated whenever profile fields are changed."
              },
              "status": {
                "type": "string",
                "description": "Current account status (active, suspended, banned, etc.).\n\nEnforced per moderation/business rule policies."
              },
              "role": {
                "$ref": "#/components/schemas/IUserRole"
              },
              "posts": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IPost.ISummary"
                },
                "description": "Array of summaries for posts authored by the user (board threads or articles)."
              },
              "comments": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IComment.ISummary"
                },
                "description": "List of summaries for comments made by this user."
              },
              "votes": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IVote.ISummary"
                },
                "description": "Summary array of votes cast by the user on posts/comments."
              }
            },
            "required": [
              "id",
              "user_role_id",
              "username",
              "email",
              "created_at",
              "updated_at",
              "status",
              "role"
            ],
            "description": "Full user entity, as per users Prisma schema. Contains all non-confidential account info and relations.\n\nDetailed per-table and per-field documentation referenced from schema. Represents user profiles for detail pages and admin/mod tools."
          },
          "IUser.ICreate": {
            "type": "object",
            "properties": {
              "user_role_id": {
                "type": "string",
                "format": "uuid",
                "description": "Role assignment for new user; must match user_roles.id. Required at registration. E.g., 'member', 'moderator', or 'administrator'."
              },
              "username": {
                "type": "string",
                "description": "New user's unique public display name. Required, must be unique, visible on the board."
              },
              "email": {
                "type": "string",
                "format": "email",
                "description": "New user's email address. Required for registration, must be unique, never public."
              },
              "bio": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Optional user bio/about section. May be empty upon registration."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Optional user bio/about section. May be empty upon registration."
              },
              "password": {
                "type": "string",
                "description": "User password, plain text at registration. Required; will be securely hashed before storage. Never returned by API."
              },
              "status": {
                "type": "string",
                "description": "Initial status for user: normally 'active', but admin can specify e.g., 'pending', 'suspended'."
              }
            },
            "required": [
              "user_role_id",
              "username",
              "email",
              "password",
              "status"
            ],
            "description": "Request body schema for new user registration/account creation.\n\nAll required/optional fields per users model. Password is accepted as clear text but is hashed internally."
          },
          "IUser.IUpdate": {
            "type": "object",
            "properties": {
              "user_role_id": {
                "type": "string",
                "format": "uuid",
                "description": "(Optional) Role update for user. Admin/moderator action only. Must match an existing user_roles.id."
              },
              "username": {
                "type": "string",
                "description": "(Optional) Update to user's public display name. Must be unique if updated."
              },
              "email": {
                "type": "string",
                "format": "email",
                "description": "(Optional) Update to user's email address. Uniqueness required if changed."
              },
              "bio": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "(Optional) Update to bio/about me field."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "(Optional) Update to bio/about me field."
              },
              "status": {
                "type": "string",
                "description": "(Optional) Modify user account status (active, suspended, etc.)."
              },
              "updated_at": {
                "type": "string",
                "format": "date-time",
                "description": "Update timestamp; automatically set by the server on update."
              }
            },
            "required": [],
            "description": "Request body for updating an existing user profile/account.\n\nOnly fields supplied are updated; all are optional. Password change is NOT handled here."
          },
          "IUser.IDeleteResponse": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "ID of user deleted or marked for deletion. Used for reference in audit trails and deletion confirmations."
              },
              "status": {
                "type": "string",
                "description": "Status message (e.g., 'deleted', 'suspended', etc.) after deletion/disable action."
              }
            },
            "description": "Response for user deletion operation. Contains minimal identifying and audit info.\n\nDoes not reveal sensitive user fields.",
            "required": []
          },
          "IUserRole.IRequest": {
            "type": "object",
            "properties": {
              "page": {
                "type": "integer",
                "format": "uint32",
                "description": "Page number for role list pagination. Optional; aligns with IPage best-practice."
              },
              "limit": {
                "type": "integer",
                "format": "uint32",
                "description": "Pagination limit for number of roles per page. Defaults to 100 if missing.\n\nStandard for IPage APIs."
              },
              "search": {
                "type": "string",
                "description": "Keyword filter for role name or description fields. Enables quick role lookup."
              }
            },
            "description": "List/request filtering schema for user roles table.\n\nSupports pagination, keyword search for role management dashboards, registration, and editor widgets.",
            "required": []
          },
          "IPageIUserRole": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IUserRole"
                },
                "description": "Array of role entities for administrative/user assignment purposes."
              }
            },
            "description": "Paginated wrapper of user roles, for admin lookup and registration dropdowns.\n\nImplements standard IPage format with list of IUserRole.",
            "required": [
              "pagination",
              "data"
            ]
          },
          "IUserRole": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique ID for this user role entry.\n\nPrimary key in user_roles. Required for all entity referencing (assignment, lookup, etc.)."
              },
              "name": {
                "type": "string",
                "description": "Machine- and human-readable name for the user role, e.g., 'member', 'moderator', or 'administrator'.\n\nMust be unique, and required for referential integrity."
              },
              "description": {
                "type": "string",
                "description": "Human explanation of what privileges and duties this role holds.\n\nAids in assigning and documenting permissions for users. Required for compliance with admin/business rule traceability."
              },
              "users": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IUser.ISummary"
                },
                "description": "(For reference/audit) Array of users holding this role. May be omitted if not required at runtime."
              }
            },
            "required": [
              "id",
              "name",
              "description"
            ],
            "description": "Full user role entity, as per user_roles Prisma model. Details all privilege/permission details, assignment context, and required unique properties."
          },
          "IUserRole.ICreate": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "Unique name for new role; will become user_roles.name. E.g., 'moderator', 'editor', or custom label."
              },
              "description": {
                "type": "string",
                "description": "Text description covering what the role enables/limits for users assigned to it."
              }
            },
            "required": [
              "name",
              "description"
            ],
            "description": "Request schema for creating new user roles.\n\nAllows admin tools to set up new permissions/policies in the board, with full business rule auditing."
          },
          "IUserRole.IUpdate": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "(Optional) New/updated role name. Must remain unique if updated."
              },
              "description": {
                "type": "string",
                "description": "(Optional) Update/extend role meaning or allowed actions."
              }
            },
            "required": [],
            "description": "Request schema for editing an existing user role entry.\n\nAll fields optional; only modified fields must be sent."
          },
          "IUserRole.IDeleteResponse": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "ID of user role entry deleted or marked deleted. For audit and post-delete reference."
              },
              "status": {
                "type": "string",
                "description": "Delete or audit status: e.g., 'deleted', 'archived', 'in use - not deleted'."
              }
            },
            "description": "Response schema for confirming user role deletion (admin-only).\n\nIncludes minimal info required for audit logs and error/success reporting.",
            "required": []
          },
          "IPage.IPagination": {
            "type": "object",
            "properties": {
              "current": {
                "type": "integer",
                "format": "uint32",
                "description": "Current page number."
              },
              "limit": {
                "type": "integer",
                "format": "uint32",
                "description": "Limitation of records per a page. Default: 100."
              },
              "records": {
                "type": "integer",
                "format": "uint32",
                "description": "Total records in the database."
              },
              "pages": {
                "type": "integer",
                "format": "uint32",
                "description": "Total number of pages (records/limit, ceiled)."
              }
            },
            "required": [
              "current",
              "limit",
              "records",
              "pages"
            ],
            "description": "Pagination metadata for paged responses, including current/limit/total/pageCount as per business requirements and search usability."
          },
          "ICategory.IRequest": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "필터링 또는 검색을 위한 카테고리 이름입니다.\n\n예: '정치', '경제'"
              },
              "description": {
                "type": "string",
                "description": "카테고리 설명의 검색을 위한 옵션 필드입니다.\n\n예: '정치 체계와 관련된 논의', '국제 경제 토론'"
              },
              "created_from": {
                "type": "string",
                "format": "date-time",
                "description": "검색 시작일자(ISO8601 형식). 예: '2024-06-09T00:00:00+09:00'."
              },
              "created_to": {
                "type": "string",
                "format": "date-time",
                "description": "검색 종료일자(ISO8601 형식). 예: '2024-07-09T23:59:59+09:00'."
              },
              "page": {
                "type": "integer",
                "description": "페이지 번호(1부터 시작).",
                "minimum": 1
              },
              "limit": {
                "type": "integer",
                "description": "페이지당 반환할 레코드 수(기본값 100).",
                "minimum": 1
              }
            },
            "description": "카테고리 리스트/검색 요청에 이용되는 필터, 검색, 페이징 정보 객체입니다.\n\n카테고리 명, 설명, 기간 필터, 페이징 조작(페이지, limit) 등 검색 옵션을 다루며, 관리자 또는 일반 사용자의 카테고리 목록 검색 시 활용됩니다.",
            "required": [
              "page",
              "limit"
            ]
          },
          "IPageICategory": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination",
                "description": "페이지네이션 정보로, 현재 페이지, 전체 레코드 수, 전체 페이지 수 등을 제공합니다."
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ICategory"
                },
                "description": "카테고리 목록 데이터 배열입니다."
              }
            },
            "description": "카테고리 검색/조회 결과를 담는 페이지 컨테이너 타입입니다.\n\n페이지네이션 메타데이터와 함께 실제 데이터 목록(카테고리 배열)을 포함해, 목록 화면 및 검색 결과에서 활용합니다.",
            "required": [
              "pagination",
              "data"
            ]
          },
          "ICategory": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "카테고리의 고유 식별자(UUID).\n\nPrisma 'categories.id' 컬럼. 예: 'b4682df2-b264-4e1b-807d-381340390a64'."
              },
              "name": {
                "type": "string",
                "description": "카테고리 이름(고유).\n\nPrisma 'categories.name' 컬럼. 예: '정치', '경제'"
              },
              "description": {
                "type": "string",
                "description": "카테고리 상세 설명.\n\nPrisma 'categories.description' 컬럼. 예: '정치 제도와 관련된 모든 주제를 다룹니다.'"
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "카테고리 생성 일시(ISO8601).\n\nPrisma 'categories.created_at' 컬럼. 예: '2024-06-09T09:00:00+09:00'."
              }
            },
            "required": [
              "id",
              "name",
              "description",
              "created_at"
            ],
            "description": "토론 게시판의 주제분류(카테고리) 정보를 담는 엔터티입니다.\n\n각 카테고리는 고유명, 설명, 생성일시 필드를 가지며 게시글(Posts)과 1:N 관계입니다. 관리자가 생성·관리하며, 게시글 작성 시 반드시 할당해야 하는 구조입니다."
          },
          "ICategory.ICreate": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "신규 카테고리의 이름(고유). 예: '시사', '국제'."
              },
              "description": {
                "type": "string",
                "description": "카테고리 상세 설명. 예: '글로벌 경제 및 정치 이슈를 다루는 공간입니다.'"
              }
            },
            "required": [
              "name",
              "description"
            ],
            "description": "카테고리 신규 생성시 전달하는 요청 바디 객체입니다.\n\n이름(고유), 설명을 필수로 제공해야 하며, 관리자가 카테고리를 추가할 때 활용됩니다."
          },
          "ICategory.IUpdate": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "변경할 카테고리명(옵션). 예: '사회'"
              },
              "description": {
                "type": "string",
                "description": "변경할 카테고리 설명(옵션)."
              }
            },
            "description": "기존 카테고리의 이름·설명을 수정하는 요청 바디입니다.\n\n두 필드 모두 선택적이며, 하나 또는 모두 변경할 수 있습니다.",
            "required": []
          },
          "ICategory.IDeleteResult": {
            "type": "object",
            "properties": {
              "success": {
                "type": "boolean",
                "description": "삭제 성공 여부. true 이면 정상 삭제, false 이면 오류."
              },
              "message": {
                "type": "string",
                "description": "삭제 결과 메시지(실패 이유, 성공 안내 등)."
              }
            },
            "required": [
              "success",
              "message"
            ],
            "description": "카테고리 삭제(soft/hard delete) 결과를 나타내는 오브젝트입니다.\n\n성공/실패의 플래그 및 설명 메시지를 포함해 후처리 사용자 안내에 활용합니다."
          },
          "IPost.IRequest": {
            "type": "object",
            "properties": {
              "category_id": {
                "type": "string",
                "format": "uuid",
                "description": "검색/필터링용 카테고리 ID.\n\n특정 카테고리 내 게시글만 조회하고자 할 때 사용합니다."
              },
              "user_id": {
                "type": "string",
                "format": "uuid",
                "description": "검색/필터링용 작성자(유저) ID.\n\n특정 사용자가 작성한 게시글만 조회할 때 활용합니다."
              },
              "title": {
                "type": "string",
                "description": "제목 키워드 검색 (부분 일치 허용).\n\n게시글의 제목에 포함된 키워드로 검색합니다."
              },
              "content": {
                "type": "string",
                "description": "본문 키워드 검색 (부분 일치 허용).\n\n게시글의 전체 텍스트에서 키워드로 검색합니다."
              },
              "created_from": {
                "type": "string",
                "format": "date-time",
                "description": "게시글 생성 시작일(검색 필터용, ISO8601)."
              },
              "created_to": {
                "type": "string",
                "format": "date-time",
                "description": "게시글 생성 종료일(검색 필터용, ISO8601)."
              },
              "page": {
                "type": "integer",
                "description": "페이지 번호(1 이상).",
                "minimum": 1
              },
              "limit": {
                "type": "integer",
                "description": "페이지당 데이터 수(기본 100).",
                "minimum": 1
              }
            },
            "description": "게시글 검색, 필터, 페이징에 요청 정보로 사용되는 객체입니다.\n\n카테고리, 작성자, 키워드, 기간, 페이징 등 다양한 필터를 지원하여 게시글 탐색 UX를 구현합니다.",
            "required": [
              "page",
              "limit"
            ]
          },
          "IPageIPost": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination",
                "description": "페이지네이션 메타데이터"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IPost"
                },
                "description": "검색 결과 게시글(Posts) 배열"
              }
            },
            "required": [
              "pagination",
              "data"
            ],
            "description": "게시글 검색/조회 결과를 담는 페이지 컨테이너 타입입니다.\n\n페이지 정보와 게시글 배열을 함께 반환하여 결과 화면에서 활용합니다."
          },
          "IPost": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "게시글의 고유 ID (Prisma 'posts.id')."
              },
              "user_id": {
                "type": "string",
                "format": "uuid",
                "description": "작성자(유저) ID (Prisma 'posts.user_id')."
              },
              "category_id": {
                "type": "string",
                "format": "uuid",
                "description": "카테고리 ID (Prisma 'posts.category_id')."
              },
              "title": {
                "type": "string",
                "description": "게시글 제목 (Prisma 'posts.title')."
              },
              "content": {
                "type": "string",
                "description": "게시글 본문 (Prisma 'posts.content')."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "생성 시각 (Prisma 'posts.created_at')."
              },
              "updated_at": {
                "type": "string",
                "format": "date-time",
                "description": "수정 시각 (Prisma 'posts.updated_at')."
              },
              "deleted_at": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "삭제(soft delete) 시각(Prisma 'posts.deleted_at'). 삭제 안된 경우 null."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "삭제(soft delete) 시각(Prisma 'posts.deleted_at'). 삭제 안된 경우 null."
              }
            },
            "required": [
              "id",
              "user_id",
              "category_id",
              "title",
              "content",
              "created_at",
              "updated_at"
            ],
            "description": "토론 게시판의 게시글(포스트) 정보를 담는 도메인 오브젝트입니다.\n\n작성자, 카테고리, 제목·본문, 생성/수정/삭제일 등을 보유하여 커뮤니티 핵심 콘텐츠 구조를 이룹니다."
          },
          "IPost.ICreate": {
            "type": "object",
            "properties": {
              "category_id": {
                "type": "string",
                "format": "uuid",
                "description": "작성할 게시글의 카테고리 ID. (필수)"
              },
              "title": {
                "type": "string",
                "description": "게시글 제목. 예: '2025년 물가·인플레이션 전망'"
              },
              "content": {
                "type": "string",
                "description": "게시글 본문 내용. (텍스트·포맷팅 지원)"
              },
              "user_id": {
                "type": "string",
                "format": "uuid",
                "description": "작성자(Author) ID. 회원 작성 시 필수"
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "생성시각 (시스템 자동 할당이지만, 조직 배치용으로도 허용될 수 있음)"
              }
            },
            "required": [
              "category_id",
              "title",
              "content",
              "user_id"
            ],
            "description": "게시글 신규 작성 요청에 전달되는 바디입니다.\n\n카테고리, 제목, 본문, 작성자 정보를 반드시 포함해야 합니다. 생성일시 등은 서버에서 자동 처리합니다."
          },
          "IPost.IUpdate": {
            "type": "object",
            "properties": {
              "title": {
                "type": "string",
                "description": "변경할 게시글 제목 (옵션)"
              },
              "content": {
                "type": "string",
                "description": "변경할 게시글 본문 (옵션)"
              },
              "category_id": {
                "type": "string",
                "format": "uuid",
                "description": "변경할 카테고리 ID (옵션)"
              }
            },
            "description": "기존 게시글(포스트)의 제목/본문/카테고리를 수정하는 요청 바디입니다.\n\n각 필드는 선택값으로, 일부만 수정 가능하며 누락시 기존 값 유지합니다.",
            "required": []
          },
          "IPost.IDeleteResult": {
            "type": "object",
            "properties": {
              "success": {
                "type": "boolean",
                "description": "삭제(Soft 또는 Hard) 성공 여부"
              },
              "message": {
                "type": "string",
                "description": "삭제 결과 메시지"
              }
            },
            "required": [
              "success",
              "message"
            ],
            "description": "게시글 삭제(soft/hard) 요청 결과나 상태를 반환하는 결과 객체입니다.\n\n정상 삭제(숨김) 시 success=true, 실패 시 false와 설명 메시지를 제공합니다."
          },
          "IComment.IRequest": {
            "type": "object",
            "properties": {
              "postId": {
                "type": "string",
                "format": "uuid",
                "description": "The unique ID of the target post to which comments should be filtered.\n\nBased on the comments table, 'post_id' field links the comment to a particular post for thread-based filtering. Sourced from the business rule: 'Each Comment is linked to a Post.'"
              },
              "userId": {
                "type": "string",
                "format": "uuid",
                "description": "The unique ID of the user who authored comments.\n\nDesigned for filtering comments made by a specific user, as referenced in the comments.user_id column."
              },
              "parentId": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "The parent comment's ID, for retrieving or searching nested replies.\n\nThis relates to the self-referential thread system: filtering for replies to a specific comment."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "The parent comment's ID, for retrieving or searching nested replies.\n\nThis relates to the self-referential thread system: filtering for replies to a specific comment."
              },
              "search": {
                "type": "string",
                "description": "A keyword or phrase to search in comment content.\n\nImplements full-text search capability as referenced in content field and API description."
              },
              "offset": {
                "type": "integer",
                "format": "int32",
                "default": 0,
                "description": "The starting index for pagination.\n\nAllows skipping records in list pagination, supporting usability in large thread navigation."
              },
              "limit": {
                "type": "integer",
                "format": "int32",
                "default": 20,
                "description": "Maximum number of records to return per page. Defaults to 20 if not specified."
              },
              "sort": {
                "type": "string",
                "description": "Sorting order or field, e.g., 'created_at:desc', 'created_at:asc'.\n\nAligns with thread listing sorting as described in business and API requirements."
              }
            },
            "description": "Defines filtering, pagination, and sorting criteria for retrieving comments. Fields draw directly from the requirements and Prisma comments model.\n\nThis allows filtering by comments made on a post, by a user, or as replies to a parent, along with keyword search and pagination. Reflects full API and business use cases for comment listing endpoints.",
            "required": []
          },
          "IPageIComment": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IComment.ISummary"
                },
                "description": "A list of comment summary objects on the current page.\n\nEach item is a concise representation of a comment as described in business use-cases: post/reply thread listings."
              }
            },
            "required": [
              "pagination",
              "data"
            ],
            "description": "A paginated list of comment summaries, including pagination metadata (page, limit, total, etc.) and a summary array.\n\nCombines IPage (standard) with IComment.ISummary as required by comment browsing scenarios."
          },
          "IComment": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Primary Key. Unique identifier for each comment (see comments.id in schema).\n\nAssigned at creation; required for retrieval, update, and reference by other entities (votes, replies)."
              },
              "user_id": {
                "type": "string",
                "format": "uuid",
                "description": "Author's {@link users.id}.\n\nStores the user's unique identifier responsible for the comment, using the relationship to users. Enables auditing, author lookup, and permissions checks."
              },
              "post_id": {
                "type": "string",
                "format": "uuid",
                "description": "The ID of the post this comment is attached to ({@link posts.id}).\n\nCrucial for associating the comment as a reply to a given post, reflecting business rules and ERD documentation."
              },
              "parent_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "Parent comment's {@link comments.id}.\n\nUsed for nested (threaded) replies. Null for top-level comments. Enables tree-based conversations."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Parent comment's {@link comments.id}.\n\nUsed for nested (threaded) replies. Null for top-level comments. Enables tree-based conversations."
              },
              "content": {
                "type": "string",
                "description": "Main text of the comment; user-provided reply content.\n\nReferences the comments.content field; holds message body visible to users."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp when the comment was first authored (see comments.created_at).\n\nUsed for chronological ordering, moderation, and audit."
              },
              "updated_at": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp of last edit to the comment (see comments.updated_at).\n\nEnables edit history, moderation, or user accountability."
              },
              "deleted_at": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "Soft deletion timestamp (see comments.deleted_at).\n\nNull if not deleted; otherwise contains date/time when marked deleted for moderation/auditing."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Soft deletion timestamp (see comments.deleted_at).\n\nNull if not deleted; otherwise contains date/time when marked deleted for moderation/auditing."
              }
            },
            "required": [
              "id",
              "user_id",
              "post_id",
              "content",
              "created_at",
              "updated_at"
            ],
            "description": "Represents a Comment record, as per the Posts domain comments model and requirements analysis.\n\nIncludes all primary properties as described in the Prisma schema, with full typing and references to related entities (users, posts, parent comments). Supports auditability, moderation, and business logic for threaded conversations."
          },
          "IComment.ICreate": {
            "type": "object",
            "properties": {
              "user_id": {
                "type": "string",
                "format": "uuid",
                "description": "User ID (author's identifier). Must reference an existing user. Required to ensure only registered users may comment.\n\nFulfills business rule that only registered users can create comments."
              },
              "post_id": {
                "type": "string",
                "format": "uuid",
                "description": "ID of the post this comment is on. Implements business rule requiring every comment to be attached to a post."
              },
              "parent_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "Parent comment's ID for nested replies. Optional. Enables thread hierarchy as in the business requirements."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Parent comment's ID for nested replies. Optional. Enables thread hierarchy as in the business requirements."
              },
              "content": {
                "type": "string",
                "description": "Main comment body text. Required; validated for length and content rules by business logic."
              }
            },
            "required": [
              "user_id",
              "post_id",
              "content"
            ],
            "description": "Object for creating a new comment. Includes required properties for new replies, including references to post, author, and optionally a parent for nested threading. Matches business rules requiring each comment to have an associated user (author) and post, plus the option to nest under another comment."
          },
          "IComment.IUpdate": {
            "type": "object",
            "properties": {
              "content": {
                "type": "string",
                "description": "New comment body, if editing. Must meet length/content requirements from business logic."
              },
              "deleted_at": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "Timestamp for marking a comment as deleted (for moderation/audit). Set to current time for 'soft delete,' or null to un-delete if allowed."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Timestamp for marking a comment as deleted (for moderation/audit). Set to current time for 'soft delete,' or null to un-delete if allowed."
              }
            },
            "description": "Object for updating an existing comment (edit or soft-delete). User or moderator may use this to change content or to mark the comment as deleted.\n\nReferences the comments Prisma model and moderation business rules: only content or soft-delete flag is usually editable.",
            "required": []
          },
          "IComment.IDeleteResult": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "ID of the comment that was deleted."
              },
              "deleted": {
                "type": "boolean",
                "description": "Status: true if successfully deleted (soft or hard as per policy), false otherwise."
              },
              "message": {
                "type": "string",
                "description": "A confirmation or informative message about the deletion result."
              }
            },
            "required": [
              "id",
              "deleted"
            ],
            "description": "Result object for delete operations on comments. Confirms deletion (soft or hard), as required by business rules and audit requirements. Returns the comment ID, deletion status, and optional human-readable message."
          },
          "IVote.IRequest": {
            "type": "object",
            "properties": {
              "userId": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier of the user who cast the vote. Used for filtering votes by a specific voter (see votes.user_id in schema and ERD)."
              },
              "postId": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the post that received the vote (see votes.post_id). Mutually exclusive with commentId."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Unique identifier of the post that received the vote (see votes.post_id). Mutually exclusive with commentId."
              },
              "commentId": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier of the comment that received the vote (see votes.comment_id). Mutually exclusive with postId."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Unique identifier of the comment that received the vote (see votes.comment_id). Mutually exclusive with postId."
              },
              "offset": {
                "type": "integer",
                "format": "int32",
                "default": 0,
                "description": "Starting index for pagination (default 0)."
              },
              "limit": {
                "type": "integer",
                "format": "int32",
                "default": 20,
                "description": "Maximum number of records to return per page."
              },
              "sort": {
                "type": "string",
                "description": "Sorting field or order (default 'created_at:desc')."
              }
            },
            "description": "Filtering, pagination, and sorting criteria for votes listing requests, following the votes table business logic and related requirements.\n\nFilters support querying by voter, target post, or comment, with support for pagination and sorting. Business rules enforce only mutual exclusivity between postId/commentId (never both set).",
            "required": []
          },
          "IPageIVote": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IVote.ISummary"
                },
                "description": "Array of vote summary records on this page."
              }
            },
            "required": [
              "pagination",
              "data"
            ],
            "description": "A paginated set of votes, as used in vote listing, audit history, or analytics use-cases. Follows IPage pattern with IVote.ISummary records per voting business and DB design."
          },
          "IVote": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Primary Key. Unique identifier for each vote record (votes.id)."
              },
              "user_id": {
                "type": "string",
                "format": "uuid",
                "description": "The ID of the user casting the vote (votes.user_id), referencing users table for author."
              },
              "post_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "The voted post's ID (votes.post_id). Mutually exclusive with comment_id."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "The voted post's ID (votes.post_id). Mutually exclusive with comment_id."
              },
              "comment_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "The voted comment's ID (votes.comment_id). Mutually exclusive with post_id."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "The voted comment's ID (votes.comment_id). Mutually exclusive with post_id."
              },
              "value": {
                "type": "integer",
                "description": "Value of the vote (+1 for upvote, -1 for downvote). Aggregated to compute content rankings."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp of when the vote was created (votes.created_at)."
              }
            },
            "required": [
              "id",
              "user_id",
              "value",
              "created_at"
            ],
            "description": "Represents a Vote as defined in the votes table: one record for each upvote/downvote action on a post or comment. Covers voter ID, target (post or comment), value (+1/-1), and creation timestamp. Fully aligned with requirements analysis and business logic for single-vote-per-user-per-content."
          },
          "IVote.ICreate": {
            "type": "object",
            "properties": {
              "user_id": {
                "type": "string",
                "format": "uuid",
                "description": "ID of the user casting the vote. References the users table; ensures only registered users can vote."
              },
              "value": {
                "type": "integer",
                "description": "Vote value: +1 or -1 as per business requirements. Used for up/down voting of posts/comments."
              },
              "post_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "Target post's ID, if voting on a post. Mutually exclusive with comment_id."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Target post's ID, if voting on a post. Mutually exclusive with comment_id."
              },
              "comment_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "Target comment's ID, if voting on a comment. Mutually exclusive with post_id."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Target comment's ID, if voting on a comment. Mutually exclusive with post_id."
              }
            },
            "required": [
              "user_id",
              "value"
            ],
            "description": "Object for creating a new vote as per voting business rules:\n- user_id: registered voter\n- value: +1 (upvote) or -1 (downvote)\n- target: must specify either post_id or comment_id (never both)\nEnforces one vote per user/content as described in requirements."
          },
          "IVote.IUpdate": {
            "type": "object",
            "properties": {
              "value": {
                "type": "integer",
                "description": "The new vote value. Allows changing an upvote to downvote (or vice versa), strictly for existing votes per business rules."
              }
            },
            "required": [
              "value"
            ],
            "description": "Object for updating existing votes, specifically editing the vote value (from +1 to -1, etc.).\n\nDoes not allow changing the vote target (post_id/comment_id); supports audit and business logic for corrections."
          },
          "IVote.IDeleteResult": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "ID of the vote record that was deleted."
              },
              "deleted": {
                "type": "boolean",
                "description": "Indicates if the vote was successfully deleted."
              },
              "message": {
                "type": "string",
                "description": "A human-readable confirmation message about the delete operation."
              }
            },
            "required": [
              "id",
              "deleted"
            ],
            "description": "Delete operation result for a vote record. Returns deleted vote's ID, deletion status, and optional result message, as required by business logic and for user/admin confirmation."
          },
          "IComment.ISummary": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for the comment."
              },
              "user_id": {
                "type": "string",
                "format": "uuid",
                "description": "User (author) of the comment."
              },
              "post_id": {
                "type": "string",
                "format": "uuid",
                "description": "Parent post for the comment."
              },
              "parent_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "Parent comment (if any)."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Parent comment (if any)."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp of comment creation."
              }
            },
            "required": [
              "id",
              "user_id",
              "post_id",
              "created_at"
            ],
            "description": "A concise summary type for comments, covering the most important references and metadata for paginated or overview lists."
          },
          "IVote.ISummary": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for the vote."
              },
              "user_id": {
                "type": "string",
                "format": "uuid",
                "description": "Voter's user ID."
              },
              "post_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "Target post."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Target post."
              },
              "comment_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "Target comment."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Target comment."
              },
              "value": {
                "type": "integer",
                "description": "Vote value (+1 or -1)."
              }
            },
            "required": [
              "id",
              "user_id",
              "value"
            ],
            "description": "Summary of a Vote for paginated/result lists, not including creation date but identifying all main relationships and value."
          }
        }
      }
    },
    "files": {
      ".env.local": "API_PORT=37001",
      ".eslintrc.cjs": "module.exports = {\n  root: true,\n  plugins: [\"@typescript-eslint\", \"deprecation\"],\n  extends: [\"plugin:@typescript-eslint/recommended\"],\n  parser: \"@typescript-eslint/parser\",\n  parserOptions: {\n    project: [\"tsconfig.json\", \"test/tsconfig.json\"],\n  },\n  overrides: [\n    {\n      files: [\"src/**/*.ts\", \"test/**/*.ts\"],\n      rules: {\n        \"@typescript-eslint/consistent-type-definitions\": \"off\",\n        \"@typescript-eslint/no-empty-function\": \"off\",\n        \"@typescript-eslint/no-empty-interface\": \"off\",\n        \"@typescript-eslint/no-explicit-any\": \"off\",\n        \"@typescript-eslint/no-inferrable-types\": \"off\",\n        \"@typescript-eslint/no-namespace\": \"off\",\n        \"@typescript-eslint/no-non-null-assertion\": \"off\",\n        \"@typescript-eslint/no-unused-vars\": \"off\",\n        \"@typescript-eslint/no-var-requires\": \"off\",\n        \"@typescript-eslint/no-floating-promises\": \"error\",\n        \"@typescript-eslint/no-require-imports\": \"off\",\n        \"@typescript-eslint/no-empty-object-type\": \"off\",\n      },\n    },\n  ],\n};\n",
      ".github/workflows/build.yml": "name: build\non:\n  pull_request:\n    paths:\n      - 'src/**'\n      - 'test/**'\n      - 'package.json'\njobs:\n  Ubuntu:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20.x\n      - uses: pnpm/action-setup@v4\n        with:\n          version: 8\n      \n      - name: Install Backend-Server\n        run: pnpm install\n\n      - name: Build Swagger\n        run: npm run build:swagger\n\n      - name: Build SDK\n        run: npm run build:sdk\n\n      - name: Compile Backend-Server\n        run: npm run build\n\n      - name: Run Test Program\n        run: npm run test -- --simultaneous 16\n\n      - name: EsLint\n        run: npm run eslint\n",
      ".github/workflows/typos.yml": "name: typos\non:\n  pull_request:\n\njobs:\n  typos:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Actions Repository\n        uses: actions/checkout@v4\n\n      - uses: crate-ci/typos@master\n        with:\n          config: ./typos.toml\n",
      ".gitignore": ".git/\nbin/\ndist/\nlib/\nnode_modules/\npackages/api/lib/\n\n.env\npackage-lock.json\npnpm-lock.yaml",
      ".prettierignore": "dist\nbin\nnode_modules\npackages\nsrc/api/functional\nsrc/api/utils/NestiaSimulator.ts\nREADME.md\ntsconfig.json",
      ".vscode/launch.json": "{\n  // Use IntelliSense to learn about possible Node.js debug attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n  {\n    \"type\": \"node\",\n    \"request\": \"launch\",\n    \"name\": \"Backend Test\",\n    \"program\": \"${workspaceRoot}/test/index.ts\",\n    \"cwd\": \"${workspaceRoot}\",\n    \"args\": [\n      // //----\n      // // Not possible to reset DB in debugging mode\n      // //\n      // // Therefore, if you need DB reset, then do it \n      // // through `npm run reset-for-debugging` command\n      // //----\n      // \"--reset\", \"false\",\n      // \"--mode\", \"local\",\n      \n      //----\n      // You can run specific test functions\n      //\n      // If you want to include or exclude multiple words,\n      // then separate them with space character\n      //----\n      // \"--include\", \"some-words-to-include\",\n      // \"--exclude\", \"some-word another-word\",\n  ],\n    \"outFiles\": [\"${workspaceRoot}/bin/**/*.js\"],\n  }\n]\n}",
      ".vscode/settings.json": "{\n  \"editor.tabSize\": 2,\n  \"editor.formatOnSave\": true,\n  \"[javascript][typescript]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n    \"editor.codeActionsOnSave\": {\n      \"source.fixAll.eslint\": \"explicit\"\n    },\n  }\n}",
      "LICENSE": "MIT License\n\nCopyright (c) 2022 Jeongho Nam\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
      "README.md": "# AutoBE Generated Backend Server\r\n\r\n![AutoBE Logo](https://github.com/user-attachments/assets/a90d14be-fd50-4dc7-ae9d-ca66c2124f31)\r\n\r\nA backend repository generated by [`@autobe`](https://github.com/wrtnlabs/autobe).\r\n\r\nThis backend program was automatically generated using [`@autobe`](https://github.com/wrtnlabs/autobe), the AI vibe coding agent for backend servers of below stack.\r\n\r\n- TypeScript\r\n- NestJS / Nestia\r\n- Prisma\r\n- Postgres\r\n\r\n## Project Structure\r\n\r\nThis template project has categorized directories like below.\r\n\r\nAs you can see from the below, all of the Backend source files are placed into the [src](src/) directory. When you build the TypeScript source files, compiled files would be placed into the `lib` directory following the [tsconfig.json](tsconfig.json) configuration. Otherwise you build client [SDK](#32-sdk) library for npm publishing and their compiled files would be placed into the [packages](packages) directory.\r\n\r\n  - [packages/api/](packages/api): SDK module built by `npm run build:api`\r\n  - [src/](src): Backend source directory\r\n    - [src/api/](src/api/): Client SDK that would be published to the `@ORGANIZATION/PROJECT-api`\r\n      - [**src/api/functional/**](src/api/functional/): API functions generated by the [`nestia`](https://github.com/samchon/nestia)\r\n      - [**src/api/structures/**](src/api/structures/): DTO structures\r\n    - [src/controllers/](src/controllers/): Controller classes of the Main Program\r\n  - [**test/**](test): Test Automation Program\r\n    - [test/features](test/features): List of test functions\r\n  - [nestia.config.ts](nestia.config.ts): Configuration file of [`nestia`](https://github.com/samchon/nestia)\r\n  - [package.json](package.json): NPM configuration\r\n  - [tsconfig.json](tsconfig.json): TypeScript configuration for the main program\r\n\r\n## NPM Run Commands\r\n\r\nList of the run commands defined in the [package.json](package.json) are like below:\r\n\r\n  - Test\r\n    - **`test`**: Run test automation program\r\n    - `benchmark`: Run performance benchmark program\r\n  - Build\r\n    - `build`: Build everything\r\n    - `build:main`: Build main program (`src` directory)\r\n    - `build:test` Build test automation program (`test` directory)\r\n    - `build:sdk`: Build SDK into main program only\r\n    - `build:swagger`: Build Swagger Documents\r\n    - **`dev`**: Incremental build for development (test program)\r\n  - Deploy\r\n    - `package:api`: Build and deploy the SDK library to the NPM\r\n    - `start`: Start the backend server\r\n    - `start:dev`: Start the backend server with incremental build and reload\r\n  - Webpack\r\n    - `webpack`: Run webpack bundler\r\n    - `webpack:start`: Start the backend server built by webpack\r\n    - `webpack:test`: Run test program to the webpack built\r\n\r\n## Specialization\r\n\r\nTransform this template project to be yours.\r\n\r\nWhen you've created a new backend project through this template project, you can specialize it to be suitable for you by changing some words. Replace below words through IDE specific function like `Edit > Replace in Files` (*Ctrl + Shift + H*), who've been supported by the VSCode.\r\n\r\n| Before       | After\r\n|--------------|----------------------------------------\r\n| ORGANIZATION | Your account or corporation name\r\n| PROJECT      | Your own project name\r\n| AUTHOR       | Author name\r\n| https://github.com/samchon/nestia-start | Your repository URL",
      "build/env.ts": "import fs from \"fs\";\n\nif (fs.existsSync(`${__dirname}/../.env`) === false)\n  fs.copyFileSync(`${__dirname}/../.env.local`, `${__dirname}/../.env`);\n",
      "docs/benchmarks/AMD Ryzen 9 7940HS w Radeon 780M Graphics.md": "# Benchmark Report\n> Generated by [`@nestia/benchmark`](https://github.com/samchon/nestia)\n\n  - Specifications\n    - CPU: AMD Ryzen 9 7940HS w/ Radeon 780M Graphics     \n    - RAM: 31 GB\n    - NodeJS Version: v20.10.0\n    - Backend Server: 1 core / 1 thread\n  - Arguments\n    - Count: 40,000\n    - Threads: 4\n    - Simultaneous: 32\n  - Time\n    - Start: 2024-10-29T19:14:35.941Z\n    - Complete: 2024-10-29T19:16:11.418Z\n    - Elapsed: 95,477 ms\n\nType | Count | Success | Mean. | Stdev. | Minimum | Maximum\n----|----|----|----|----|----|----\nTotal | 41,586 | 41,586 | 69.24 | 73.05 | 5 | 546\n\n> Unit: milliseconds\n\n## Memory Consumptions\n```mermaid\nxychart-beta\n  x-axis \"Time (second)\"\n  y-axis \"Memory (MB)\"\n  line \"Resident Set Size\" [122, 156, 159, 142, 154, 165, 184, 185, 187, 189, 200, 205, 209, 217, 221, 225, 229, 224, 230, 235, 242, 250, 256, 262, 267, 272, 234, 237, 249, 259, 266, 273, 285, 292, 291, 216, 225, 235, 243, 200, 208, 214, 186, 186, 171, 177, 187, 199, 185, 192, 205, 171, 180, 158, 170, 179, 163, 163, 176, 188, 193, 202, 213, 219, 230, 239, 256, 265, 283, 301, 240, 249, 257, 267, 284, 282, 290, 202, 213, 166, 178, 188, 200, 203, 208, 180, 191, 199, 175]\n  line \"Heap Total\" [85, 116, 120, 103, 114, 124, 146, 146, 147, 148, 158, 166, 170, 176, 180, 184, 187, 185, 190, 195, 203, 211, 217, 222, 225, 229, 194, 197, 209, 218, 225, 232, 241, 249, 247, 176, 185, 194, 202, 160, 168, 173, 146, 146, 130, 136, 146, 158, 145, 151, 165, 129, 139, 116, 128, 137, 120, 123, 136, 148, 152, 161, 172, 179, 189, 198, 215, 223, 241, 257, 200, 209, 216, 227, 244, 242, 249, 163, 174, 127, 136, 147, 159, 162, 166, 138, 150, 158, 132]\n  line \"Heap Used + External\" [69, 94, 62, 82, 88, 107, 71, 83, 93, 107, 136, 72, 76, 85, 92, 106, 139, 48, 68, 69, 86, 95, 108, 116, 140, 175, 67, 74, 88, 112, 125, 136, 142, 169, 180, 91, 104, 105, 121, 60, 71, 91, 64, 74, 86, 110, 121, 135, 76, 82, 103, 70, 93, 66, 91, 107, 76, 75, 95, 101, 115, 127, 136, 154, 165, 168, 196, 193, 214, 232, 84, 94, 101, 118, 145, 147, 149, 86, 96, 72, 90, 112, 126, 133, 132, 78, 87, 107, 88]\n  line \"Heap Used Only\" [66, 89, 59, 78, 83, 100, 68, 79, 88, 101, 129, 68, 72, 80, 86, 100, 131, 45, 64, 65, 81, 90, 103, 110, 133, 168, 64, 71, 84, 108, 120, 130, 136, 162, 173, 88, 100, 101, 117, 58, 68, 87, 61, 71, 83, 107, 118, 130, 73, 79, 99, 67, 89, 63, 88, 103, 74, 72, 91, 98, 111, 123, 132, 149, 160, 163, 190, 187, 208, 225, 81, 90, 97, 114, 140, 143, 145, 83, 93, 70, 87, 108, 122, 130, 128, 76, 84, 104, 85]\n```\n\n> - 🟦 Resident Set Size\n> - 🟢 Heap Total\n> - 🔴 Heap Used + External\n> - 🟡 Heap Used Only\n\n## Endpoints\nType | Count | Success | Mean. | Stdev. | Minimum | Maximum\n----|----|----|----|----|----|----\nPATCH /bbs/articles/:section | 6,439 | 6,439 | 108.37 | 76.56 | 6 | 546\nPUT /bbs/articles/:section/:id | 380 | 380 | 78.52 | 69.03 | 6 | 296\nGET /bbs/articles/:section/:id | 917 | 917 | 77.65 | 69.84 | 6 | 463\nDELETE /bbs/articles/:section/:id | 201 | 201 | 73.89 | 63.55 | 7 | 307\nPOST /bbs/articles/:section | 33,649 | 33,649 | 61.39 | 70.04 | 5 | 546\n\n> Unit: milliseconds\n\n## Failures\nMethod | Path | Count | Failures\n-------|------|-------|----------",
      "nest-cli.json": "{\n  \"$schema\": \"https://json.schemastore.org/nest-cli\",\n  \"collection\": \"@nestjs/schematics\",\n  \"sourceRoot\": \"src\",\n  \"entryFile\": \"executable/server\",\n  \"compilerOptions\": {\n    \"deleteOutDir\": true\n  }\n}\n",
      "nestia.config.ts": "// nestia configuration file\nimport type sdk from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { MyModule } from \"./src/MyModule\";\n\nconst NESTIA_CONFIG: sdk.INestiaConfig = {\n  input: () => NestFactory.create(MyModule),\n  output: \"src/api\",\n  swagger: {\n    output: \"packages/api/swagger.json\",\n    servers: [\n      {\n        url: \"http://localhost:37001\",\n        description: \"Local Server\",\n      },\n    ],\n    beautify: true,\n  },\n  distribute: \"packages/api\",\n  primitive: false,\n  simulate: true,\n};\nexport default NESTIA_CONFIG;\n",
      "package.json": "{\n  \"private\": true,\n  \"name\": \"@ORGANIZATION/PROJECT\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Starter kit of Nestia\",\n  \"main\": \"lib/index.js\",\n  \"scripts\": {\n    \"benchmark\": \"node bin/test/benchmark\",\n    \"test\": \"node bin/test\",\n    \"test:webpack\": \"npm run webpack && node bin/test/webpack.js\",\n    \"------------------------BUILDS------------------------\": \"\",\n    \"build\": \"npm run build:sdk && npm run build:main && npm run build:test\",\n    \"build:api\": \"rimraf packages/api/lib && nestia all && rimraf packages/api/lib && tsc -p packages/api/tsconfig.json && rollup -c packages/api/rollup.config.js\",\n    \"build:main\": \"rimraf lib && tsc\",\n    \"build:sdk\": \"rimraf src/api/functional && nestia sdk\",\n    \"build:swagger\": \"npx nestia swagger\",\n    \"build:test\": \"rimraf bin && tsc -p test/tsconfig.json\",\n    \"dev\": \"npm run build:test -- --watch\",\n    \"eslint\": \"eslint src && eslint test\",\n    \"eslint:fix\": \"eslint --fix src && eslint --fix test\",\n    \"prepare\": \"ts-patch install && ts-node build/env.ts\",\n    \"prettier\": \"prettier src --write && prettier test --write\",\n    \"------------------------WEBPACK------------------------\": \"\",\n    \"webpack\": \"rimraf dist && webpack\",\n    \"webpack:start\": \"cd dist && node dist/server\",\n    \"webpack:test\": \"npm run webpack && node bin/test/webpack.js\",\n    \"------------------------DEPLOYS------------------------\": \"\",\n    \"package:api\": \"npm run build:api && cd packages/api && npm publish\",\n    \"start\": \"node lib/executable/server\",\n    \"start:dev\": \"nest start --watch\",\n    \"start:swagger\": \"ts-node src/executable/swagger.ts\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/samchon/nestia-start\"\n  },\n  \"keywords\": [\n    \"nestia\",\n    \"template\",\n    \"boilerplate\"\n  ],\n  \"author\": \"AUTHOR\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/samchon/nestia-start/issues\"\n  },\n  \"homepage\": \"https://github.com/samchon/nestia-start#readme\",\n  \"devDependencies\": {\n    \"@nestia/benchmark\": \"^6.0.6\",\n    \"@nestia/e2e\": \"^6.0.6\",\n    \"@nestia/sdk\": \"^7.0.0\",\n    \"@nestjs/cli\": \"^11.0.7\",\n    \"@rollup/plugin-terser\": \"^0.4.4\",\n    \"@rollup/plugin-typescript\": \"^11.1.6\",\n    \"@trivago/prettier-plugin-sort-imports\": \"^4.3.0\",\n    \"@types/cli\": \"^0.11.21\",\n    \"@types/cli-progress\": \"^3.11.5\",\n    \"@types/express\": \"^4.17.21\",\n    \"@types/inquirer\": \"^8.2.5\",\n    \"@types/node\": \"^18.11.0\",\n    \"@types/uuid\": \"^8.3.4\",\n    \"@typescript-eslint/eslint-plugin\": \"^8.1.0\",\n    \"@typescript-eslint/parser\": \"^8.1.0\",\n    \"chalk\": \"^4.1.2\",\n    \"cli\": \"^1.0.1\",\n    \"cli-progress\": \"^3.12.0\",\n    \"copy-webpack-plugin\": \"^11.0.0\",\n    \"eslint-plugin-deprecation\": \"^3.0.0\",\n    \"express\": \"^4.18.2\",\n    \"nestia\": \"^7.0.0\",\n    \"prettier\": \"^3.2.4\",\n    \"prettier-plugin-prisma\": \"^5.0.0\",\n    \"rimraf\": \"^3.0.2\",\n    \"rollup\": \"^4.18.0\",\n    \"source-map-support\": \"^0.5.21\",\n    \"swagger-ui-express\": \"^5.0.0\",\n    \"ts-loader\": \"^9.5.1\",\n    \"ts-node\": \"^10.9.1\",\n    \"ts-patch\": \"^3.3.0\",\n    \"typescript\": \"~5.8.3\",\n    \"typescript-transform-paths\": \"^3.5.5\",\n    \"webpack\": \"^5.89.0\",\n    \"webpack-cli\": \"^5.1.4\",\n    \"write-file-webpack-plugin\": \"^4.5.1\"\n  },\n  \"dependencies\": {\n    \"@nestia/core\": \"^7.0.0\",\n    \"@nestia/fetcher\": \"^7.0.0\",\n    \"@nestjs/common\": \"^11.1.3\",\n    \"@nestjs/core\": \"^11.1.3\",\n    \"@nestjs/platform-express\": \"^11.1.3\",\n    \"commander\": \"10.0.0\",\n    \"dotenv\": \"^16.3.1\",\n    \"dotenv-expand\": \"^10.0.0\",\n    \"inquirer\": \"8.2.5\",\n    \"serialize-error\": \"^4.1.0\",\n    \"tgrid\": \"^1.1.0\",\n    \"tstl\": \"^3.0.0\",\n    \"typia\": \"^9.3.1\",\n    \"uuid\": \"^9.0.0\"\n  },\n  \"stackblitz\": {\n    \"startCommand\": \"npm run prepare && npm run build:test && npm run test -- --simultaneous 1\"\n  }\n}",
      "packages/api/.gitignore": "lib/\nnode_modules/\n\nswagger.json\nopenai.json",
      "packages/api/LICENSE": "MIT License\n\nCopyright (c) 2021 ORGANIZATION\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
      "packages/api/README.md": "# SDK Library\nThis is a SDK library generated by [`nestia`](https://nestia.io).\n\nWith this SDK library, you can easily and safely interact with backend server.\n\nJust import and call some API functions like gif image below:\n\n![nestia-sdk-demo](https://user-images.githubusercontent.com/13158709/215004990-368c589d-7101-404e-b81b-fbc936382f05.gif)\n\n> Left is server code, and right is client code utilizing the SDK\n\n\n\n\n# What [`Nestia`](https://nestia.io) is:\n![Nestia Logo](https://nestia.io/logo.png)\n\n[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/samchon/nestia/blob/master/LICENSE)\n[![npm version](https://img.shields.io/npm/v/@nestia/core.svg)](https://www.npmjs.com/package/@nestia/core)\n[![Downloads](https://img.shields.io/npm/dm/@nestia/core.svg)](https://www.npmjs.com/package/@nestia/core)\n[![Build Status](https://github.com/samchon/nestia/workflows/build/badge.svg)](https://github.com/samchon/nestia/actions?query=workflow%3Abuild)\n[![Guide Documents](https://img.shields.io/badge/guide-documents-forestgreen)](https://nestia.io/docs/)\n\nNestia is a set of helper libraries for NestJS, supporting below features:\n\n  - `@nestia/core`: super-fast decorators\n  - `@nestia/sdk`:\n    - Swagger generator evolved than ever\n    - SDK library generator for clients\n    - Mockup Simulator for client applications\n    - Automatic E2E test functions generator\n  - `@nestia/migrate`: migration from Swagger to NestJS\n  - `nestia`: just CLI (command line interface) tool\n\n> **Note**\n> \n> - **Only one line** required, with pure TypeScript type\n> - Enhance performance **30x** up\n>   - Runtime validator is **20,000x faster** than `class-validator`\n>   - JSON serialization is **200x faster** than `class-transformer`\n> - Software Development Kit\n>   - SDK is a collection of `fetch` functions with type definitions like [tRPC](https://trpc.io/)\n>   - Mockup simulator means embedded backend simulator in SDK\n>     - similar with [msw](https://mswjs.io/), but fully automated",
      "packages/api/package.json": "{\n  \"name\": \"@ORGANIZATION/PROJECT-api\",\n  \"version\": \"0.1.0\",\n  \"description\": \"SDK library generated by Nestia\",\n  \"main\": \"lib/index.js\",\n  \"module\": \"lib/index.mjs\",\n  \"typings\": \"lib/index.d.ts\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/samchon/nestia\"\n  },\n  \"author\": \"Jeongho Nam\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/samchon/nestia/issues\"\n  },\n  \"homepage\": \"https://nestia.io\",\n  \"files\": [\n    \"lib\",\n    \"package.json\",\n    \"swagger.json\",\n    \"openai.json\",\n    \"README.md\"\n  ],\n  \"dependencies\": {\n    \"@nestia/fetcher\": \"^6.0.6\",\n    \"tgrid\": \"^1.1.0\",\n    \"typia\": \"^9.3.1\"\n  }\n}",
      "packages/api/rollup.config.js": "const typescript = require(\"@rollup/plugin-typescript\");\nconst terser = require(\"@rollup/plugin-terser\");\n\nmodule.exports = {\n  input: `${__dirname}/../../src/api/index.ts`,\n  output: {\n    dir: `${__dirname}/lib`,\n    format: \"esm\",\n    entryFileNames: \"[name].mjs\",\n    sourcemap: true,\n  },\n  plugins: [\n    typescript({\n      tsconfig: `${__dirname}/tsconfig.json`,\n      module: \"ESNext\",\n      target: \"ESNext\",\n    }),\n    terser({\n      format: {\n        comments: \"some\",\n        beautify: true,\n        ecma: \"2020\",\n      },\n      compress: false,\n      mangle: false,\n      module: true,\n    }),\n  ],\n};\n",
      "packages/api/tsconfig.json": "{\n  \"compilerOptions\": {\n    /* Visit https://aka.ms/tsconfig to read more about this file */\n    /* Projects */\n    // \"incremental\": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */\n    // \"composite\": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */\n    // \"tsBuildInfoFile\": \"./.tsbuildinfo\",              /* Specify the path to .tsbuildinfo incremental compilation file. */\n    // \"disableSourceOfProjectReferenceRedirect\": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */\n    // \"disableSolutionSearching\": true,                 /* Opt a project out of multi-project reference checking when editing. */\n    // \"disableReferencedProjectLoad\": true,             /* Reduce the number of projects loaded automatically by TypeScript. */\n    /* Language and Environment */\n    \"target\": \"ES5\", /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */\n    \"lib\": [\n      \"DOM\",\n      \"ES2015\"\n    ], /* Specify a set of bundled library declaration files that describe the target runtime environment. */// \"jsx\": \"preserve\",                                /* Specify what JSX code is generated. */\n    // \"experimentalDecorators\": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */\n    // \"emitDecoratorMetadata\": true,                    /* Emit design-type metadata for decorated declarations in source files. */\n    // \"jsxFactory\": \"\",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */\n    // \"jsxFragmentFactory\": \"\",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */\n    // \"jsxImportSource\": \"\",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */\n    // \"reactNamespace\": \"\",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */\n    // \"noLib\": true,                                    /* Disable including any library files, including the default lib.d.ts. */\n    // \"useDefineForClassFields\": true,                  /* Emit ECMAScript-standard-compliant class fields. */\n    // \"moduleDetection\": \"auto\",                        /* Control what method is used to detect module-format JS files. */\n    /* Modules */\n    \"module\": \"commonjs\", /* Specify what module code is generated. */// \"rootDir\": \"./\",                                  /* Specify the root folder within your source files. */\n    // \"moduleResolution\": \"node\",                       /* Specify how TypeScript looks up a file from a given module specifier. */\n    // \"baseUrl\": \"./\",                                  /* Specify the base directory to resolve non-relative module names. */\n    // \"paths\": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */\n    // \"rootDirs\": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */\n    // \"typeRoots\": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */\n    // \"types\": [],                                      /* Specify type package names to be included without being referenced in a source file. */\n    // \"allowUmdGlobalAccess\": true,                     /* Allow accessing UMD globals from modules. */\n    // \"moduleSuffixes\": [],                             /* List of file name suffixes to search when resolving a module. */\n    // \"resolveJsonModule\": true,                        /* Enable importing .json files. */\n    // \"noResolve\": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */\n    /* JavaScript Support */\n    // \"allowJs\": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */\n    // \"checkJs\": true,                                  /* Enable error reporting in type-checked JavaScript files. */\n    // \"maxNodeModuleJsDepth\": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */\n    /* Emit */\n    \"declaration\": true, /* Generate .d.ts files from TypeScript and JavaScript files in your project. */// \"declarationMap\": true,                           /* Create sourcemaps for d.ts files. */\n    // \"emitDeclarationOnly\": true,                      /* Only output d.ts files and not JavaScript files. */\n    \"sourceMap\": true, /* Create source map files for emitted JavaScript files. */// \"outFile\": \"./\",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */\n    \"outDir\": \"./lib\", /* Specify an output folder for all emitted files. */// \"removeComments\": true,                           /* Disable emitting comments. */\n    // \"noEmit\": true,                                   /* Disable emitting files from a compilation. */\n    // \"importHelpers\": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */\n    // \"importsNotUsedAsValues\": \"remove\",               /* Specify emit/checking behavior for imports that are only used for types. */\n    \"downlevelIteration\": true, /* Emit more compliant, but verbose and less performant JavaScript for iteration. */// \"sourceRoot\": \"\",                                 /* Specify the root path for debuggers to find the reference source code. */\n    // \"mapRoot\": \"\",                                    /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,                          /* Include sourcemap files inside the emitted JavaScript. */\n    // \"inlineSources\": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */\n    // \"emitBOM\": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */\n    \"newLine\": \"lf\", /* Set the newline character for emitting files. */// \"stripInternal\": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */\n    // \"noEmitHelpers\": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */\n    // \"noEmitOnError\": true,                            /* Disable emitting files if any type checking errors are reported. */\n    // \"preserveConstEnums\": true,                       /* Disable erasing 'const enum' declarations in generated code. */\n    // \"declarationDir\": \"./\",                           /* Specify the output directory for generated declaration files. */\n    // \"preserveValueImports\": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */\n    /* Interop Constraints */\n    // \"isolatedModules\": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */\n    // \"allowSyntheticDefaultImports\": true,             /* Allow 'import x from y' when a module doesn't have a default export. */\n    \"esModuleInterop\": true, /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */// \"preserveSymlinks\": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */\n    \"forceConsistentCasingInFileNames\": true, /* Ensure that casing is correct in imports. *//* Type Checking */\n    \"strict\": true, /* Enable all strict type-checking options. */// \"noImplicitAny\": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */\n    // \"strictNullChecks\": true,                         /* When type checking, take into account 'null' and 'undefined'. */\n    // \"strictFunctionTypes\": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */\n    // \"strictBindCallApply\": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */\n    // \"strictPropertyInitialization\": true,             /* Check for class properties that are declared but not set in the constructor. */\n    // \"noImplicitThis\": true,                           /* Enable error reporting when 'this' is given the type 'any'. */\n    // \"useUnknownInCatchVariables\": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */\n    // \"alwaysStrict\": true,                             /* Ensure 'use strict' is always emitted. */\n    // \"noUnusedLocals\": true,                           /* Enable error reporting when local variables aren't read. */\n    // \"noUnusedParameters\": true,                       /* Raise an error when a function parameter isn't read. */\n    // \"exactOptionalPropertyTypes\": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */\n    // \"noImplicitReturns\": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */\n    // \"noFallthroughCasesInSwitch\": true,               /* Enable error reporting for fallthrough cases in switch statements. */\n    // \"noUncheckedIndexedAccess\": true,                 /* Add 'undefined' to a type when accessed using an index. */\n    // \"noImplicitOverride\": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */\n    // \"noPropertyAccessFromIndexSignature\": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */\n    // \"allowUnusedLabels\": true,                        /* Disable error reporting for unused labels. */\n    // \"allowUnreachableCode\": true,                     /* Disable error reporting for unreachable code. */\n    /* Completeness */\n    // \"skipDefaultLibCheck\": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */\n    \"skipLibCheck\": true, /* Skip type checking all .d.ts files. */\n    \"plugins\": [\n      {\n        \"transform\": \"typia/lib/transform\"\n      }\n    ],\n    \"strictNullChecks\": true\n  },\n  \"include\": [\n    \"../../src/api\"\n  ]\n}",
      "prettier.config.js": "module.exports = {\n  // DEFAULT CONFIGURATIONS\n  parser: \"typescript\",\n  printWidth: 80,\n  semi: true,\n  tabWidth: 2,\n  trailingComma: \"all\",\n\n  // PLUG-IN CONFIGURATIONS\n  plugins: [\"@trivago/prettier-plugin-sort-imports\"],\n  importOrder: [\n    \"<THIRD_PARTY_MODULES>\",\n    \"^@ORGANIZATION/PROJECT-api(.*)$\",\n    \"^[./]\",\n  ],\n  importOrderSeparation: true,\n  importOrderSortSpecifiers: true,\n  importOrderParserPlugins: [\"decorators-legacy\", \"typescript\"],\n};\n",
      "src/MyBackend.ts": "import { WebSocketAdaptor } from \"@nestia/core\";\nimport { INestApplication } from \"@nestjs/common\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { MyConfiguration } from \"./MyConfiguration\";\nimport { MyModule } from \"./MyModule\";\n\nexport class MyBackend {\n  private application_?: INestApplication;\n\n  public async open(): Promise<void> {\n    //----\n    // OPEN THE BACKEND SERVER\n    //----\n    // MOUNT CONTROLLERS\n    this.application_ = await NestFactory.create(MyModule, { logger: false });\n    await WebSocketAdaptor.upgrade(this.application_);\n\n    // DO OPEN\n    this.application_.enableCors();\n    await this.application_.listen(MyConfiguration.API_PORT(), \"0.0.0.0\");\n\n    //----\n    // POST-PROCESSES\n    //----\n    // INFORM TO THE PM2\n    if (process.send) process.send(\"ready\");\n\n    // WHEN KILL COMMAND COMES\n    process.on(\"SIGINT\", async () => {\n      await this.close();\n      process.exit(0);\n    });\n  }\n\n  public async close(): Promise<void> {\n    if (this.application_ === undefined) return;\n\n    // DO CLOSE\n    await this.application_.close();\n    delete this.application_;\n  }\n}\n",
      "src/MyConfiguration.ts": "import fs from \"fs\";\nimport path from \"path\";\n\nimport { MyGlobal } from \"./MyGlobal\";\n\nexport namespace MyConfiguration {\n  export const API_PORT = () => Number(MyGlobal.env.API_PORT);\n\n  export const ROOT = (() => {\n    const split: string[] = __dirname.split(path.sep);\n    return split.at(-1) === \"src\" && split.at(-2) === \"bin\"\n      ? path.resolve(__dirname + \"/../..\")\n      : fs.existsSync(__dirname + \"/.env\")\n        ? __dirname\n        : path.resolve(__dirname + \"/..\");\n  })();\n}\n",
      "src/MyGlobal.ts": "import dotenv from \"dotenv\";\nimport dotenvExpand from \"dotenv-expand\";\nimport { Singleton } from \"tstl\";\nimport typia from \"typia\";\n\n/* eslint-disable */\nexport class MyGlobal {\n  public static testing: boolean = false;\n  public static get env(): MyGlobal.IEnvironments {\n    return environments.get();\n  }\n}\nexport namespace MyGlobal {\n  export interface IEnvironments {\n    API_PORT: `${number}`;\n  }\n}\n\nconst environments = new Singleton(() => {\n  const env = dotenv.config();\n  dotenvExpand.expand(env);\n  return typia.assert<MyGlobal.IEnvironments>(process.env);\n});\n",
      "src/api/HttpError.ts": "export { HttpError } from \"@nestia/fetcher\";\n",
      "src/api/IConnection.ts": "export type { IConnection } from \"@nestia/fetcher\";\n",
      "src/api/Primitive.ts": "export type { Primitive } from \"typia\";\n",
      "src/api/Resolved.ts": "export type { Resolved } from \"typia\";\n",
      "src/api/index.ts": "import * as api from \"./module\";\n\nexport * from \"./module\";\nexport default api;\n",
      "src/api/module.ts": "export type * from \"./IConnection\";\nexport * from \"./HttpError\";\n\nexport * as functional from \"./functional\";\n",
      "src/executable/server.ts": "import { MyBackend } from \"../MyBackend\";\n\nconst EXTENSION = __filename.substring(__filename.length - 2);\nif (EXTENSION === \"js\") require(\"source-map-support/register\");\n\nasync function main(): Promise<void> {\n  // BACKEND SEVER\n  const backend: MyBackend = new MyBackend();\n  await backend.open();\n\n  // UNEXPECTED ERRORS\n  global.process.on(\"uncaughtException\", console.error);\n  global.process.on(\"unhandledRejection\", console.error);\n}\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
      "src/executable/swagger.ts": "import cp from \"child_process\";\nimport express from \"express\";\n\nconst execute = (command: string): void => {\n  console.log(`\\n$ ${command}\\n`);\n  cp.execSync(command, { stdio: \"inherit\" });\n};\n\nconst main = async (): Promise<void> => {\n  if (!process.argv.some((str) => str === \"--skipBuild\"))\n    execute(\"npm run build:swagger\");\n\n  const docs = await import(\"../../packages/api/swagger.json\" as any);\n\n  const app = express();\n  const swaggerUi = require(\"swagger-ui-express\");\n  app.use(\"/api-docs\", swaggerUi.serve, swaggerUi.setup(docs));\n  app.listen(37810);\n\n  console.log(\"\\n\");\n  console.log(\"-----------------------------------------------------------\");\n  console.log(\"\\n Swagger UI Address: http://127.0.0.1:37810/api-docs \\n\");\n  console.log(\"-----------------------------------------------------------\");\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
      "src/utils/ErrorUtil.ts": "import serializeError = require(\"serialize-error\");\n\nexport namespace ErrorUtil {\n  export const toJSON = (err: any): object =>\n    err instanceof Object && err.toJSON instanceof Function\n      ? err.toJSON()\n      : serializeError(err);\n}\n",
      "src/utils/MapUtil.ts": "export namespace MapUtil {\n  export function take<Key, T>(\n    dict: Map<Key, T>,\n    key: Key,\n    generator: () => T,\n  ): T {\n    const oldbie: T | undefined = dict.get(key);\n    if (oldbie) return oldbie;\n\n    const value: T = generator();\n    dict.set(key, value);\n    return value;\n  }\n}\n",
      "test/TestAutomation.ts": "import { DynamicExecutor } from \"@nestia/e2e\";\nimport chalk from \"chalk\";\nimport { sleep_for } from \"tstl\";\n\nimport { MyConfiguration } from \"../src/MyConfiguration\";\nimport api from \"../src/api\";\nimport { ArgumentParser } from \"./helpers/ArgumentParser\";\n\nexport namespace TestAutomation {\n  export interface IProps<T> {\n    open(options: IOptions): Promise<T>;\n    close(backend: T): Promise<void>;\n  }\n\n  export interface IOptions {\n    simultaneous: number;\n    include?: string[];\n    exclude?: string[];\n  }\n\n  export const execute = async <T,>(props: IProps<T>): Promise<void> => {\n    // OPEN BACKEND\n    const options: IOptions = await getOptions();\n    const backend: T = await props.open(options);\n\n    // DO TEST\n    const connection: api.IConnection = {\n      host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\n    };\n    const report: DynamicExecutor.IReport = await DynamicExecutor.validate({\n      prefix: \"test\",\n      location: __dirname + \"/features\",\n      parameters: () => [\n        {\n          host: connection.host,\n          encryption: connection.encryption,\n        },\n      ],\n      filter: (func) =>\n        (!options.include?.length ||\n          (options.include ?? []).some((str) => func.includes(str))) &&\n        (!options.exclude?.length ||\n          (options.exclude ?? []).every((str) => !func.includes(str))),\n      onComplete: (exec) => {\n        const trace = (str: string) =>\n          console.log(`  - ${chalk.green(exec.name)}: ${str}`);\n        if (exec.error === null) {\n          const elapsed: number =\n            new Date(exec.completed_at).getTime() -\n            new Date(exec.started_at).getTime();\n          trace(`${chalk.yellow(elapsed.toLocaleString())} ms`);\n        } else trace(chalk.red(exec.error.name));\n      },\n      simultaneous: options.simultaneous,\n    });\n\n    // TERMINATE - WAIT FOR BACKGROUND EVENTS\n    await sleep_for(2500);\n    await props.close(backend);\n\n    const failures: DynamicExecutor.IExecution[] = report.executions.filter(\n      (exec) => exec.error !== null,\n    );\n    if (failures.length === 0) {\n      console.log(\"Success\");\n      console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\n    } else {\n      for (const f of failures) console.log(f.error);\n      process.exit(-1);\n    }\n\n    console.log(\n      [\n        `All: #${report.executions.length}`,\n        `Success: #${report.executions.length - failures.length}`,\n        `Failed: #${failures.length}`,\n      ].join(\"\\n\"),\n    );\n  };\n}\n\nconst getOptions = () =>\n  ArgumentParser.parse<TestAutomation.IOptions>(\n    async (command, prompt, action) => {\n      command.option(\n        \"--simultaneous <number>\",\n        \"number of simultaneous requests\",\n      );\n      command.option(\"--include <string...>\", \"include feature files\");\n      command.option(\"--exclude <string...>\", \"exclude feature files\");\n\n      return action(async (options) => {\n        options.simultaneous = Number(\n          options.simultaneous ??\n            (await prompt.number(\"simultaneous\")(\n              \"Number of simultaneous requests to make\",\n            )),\n        );\n        if (isNaN(options.simultaneous) || options.simultaneous <= 0)\n          options.simultaneous = 1;\n        return options as TestAutomation.IOptions;\n      });\n    },\n  );\n",
      "test/benchmark/index.ts": "import { DynamicBenchmarker } from \"@nestia/benchmark\";\nimport cliProgress from \"cli-progress\";\nimport fs from \"fs\";\nimport os from \"os\";\nimport { IPointer } from \"tstl\";\n\nimport { MyBackend } from \"../../src/MyBackend\";\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\nimport { MyGlobal } from \"../../src/MyGlobal\";\nimport { ArgumentParser } from \"../helpers/ArgumentParser\";\n\ninterface IOptions {\n  include?: string[];\n  exclude?: string[];\n  count: number;\n  threads: number;\n  simultaneous: number;\n}\n\nconst getOptions = () =>\n  ArgumentParser.parse<IOptions>(async (command, prompt, action) => {\n    // command.option(\"--mode <string>\", \"target mode\");\n    // command.option(\"--reset <true|false>\", \"reset local DB or not\");\n    command.option(\"--include <string...>\", \"include feature files\");\n    command.option(\"--exclude <string...>\", \"exclude feature files\");\n    command.option(\"--count <number>\", \"number of requests to make\");\n    command.option(\"--threads <number>\", \"number of threads to use\");\n    command.option(\n      \"--simultaneous <number>\",\n      \"number of simultaneous requests to make\",\n    );\n    return action(async (options) => {\n      // if (typeof options.reset === \"string\")\n      //     options.reset = options.reset === \"true\";\n      // options.mode ??= await prompt.select(\"mode\")(\"Select mode\")([\n      //     \"LOCAL\",\n      //     \"DEV\",\n      //     \"REAL\",\n      // ]);\n      // options.reset ??= await prompt.boolean(\"reset\")(\"Reset local DB\");\n      options.count = Number(\n        options.count ??\n          (await prompt.number(\"count\")(\"Number of requests to make\")),\n      );\n      options.threads = Number(\n        options.threads ??\n          (await prompt.number(\"threads\")(\"Number of threads to use\")),\n      );\n      options.simultaneous = Number(\n        options.simultaneous ??\n          (await prompt.number(\"simultaneous\")(\n            \"Number of simultaneous requests to make\",\n          )),\n      );\n      return options as IOptions;\n    });\n  });\n\nconst main = async (): Promise<void> => {\n  // CONFIGURATIONS\n  const options: IOptions = await getOptions();\n  MyGlobal.testing = true;\n\n  // BACKEND SERVER\n  const backend: MyBackend = new MyBackend();\n  await backend.open();\n\n  // DO BENCHMARK\n  const prev: IPointer<number> = { value: 0 };\n  const bar: cliProgress.SingleBar = new cliProgress.SingleBar(\n    {},\n    cliProgress.Presets.shades_classic,\n  );\n  bar.start(options.count, 0);\n\n  const report: DynamicBenchmarker.IReport = await DynamicBenchmarker.master({\n    servant: `${__dirname}/servant.js`,\n    count: options.count,\n    threads: options.threads,\n    simultaneous: options.simultaneous,\n    filter: (func) =>\n      (!options.include?.length ||\n        (options.include ?? []).some((str) => func.includes(str))) &&\n      (!options.exclude?.length ||\n        (options.exclude ?? []).every((str) => !func.includes(str))),\n    progress: (value: number) => {\n      if (value >= 100 + prev.value) {\n        bar.update(value);\n        prev.value = value;\n      }\n    },\n    stdio: \"ignore\",\n  });\n  bar.stop();\n\n  // DOCUMENTATION\n  try {\n    await fs.promises.mkdir(`${MyConfiguration.ROOT}/docs/benchmarks`, {\n      recursive: true,\n    });\n  } catch {}\n  await fs.promises.writeFile(\n    `${MyConfiguration.ROOT}/docs/benchmarks/${os\n      .cpus()[0]\n      .model.trim()\n      .split(\"\\\\\")\n      .join(\"\")\n      .split(\"/\")\n      .join(\"\")}.md`,\n    DynamicBenchmarker.markdown(report),\n    \"utf8\",\n  );\n\n  // CLOSE\n  await backend.close();\n};\nmain().catch((exp) => {\n  console.error(exp);\n  process.exit(-1);\n});\n",
      "test/benchmark/servant.ts": "import { DynamicBenchmarker } from \"@nestia/benchmark\";\n\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\n\nDynamicBenchmarker.servant({\n  connection: {\n    host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\n  },\n  location: `${__dirname}/../features`,\n  parameters: (connection) => [connection],\n  prefix: \"test_api_\",\n}).catch((exp) => {\n  console.error(exp);\n  process.exit(-1);\n});\n",
      "test/helpers/ArgumentParser.ts": "import commander from \"commander\";\nimport * as inquirer from \"inquirer\";\n\nexport namespace ArgumentParser {\n  export type Inquiry<T> = (\n    command: commander.Command,\n    prompt: (opt?: inquirer.StreamOptions) => inquirer.PromptModule,\n    action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>,\n  ) => Promise<T>;\n\n  export interface Prompt {\n    select: (\n      name: string,\n    ) => (\n      message: string,\n    ) => <Choice extends string>(choices: Choice[]) => Promise<Choice>;\n    boolean: (name: string) => (message: string) => Promise<boolean>;\n    number: (name: string) => (message: string) => Promise<number>;\n  }\n\n  export const parse = async <T,>(\n    inquiry: (\n      command: commander.Command,\n      prompt: Prompt,\n      action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>,\n    ) => Promise<T>,\n  ): Promise<T> => {\n    // TAKE OPTIONS\n    const action = (closure: (options: Partial<T>) => Promise<T>) =>\n      new Promise<T>((resolve, reject) => {\n        commander.program.action(async (options) => {\n          try {\n            resolve(await closure(options));\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n        commander.program.parseAsync().catch(reject);\n      });\n\n    const select =\n      (name: string) =>\n      (message: string) =>\n      async <Choice extends string>(choices: Choice[]): Promise<Choice> =>\n        (\n          await inquirer.createPromptModule()({\n            type: \"list\",\n            name,\n            message,\n            choices,\n          })\n        )[name];\n    const boolean = (name: string) => async (message: string) =>\n      (\n        await inquirer.createPromptModule()({\n          type: \"confirm\",\n          name,\n          message,\n        })\n      )[name] as boolean;\n    const number = (name: string) => async (message: string) =>\n      Number(\n        (\n          await inquirer.createPromptModule()({\n            type: \"number\",\n            name,\n            message,\n          })\n        )[name],\n      );\n\n    const output: T | Error = await (async () => {\n      try {\n        return await inquiry(\n          commander.program,\n          { select, boolean, number },\n          action,\n        );\n      } catch (error) {\n        return error as Error;\n      }\n    })();\n\n    // RETURNS\n    if (output instanceof Error) throw output;\n    return output;\n  };\n}\n",
      "test/index.ts": "import { MyBackend } from \"../src/MyBackend\";\nimport { MyGlobal } from \"../src/MyGlobal\";\nimport { TestAutomation } from \"./TestAutomation\";\n\nconst main = async (): Promise<void> => {\n  MyGlobal.testing = true;\n  await TestAutomation.execute({\n    open: async () => {\n      const backend: MyBackend = new MyBackend();\n      await backend.open();\n      return backend;\n    },\n    close: (backend) => backend.close(),\n  });\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
      "test/tsconfig.json": "{\n  \"extends\": \"../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"../bin\",\n  },\n  \"include\": [\".\", \"../src\"]\n}",
      "test/webpack.ts": "import cp from \"child_process\";\nimport { sleep_for } from \"tstl\";\n\nimport { MyConfiguration } from \"../src/MyConfiguration\";\nimport { MyGlobal } from \"../src/MyGlobal\";\nimport { TestAutomation } from \"./TestAutomation\";\n\nconst wait = async (): Promise<void> => {\n  while (true)\n    try {\n      await fetch(`http://localhost:${MyConfiguration.API_PORT()}/dsafdsafsd`);\n      return;\n    } catch (exp) {\n      await sleep_for(100);\n    }\n};\n\nconst main = async (): Promise<void> => {\n  MyGlobal.testing = true;\n  await TestAutomation.execute({\n    open: async () => {\n      const backend: cp.ChildProcess = cp.fork(\n        `${MyConfiguration.ROOT}/dist/server.js`,\n        {\n          cwd: `${MyConfiguration.ROOT}/dist`,\n        },\n      );\n      await wait();\n      return backend;\n    },\n    close: async (backend) => {\n      backend.kill();\n    },\n  });\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
      "tsconfig.json": "{\n  \"compilerOptions\": {\n    /* Visit https://aka.ms/tsconfig to read more about this file */\n\n    /* Projects */\n    // \"incremental\": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */\n    // \"composite\": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */\n    // \"tsBuildInfoFile\": \"./.tsbuildinfo\",              /* Specify the path to .tsbuildinfo incremental compilation file. */\n    // \"disableSourceOfProjectReferenceRedirect\": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */\n    // \"disableSolutionSearching\": true,                 /* Opt a project out of multi-project reference checking when editing. */\n    // \"disableReferencedProjectLoad\": true,             /* Reduce the number of projects loaded automatically by TypeScript. */\n\n    /* Language and Environment */\n    \"target\": \"ES2015\",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */\n    // \"lib\": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */\n    // \"jsx\": \"preserve\",                                /* Specify what JSX code is generated. */\n    \"experimentalDecorators\": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */\n    \"emitDecoratorMetadata\": true,                    /* Emit design-type metadata for decorated declarations in source files. */\n    // \"jsxFactory\": \"\",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */\n    // \"jsxFragmentFactory\": \"\",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */\n    // \"jsxImportSource\": \"\",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */\n    // \"reactNamespace\": \"\",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */\n    // \"noLib\": true,                                    /* Disable including any library files, including the default lib.d.ts. */\n    // \"useDefineForClassFields\": true,                  /* Emit ECMAScript-standard-compliant class fields. */\n    // \"moduleDetection\": \"auto\",                        /* Control what method is used to detect module-format JS files. */\n\n    /* Modules */\n    \"module\": \"commonjs\",                                /* Specify what module code is generated. */\n    // \"rootDir\": \"./\",                                  /* Specify the root folder within your source files. */\n    // \"moduleResolution\": \"node\",                       /* Specify how TypeScript looks up a file from a given module specifier. */\n    // \"baseUrl\": \"./\",                                  /* Specify the base directory to resolve non-relative module names. */\n    \"paths\": {\n      \"@ORGANIZATION/PROJECT-api/lib/*\": [\"./src/api/*\"],\n      \"@ORGANIZATION/PROJECT-api\": [\"./src/api\"],\n    },                                      /* Specify a set of entries that re-map imports to additional lookup locations. */\n    // \"rootDirs\": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */\n    // \"typeRoots\": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */\n    // \"types\": [],                                      /* Specify type package names to be included without being referenced in a source file. */\n    // \"allowUmdGlobalAccess\": true,                     /* Allow accessing UMD globals from modules. */\n    // \"moduleSuffixes\": [],                             /* List of file name suffixes to search when resolving a module. */\n    // \"resolveJsonModule\": true,                        /* Enable importing .json files. */\n    // \"noResolve\": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */\n\n    /* JavaScript Support */\n    // \"allowJs\": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */\n    // \"checkJs\": true,                                  /* Enable error reporting in type-checked JavaScript files. */\n    // \"maxNodeModuleJsDepth\": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */\n\n    /* Emit */\n    // \"declaration\": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */\n    // \"declarationMap\": true,                           /* Create sourcemaps for d.ts files. */\n    // \"emitDeclarationOnly\": true,                      /* Only output d.ts files and not JavaScript files. */\n    \"sourceMap\": true,                                /* Create source map files for emitted JavaScript files. */\n    // \"outFile\": \"./\",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */\n    \"outDir\": \"./lib\",                                   /* Specify an output folder for all emitted files. */\n    // \"removeComments\": true,                           /* Disable emitting comments. */\n    // \"noEmit\": true,                                   /* Disable emitting files from a compilation. */\n    // \"importHelpers\": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */\n    // \"importsNotUsedAsValues\": \"remove\",               /* Specify emit/checking behavior for imports that are only used for types. */\n    // \"downlevelIteration\": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */\n    // \"sourceRoot\": \"\",                                 /* Specify the root path for debuggers to find the reference source code. */\n    // \"mapRoot\": \"\",                                    /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,                          /* Include sourcemap files inside the emitted JavaScript. */\n    // \"inlineSources\": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */\n    // \"emitBOM\": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */\n    \"newLine\": \"lf\",                                /* Set the newline character for emitting files. */\n    \"stripInternal\": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */\n    // \"noEmitHelpers\": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */\n    // \"noEmitOnError\": true,                            /* Disable emitting files if any type checking errors are reported. */\n    // \"preserveConstEnums\": true,                       /* Disable erasing 'const enum' declarations in generated code. */\n    // \"declarationDir\": \"./\",                           /* Specify the output directory for generated declaration files. */\n    // \"preserveValueImports\": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */\n\n    /* Interop Constraints */\n    // \"isolatedModules\": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */\n    // \"allowSyntheticDefaultImports\": true,             /* Allow 'import x from y' when a module doesn't have a default export. */\n    \"esModuleInterop\": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */\n    // \"preserveSymlinks\": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */\n    \"forceConsistentCasingInFileNames\": true,            /* Ensure that casing is correct in imports. */\n\n    /* Type Checking */\n    \"strict\": true,                                      /* Enable all strict type-checking options. */\n    // \"noImplicitAny\": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */\n    // \"strictNullChecks\": true,                         /* When type checking, take into account 'null' and 'undefined'. */\n    // \"strictFunctionTypes\": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */\n    // \"strictBindCallApply\": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */\n    // \"strictPropertyInitialization\": true,             /* Check for class properties that are declared but not set in the constructor. */\n    // \"noImplicitThis\": true,                           /* Enable error reporting when 'this' is given the type 'any'. */\n    // \"useUnknownInCatchVariables\": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */\n    // \"alwaysStrict\": true,                             /* Ensure 'use strict' is always emitted. */\n    \"noUnusedLocals\": true,                           /* Enable error reporting when local variables aren't read. */\n    \"noUnusedParameters\": true,                       /* Raise an error when a function parameter isn't read. */\n    // \"exactOptionalPropertyTypes\": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */\n    \"noImplicitReturns\": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */\n    \"noFallthroughCasesInSwitch\": true,               /* Enable error reporting for fallthrough cases in switch statements. */\n    // \"noUncheckedIndexedAccess\": true,                 /* Add 'undefined' to a type when accessed using an index. */\n    // \"noImplicitOverride\": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */\n    // \"noPropertyAccessFromIndexSignature\": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */\n    // \"allowUnusedLabels\": true,                        /* Disable error reporting for unused labels. */\n    // \"allowUnreachableCode\": true,                     /* Disable error reporting for unreachable code. */\n\n    /* Completeness */\n    // \"skipDefaultLibCheck\": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */\n    \"skipLibCheck\": true,                                 /* Skip type checking all .d.ts files. */\n    \"plugins\": [\n      { \"transform\": \"typescript-transform-paths\" },\n      { \"transform\": \"typia/lib/transform\" },\n      { \n        \"transform\": \"@nestia/core/lib/transform\",\n        /**\n         * Validate request body.\n         * \n         *   - \"assert\": Use typia.assert() function\n         *   - \"is\": Use typia.is() function\n         *   - \"validate\": Use typia.validate() function\n         *   - \"assertEquals\": Use typia.assertEquals() function\n         *   - \"equals\": Use typia.equals() function\n         *   - \"validateEquals\": Use typia.validateEquals() function\n         */\n        \"validate\": \"validate\",\n        /**\n         * Validate JSON typed response body.\n         * \n         *   - \"assert\": Use typia.assertStringify() function\n         *   - \"is\": Use typia.isStringify() function\n         *   - \"validate\": Use typia.validateStringify() function\n         *   - \"validate.log\": typia.validateStringify(), but do not throw and just log it\n         *   - \"stringify\": Use typia.stringify() function, but dangerous\n         *   - null: Just use JSON.stringify() function, without boosting\n         */\n        \"stringify\": \"assert\",\n      },\n    ]\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"packages\",\n  ]\n}\n",
      "typos.toml": "[default]\nlocale = 'en-us'\nextend-ignore-re = [\n  \"(?Rm)^.*(<!--|#|//)\\\\s*spellchecker:disable-line(-->|\\n)?$\",\n  \"(?s)(<!--|#|//)\\\\s*spellchecker:off\\\\s*(-->|\\n).*?(<!--|#|//)\\\\s*spellchecker:on\",\n]\n\n[default.extend-words]\nJeongho = \"Jeongho\"\nNam = \"Nam\"\ntypia = \"typia\"\n\n[files]\nextend-exclude = [\"*.json\"]",
      "webpack.config.js": "const path = require(\"path\");\n\nconst CopyWebpackPlugin = require(\"copy-webpack-plugin\");\nconst WriteFilePlugin = require(\"write-file-webpack-plugin\");\nconst { IgnorePlugin } = require(\"webpack\");\n\nconst lazyImports = [\n  \"@fastify/static\",\n  \"@fastify/view\",\n  \"@nestjs/microservices\",\n  \"@nestjs/websockets\",\n  \"class-transformer\",\n  \"class-validator\",\n];\n\n// @reference https://tech-blog.s-yoshiki.com/entry/297\nmodule.exports = {\n  // CUSTOMIZE HERE\n  entry: {\n    server: \"./src/executable/server.ts\",\n  },\n  output: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"[name].js\",\n  },\n  optimization: {\n    minimize: true,\n  },\n\n  // JUST KEEP THEM\n  mode: \"production\",\n  target: \"node\",\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        exclude: /node_modules/,\n        loader: \"ts-loader\",\n      },\n    ],\n  },\n  resolve: {\n    extensions: [\".tsx\", \".ts\", \".js\"],\n  },\n  plugins: [\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: \".env\",\n          to: \"[name][ext]\",\n        },\n        // {\n        //   from: \"./node_modules/.prisma/client/*.node\",\n        //   to: () => Promise.resolve(\"[path][name][ext]\"),\n        //   globOptions: {\n        //     dot: true,\n        //   },\n        // },\n      ],\n    }),\n    new WriteFilePlugin(),\n    new IgnorePlugin({\n      checkResource: (resource) => {\n        if (lazyImports.some((modulo) => resource.startsWith(modulo))) {\n          try {\n            require.resolve(resource);\n          } catch (err) {\n            return true;\n          }\n        }\n        return false;\n      },\n    }),\n  ],\n};\n",
      "src/MyModule.ts": "import { Module } from \"@nestjs/common\";\n\nimport { CoreUsersController } from \"./controllers/core/users/CoreUsersController\";\nimport { CoreUserrolesController } from \"./controllers/core/userRoles/CoreUserrolesController\";\nimport { CoreCategoriesController } from \"./controllers/core/categories/CoreCategoriesController\";\nimport { PostsPostsController } from \"./controllers/posts/posts/PostsPostsController\";\nimport { PostsCommentsController } from \"./controllers/posts/comments/PostsCommentsController\";\nimport { VotesVotesController } from \"./controllers/votes/votes/VotesVotesController\";\n\n@Module({\n  controllers: [\n    CoreUsersController,\n    CoreUserrolesController,\n    CoreCategoriesController,\n    PostsPostsController,\n    PostsCommentsController,\n    VotesVotesController,\n  ],\n})\nexport class MyModule {}\n",
      "src/controllers/core/users/CoreUsersController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IUser } from \"../../../api/structures/IUser\";\nimport { IPageIUser } from \"../../../api/structures/IPageIUser\";\n\n@Controller(\"/core/users\")\nexport class CoreUsersController {\n  /**\n   * Register a new user (core.users table).\n   *\n   * This operation handles new user registration or administrator-created\n   * user accounts. It accepts all required and optional fields per the users\n   * model: username, email, bio (optional), status, and an associated\n   * user_role_id. Passwords are securely hashed before saving, never stored\n   * in plain text.\n   *\n   * Unique constraints are enforced for both username and email to prevent\n   * duplicates. The user role must point to an existing role defined in\n   * user_roles. Timestamps for creation and update are handled automatically.\n   * Successful creation returns the newly registered user's public profile\n   * and role association (never the password hash).\n   *\n   * Security and validation reflect business rules, e.g., email visibility,\n   * profile privacy, and initial status setting. Input errors or duplicates\n   * return clear messages and codes. Related endpoints: list (PATCH), read\n   * (GET), update (PUT), delete (DELETE).\n   *\n   * @param body Registration info for the new user, including username,\n   *   email, password, user role, etc.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IUser.ICreate,\n  ): Promise<IUser> {\n    body;\n    return typia.random<IUser>();\n  }\n\n  /**\n   * Retrieve a paginated, filterable list of users (core.users table).\n   *\n   * This operation returns a paginated and filtered list of users registered\n   * on the discussion board. Users may be searched by username, email, user\n   * role, or status, and results are sorted and paginated according to the\n   * provided parameters. The endpoint refers to the users table, whose\n   * structure includes fields for username, email, bio, role reference,\n   * password hash, timestamps, and status. Filters can help administrators or\n   * moderators locate specific accounts, monitor new signups, or audit\n   * activity. Security is enforced: only users with moderator or\n   * administrator roles can access or use advanced filters.\n   *\n   * The endpoint applies business rules from the requirements, such as hiding\n   * sensitive (e.g., password) information, and supports relations to\n   * user_roles for displaying or filtering by user type. Pagination and\n   * sorting follow best practices for usability and performance. Related\n   * endpoints: create (POST), retrieve detail (GET), update (PUT), and delete\n   * (DELETE) for users.\n   *\n   * Error handling ensures invalid queries, unauthorized access, or database\n   * issues are managed gracefully, returning clear status codes and messages.\n   * Sensitive data, such as password hashes, is never included in responses.\n   *\n   * @param body Filtering, sorting, and pagination info for user listing\n   *   request.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IUser.IRequest,\n  ): Promise<IPageIUser.ISummary> {\n    body;\n    return typia.random<IPageIUser.ISummary>();\n  }\n\n  /**\n   * Retrieve detailed profile info for a specific user (core.users table).\n   *\n   * This operation retrieves the full profile and related information for a\n   * specific user, identified by their unique user ID. Fields returned follow\n   * the schema comments: username, email, bio, status, timestamps, and a\n   * reference to their user role. User roles are resolved to human-readable\n   * labels where appropriate.\n   *\n   * Sensitive fields such as password_hash are never returned. This endpoint\n   * is typically used by administrators for user management, or by users to\n   * view their own account details. Where authorized, moderators may use this\n   * endpoint for resolving moderation cases or audits. The data aligns\n   * exactly with the users table comments and model.\n   *\n   * Related endpoints include listing (PATCH), creation (POST), update (PUT),\n   * and deletion (DELETE) for users. Error handling covers not found,\n   * unauthorized, or forbidden cases, always giving appropriate error codes\n   * and minimal leak of protected info.\n   *\n   * @param id Target user's ID (UUID).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IUser> {\n    id;\n    return typia.random<IUser>();\n  }\n\n  /**\n   * Update user profile and account fields (core.users table).\n   *\n   * Updates an existing user's information, addressing fields in the users\n   * schema, such as username, email, bio, role, status, and update timestamp.\n   * The input must include the user ID and only permitted fields are\n   * updateable. Username/email uniqueness is enforced on update as well.\n   * Moderators/administrators can change roles/statuses as permitted by\n   * business rules.\n   *\n   * The request never allows direct password updates (managed by a separate\n   * dedicated endpoint, or by password reset process for security). All\n   * change history is reflected in the updated_at timestamp. Security\n   * measures prevent users from editing others' profiles unless authorized;\n   * self-edits are limited to certain fields.\n   *\n   * Related endpoints: detail (GET), list (PATCH), create (POST), delete\n   * (DELETE). Strict validation and business rule application ensure\n   * stability and data quality.\n   *\n   * @param id Target user's ID (UUID).\n   * @param body Editable fields for user update, such as profile details or\n   *   status/role changes (excludes password updates).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IUser.IUpdate,\n  ): Promise<IUser> {\n    id;\n    body;\n    return typia.random<IUser>();\n  }\n\n  /**\n   * Softly or fully delete a user (core.users table).\n   *\n   * Deletes a user account with the specified ID. This typically marks the\n   * user's status as deleted or suspended and/or sets a deletion flag in\n   * audit fields, per the users Prisma schema and moderation rules.\n   * Associated content (posts, comments, votes) may be retained for community\n   * reference, moderation, or audit logs, as described in requirements.\n   *\n   * Only administrators may perform this action, and a detailed audit trail\n   * is kept. Related endpoints are used for restoration or final hard-delete\n   * (if policy allows). Errors for not found or forbidden actions are handled\n   * appropriately; sensitive information on deleted users is not exposed.\n   *\n   * @param id Target user's ID (UUID).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IUser.IDeleteResponse> {\n    id;\n    return typia.random<IUser.IDeleteResponse>();\n  }\n}\n",
      "src/controllers/core/userRoles/CoreUserrolesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IUserRole } from \"../../../api/structures/IUserRole\";\nimport { IPageIUserRole } from \"../../../api/structures/IPageIUserRole\";\n\n@Controller(\"/core/userRoles\")\nexport class CoreUserrolesController {\n  /**\n   * Create a new user role (core.userRoles table).\n   *\n   * Creates a new user role based on the schema structure, with fields for\n   * name (label) and description. Enforces the uniqueness of the role name\n   * and ensures all required information is provided, following the comments\n   * and requirements detailed in the Prisma schema.\n   *\n   * Intended for administrator setup or customization of new permission\n   * levels. Errors are sent in case of duplicate names, missing fields, or\n   * insufficient permissions. Successful creation returns the new user role\n   * record, suitable for immediate assignment to users.\n   *\n   * Related endpoints: list (PATCH), single GET, update (PUT), and delete\n   * (DELETE) for user roles.\n   *\n   * @param body New user role details, including name and description.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IUserRole.ICreate,\n  ): Promise<IUserRole> {\n    body;\n    return typia.random<IUserRole>();\n  }\n\n  /**\n   * List and filter user roles (core.userRoles table).\n   *\n   * This operation returns a paginated list of user roles available to\n   * assign, as defined by the user_roles model. Roles govern permissions\n   * across the board (e.g., member, moderator, administrator). Designed for\n   * use in registration processes, admin dashboards, or role management\n   * panels, enabling filtering by role name or description and ordering of\n   * results.\n   *\n   * Data returned is defined strictly by the Prisma model and schema\n   * comments. This operation is auditable and respects business constraints\n   * on who may view/assign roles. Related endpoints: single role GET, create\n   * (POST), update (PUT), and delete (DELETE).\n   *\n   * Error cases (e.g., forbidden access) are handled with appropriate status\n   * codes. Pagination and search parameters maximize usability and\n   * efficiency, especially for large deployments with custom roles.\n   *\n   * @param body Filter, search, and pagination info for user roles listing.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IUserRole.IRequest,\n  ): Promise<IPageIUserRole> {\n    body;\n    return typia.random<IPageIUserRole>();\n  }\n\n  /**\n   * Get a single user role's details (core.userRoles table).\n   *\n   * Retrieves all details for a single user role, specified by ID. Used in\n   * admin panels to display all properties of a role, or in account\n   * registration to inform users about the meaning and permissions of each\n   * role (as described in schema comments: name, description, etc).\n   *\n   * Respects all business rules regarding role assignment and application.\n   * Related endpoints: list (PATCH), creation (POST), update (PUT), delete\n   * (DELETE). Errors for missing roles or unauthorized actions are handled\n   * gracefully, with clear messaging.\n   *\n   * @param id Target role's ID (UUID).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IUserRole> {\n    id;\n    return typia.random<IUserRole>();\n  }\n\n  /**\n   * Edit label/description for a user role (core.userRoles table).\n   *\n   * Updates an existing user role's properties (name and/or description).\n   * Uniqueness of the name is enforced by Prisma schema rules. Typical in\n   * systems where additional roles/policies are introduced or for correcting\n   * role definitions.\n   *\n   * Only administrators are permitted to update roles. Change history is\n   * tracked and any update is reflected in audit fields. Related endpoints:\n   * detail GET, list PATCH, creation POST, and deletion DELETE for user\n   * roles.\n   *\n   * Any errors due to duplicates, forbidden edits, or missing records\n   * generate suitable error codes in response. Endpoint matches structure and\n   * intentions described in requirements and schema comments.\n   *\n   * @param id Target role's ID (UUID).\n   * @param body New values for user role fields (name/description).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IUserRole.IUpdate,\n  ): Promise<IUserRole> {\n    id;\n    body;\n    return typia.random<IUserRole>();\n  }\n\n  /**\n   * Delete a user role from the system (core.userRoles table).\n   *\n   * Deletes a user role identified by its ID. Enforces business and schema\n   * rules about which roles can be deleted (e.g., prevents deletion of\n   * critical roles if protected by business logic). If the role is in use\n   * (referenced by users), operation will fail with a clear error message.\n   *\n   * Administrative rights are required. Detailed audit trails are maintained\n   * for changes. Related endpoints: create (POST), list (PATCH), update\n   * (PUT), detail (GET). All operations match Prisma schema and requirements.\n   * Appropriate handling is provided for not found, forbidden, or dependency\n   * errors.\n   *\n   * @param id Target role's ID (UUID).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IUserRole.IDeleteResponse> {\n    id;\n    return typia.random<IUserRole.IDeleteResponse>();\n  }\n}\n",
      "src/controllers/core/categories/CoreCategoriesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { ICategory } from \"../../../api/structures/ICategory\";\nimport { IPageICategory } from \"../../../api/structures/IPageICategory\";\n\n@Controller(\"/core/categories\")\nexport class CoreCategoriesController {\n  /**\n   * Create new category (Core.categories).\n   *\n   * Allows creation of a new category topic for the discussion board, by\n   * inserting a new record into the 'categories' table in the database. The\n   * provided name must be unique among all categories. Description field\n   * gives users context. Only authorized users (administrators) are permitted\n   * to execute this operation.\n   *\n   * Input validation includes ensuring that required fields are present, name\n   * does not duplicate existing entries, and description respects\n   * length/content rules. On success, the new category is created and\n   * returned with full detail including its assigned UUID and creation\n   * timestamp.\n   *\n   * Error handling covers invalid parameters, uniqueness violations, or\n   * insufficient permissions.\n   *\n   * Related endpoints: list/search (PATCH), get (GET), update (PUT), and\n   * delete (DELETE) for categories.\n   *\n   * @param body Data for new category including unique name and description.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: ICategory.ICreate,\n  ): Promise<ICategory> {\n    body;\n    return typia.random<ICategory>();\n  }\n\n  /**\n   * List and search categories (Core.categories).\n   *\n   * This API operation returns a list of categories, leveraging the\n   * 'categories' table from the database.\n   *\n   * The response is paginated and may be filtered based on optional query\n   * parameters such as name, partial matches in description, or created_at\n   * window. Secure endpoints may restrict certain filters or result fields to\n   * administrators. The main purpose is to allow users to browse or search\n   * available discussion categories for post assignment or exploration.\n   *\n   * Security: Some filtering/search options may be restricted to users with\n   * elevated roles, such as administrators or moderators. Regular users\n   * typically see all active categories only.\n   *\n   * This endpoint is commonly used in category selection modals,\n   * administrative dashboards, and on board homepages. Validation ensures\n   * page and pageSize are non-negative, and sortBy field must match a valid\n   * column. Error handling will return informative failures for invalid\n   * filter parameters or database errors.\n   *\n   * This operation is related to single-category get, create, update, and\n   * delete operations, and in large systems may be supplemented by category\n   * suggestion/approval flows.\n   *\n   * @param body Search criteria, pagination, and sorting parameters for\n   *   categories list query.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: ICategory.IRequest,\n  ): Promise<IPageICategory> {\n    body;\n    return typia.random<IPageICategory>();\n  }\n\n  /**\n   * Retrieve specific category by ID (Core.categories).\n   *\n   * Retrieves category information for the specified ID from the 'categories'\n   * table, including name, description, creation timestamp, and potentially\n   * related post count or status if extended.\n   *\n   * If the category does not exist, the API returns a clear error message.\n   * Access policies determine visibility of archived or deactivated\n   * categories—regular users can only view active categories, while admins\n   * may retrieve all states.\n   *\n   * This endpoint is essential for screens displaying category details prior\n   * to editing/deleting, or for referencing during post creation/editing\n   * workflows. Includes validation of the UUID path parameter. Returns 404 if\n   * not found or permission denied.\n   *\n   * Related endpoints: categories list/search (PATCH), create (POST), update\n   * (PUT), and delete (DELETE).\n   *\n   * @param id Unique ID of the target category\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<ICategory> {\n    id;\n    return typia.random<ICategory>();\n  }\n\n  /**\n   * Update a category by ID (Core.categories).\n   *\n   * Updates an existing category's name or description by changing the\n   * relevant fields in the 'categories' table. The category is referenced by\n   * its unique UUID path parameter, and the body provides updated data.\n   *\n   * This operation may only be performed by users with appropriate\n   * administrative roles. Validation checks include verifying that the new\n   * category name does not duplicate any other categories and that all\n   * required fields meet formatting rules.\n   *\n   * Partial or full updates are supported; fields not included may retain\n   * their current values. Business rules may restrict changes if the category\n   * is currently associated with posts. On success, the full updated category\n   * information is returned.\n   *\n   * Error handling includes failing if the category does not exist, trying to\n   * use a duplicate name, or lacking sufficient rights. Related operations:\n   * get, create, delete, and list/search categories.\n   *\n   * @param id Unique ID of the target category\n   * @param body Updated name and/or description for the category.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ICategory.IUpdate,\n  ): Promise<ICategory> {\n    id;\n    body;\n    return typia.random<ICategory>();\n  }\n\n  /**\n   * Delete a category by ID (Core.categories).\n   *\n   * Deletes (or marks as deleted) a category based on its unique ID. This\n   * operation usually employs soft-deletion: the category is flagged so it no\n   * longer appears in lists or selection menus, but remains in the database\n   * for historical tracking and audit purposes. Some implementations may\n   * require hard deletion if the category has no posts attached.\n   *\n   * Permission to use this operation is typically restricted to\n   * administrators. Attempts to delete active categories in use by posts may\n   * be rejected or require confirmation. All deletion attempts are logged for\n   * audit.\n   *\n   * Error cases include non-existent category ID, attempts to delete\n   * categories linked to live posts, or insufficient permissions. Related\n   * endpoints: create, get, update, and list/search categories.\n   *\n   * @param id Unique ID of the target category\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<ICategory.IDeleteResult> {\n    id;\n    return typia.random<ICategory.IDeleteResult>();\n  }\n}\n",
      "src/controllers/posts/posts/PostsPostsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPost } from \"../../../api/structures/IPost\";\nimport { IPageIPost } from \"../../../api/structures/IPageIPost\";\n\n@Controller(\"/posts/posts\")\nexport class PostsPostsController {\n  /**\n   * Create a new post (Posts.posts).\n   *\n   * Allows a user to create a new post by providing required information such\n   * as category, title, and content. The new post is assigned to the\n   * authoring user and is inserted into the database. Creation may be subject\n   * to moderation or review depending on platform policies.\n   *\n   * Input validation includes ensuring a valid category reference,\n   * unique/valid title, and legitimate content (length, formatting). On\n   * success, the API returns the full details of the created post, including\n   * assigned UUID, timestamps, and author/category references.\n   *\n   * Error cases include missing/invalid data, attempts to create a post in\n   * non-existent category, or by unauthorized/blocked users. Related\n   * endpoints: list/search (PATCH), get (GET), update (PUT), delete (DELETE);\n   * plus comment APIs.\n   *\n   * @param body All information required for new post: categoryId, title,\n   *   content.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IPost.ICreate,\n  ): Promise<IPost> {\n    body;\n    return typia.random<IPost>();\n  }\n\n  /**\n   * List and search posts (Posts.posts).\n   *\n   * This API operation returns a list of posts (discussion threads or\n   * articles) with full support for filtering by category, author, or\n   * keywords, as well as sorting and pagination. Non-admin users typically\n   * see only non-deleted, non-archived posts, while administrators may have\n   * visibility into all post states. Standard search validation is performed\n   * for page, pageSize, and sort field inputs.\n   *\n   * The endpoint supports community browsing, category threads,\n   * author-centric feeds, and search result pages. It also includes support\n   * for keyword-based full-text search on titles and content. Additional\n   * metadata such as comment and vote counts may be included per business\n   * requirements. Error handling addresses invalid filters, missing results,\n   * or backend errors.\n   *\n   * Related to post retrieval (GET), post creation (POST), update (PUT), and\n   * delete (DELETE) endpoints, as well as comment and vote-related APIs.\n   *\n   * @param body Criteria for searching, paging, and sorting posts.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IPost.IRequest,\n  ): Promise<IPageIPost> {\n    body;\n    return typia.random<IPageIPost>();\n  }\n\n  /**\n   * Retrieve specific post by ID (Posts.posts).\n   *\n   * Retrieves full details of a single post, identified by its unique ID.\n   * Returns all fields visible to the viewing user, such as title, content,\n   * author reference, category reference, creation and update times, etc.\n   * Admin users may access deleted posts if required, while normal users only\n   * see active posts.\n   *\n   * This API is the primary source of detail for displaying or editing a\n   * discussion post. It validates the UUID input, and returns a 404 or\n   * permission error if the post does not exist or the user lacks rights.\n   *\n   * Related endpoints: post list/search (PATCH), create (POST), update (PUT),\n   * delete (DELETE). Also supports comment and voting APIs.\n   *\n   * @param id Unique ID of the target post\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IPost> {\n    id;\n    return typia.random<IPost>();\n  }\n\n  /**\n   * Update a post by ID (Posts.posts).\n   *\n   * Updates an existing post, referenced by its unique ID. Input may update\n   * title, content, and/or category reference. Only the author or an\n   * administrator/moderator may perform this operation. All updates are\n   * validated for required structure, content, and permission.\n   *\n   * Partial updates retain other fields unchanged. History tracking is\n   * enabled via timestamps. Changing category may have restrictions if the\n   * post has live comments. On success, returns updated post data; on\n   * failure, returns validation or permission errors.\n   *\n   * Related endpoints: get, list/search, create, delete for posts. This\n   * endpoint supports editing discussion threads after posting.\n   *\n   * @param id Unique ID of the target post\n   * @param body Fields to update for post (title, content, category).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IPost.IUpdate,\n  ): Promise<IPost> {\n    id;\n    body;\n    return typia.random<IPost>();\n  }\n\n  /**\n   * Delete a post by ID (Posts.posts).\n   *\n   * Deletes (or marks as deleted) a post record by its ID. Standard\n   * implementation is soft-deletion: post remains in database for moderation\n   * and audit but is removed from normal views and feeds. Only the original\n   * author, admin, or moderator can perform deletion. Attempts to delete\n   * posts with active comments or votes may be subject to business rule\n   * restrictions or warnings.\n   *\n   * All delete actions are logged. The response provides confirmation or\n   * error. Related endpoints: create, get, update, and list/search for posts.\n   * Deletion cascades may apply to comments and votes as policy dictates.\n   *\n   * @param id Unique ID of the target post\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IPost.IDeleteResult> {\n    id;\n    return typia.random<IPost.IDeleteResult>();\n  }\n}\n",
      "src/controllers/posts/comments/PostsCommentsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IComment } from \"../../../api/structures/IComment\";\nimport { IPageIComment } from \"../../../api/structures/IPageIComment\";\n\n@Controller(\"/posts/comments\")\nexport class PostsCommentsController {\n  /**\n   * Create a new comment (Posts domain, 'comments' table).\n   *\n   * This API lets a registered user create a new comment (either as a direct\n   * reply to a post or as a nested reply to another comment). Necessary\n   * fields include the content, target postId, and optionally a parentId (for\n   * replies-to-replies).\n   *\n   * Input is validated for minimum/maximum length, appropriate content, and\n   * ensuring the parent exists and belongs to the same post. The endpoint\n   * checks author authentication and standard anti-abuse policies (e.g., rate\n   * limiting). On success, it returns the created comment record with all\n   * metadata (author, timestamp, etc.).\n   *\n   * Business logic from the 'comments' table (Posts domain) is implemented:\n   * only registered users may comment; soft deletion rules apply. Related\n   * endpoints: retrieval (GET /posts/comments/{id}), update (PUT\n   * /posts/comments/{id}), and listing (PATCH /posts/comments).\n   *\n   * @param body New comment data, including content, postId, and optional\n   *   parentId.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IComment.ICreate,\n  ): Promise<IComment> {\n    body;\n    return typia.random<IComment>();\n  }\n\n  /**\n   * Retrieve a filtered, paginated list of comments (Posts domain, 'comments'\n   * table).\n   *\n   * This API retrieves a paged list of comments from the discussion board.\n   * Typically, users or moderators use it to see all comments on a specific\n   * thread, all comments by a particular user, or to moderate recent\n   * activity.\n   *\n   * The route supports filtering (e.g., by postId, userId, parentId),\n   * pagination (offset/limit), full-text search on comment content, and\n   * sorting (e.g., newest first). Security considerations include only\n   * exposing non-deleted comments by default, unless requested by a\n   * privileged moderator/admin. Comment content is filtered to remove\n   * inappropriate language if the requester has insufficient privileges.\n   *\n   * It references the 'comments' table (Posts domain). Query performance is\n   * optimized via relevant indexes. Related APIs include: create (POST\n   * /posts/comments), update (PUT /posts/comments/{id}), retrieve detail (GET\n   * /posts/comments/{id}), and delete (DELETE /posts/comments/{id}).\n   *\n   * Input validation includes correct types for filters, max page size, and\n   * valid sort orders. Error handling covers unauthorized access, malformed\n   * filters, and nonexistent references.\n   *\n   * @param body Defines filtering, pagination, and sorting criteria for\n   *   retrieving comments. Fields may include postId, userId, parentId,\n   *   search, offset, limit, and sort.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IComment.IRequest,\n  ): Promise<IPageIComment> {\n    body;\n    return typia.random<IPageIComment>();\n  }\n\n  /**\n   * Fetch detailed information about a single comment (Posts domain,\n   * 'comments' table).\n   *\n   * This API fetches the detail of a single comment in the discussion board\n   * by its unique ID. Common scenarios include users viewing a nested reply,\n   * moderators inspecting a reported comment, or when displaying a comment in\n   * thread view.\n   *\n   * It returns full details such as content, author, timestamps, post\n   * reference, parent comment reference, and vote tallies. The route\n   * references the 'comments' table (Posts domain) and is optimized for quick\n   * retrieval. It will not return comments marked as deleted unless accessed\n   * by a user with sufficient privileges (e.g., moderator or admin).\n   *\n   * Error handling includes returning appropriate errors for nonexistent,\n   * deleted, or unauthorized access. Related APIs: listing (PATCH\n   * /posts/comments), update (PUT /posts/comments/{id}), creation (POST\n   * /posts/comments), and deletion (DELETE /posts/comments/{id}).\n   *\n   * @param id Target comment's ID\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IComment> {\n    id;\n    return typia.random<IComment>();\n  }\n\n  /**\n   * Update an existing comment's content or deletion status (Posts domain,\n   * 'comments' table).\n   *\n   * This API allows an authorized user (typically the comment's original\n   * author or a moderator/admin) to update the content or status of a\n   * comment. Supported fields for update include content (for editing), and\n   * soft deletion flag.\n   *\n   * Checks include author authentication, edit time-window (if enforced by\n   * policy), and protection against editing after moderation/deletion. Input\n   * validation ensures updated content meets platform standards, and\n   * references are unaltered (cannot change post or parentId).\n   *\n   * The endpoint references the 'comments' table (Posts domain). On success,\n   * returns the updated comment object. Error scenarios include not found,\n   * unauthorized modification, or invalid updates. Related APIs: create (POST\n   * /posts/comments), retrieve (GET /posts/comments/{id}), delete (DELETE\n   * /posts/comments/{id}).\n   *\n   * @param id The target comment's ID to update\n   * @param body Fields to update in the comment (content and/or soft delete).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IComment.IUpdate,\n  ): Promise<IComment> {\n    id;\n    body;\n    return typia.random<IComment>();\n  }\n\n  /**\n   * Soft-delete a comment (Posts domain, 'comments' table).\n   *\n   * This API performs a soft deletion (marks as deleted) of a comment\n   * identified by its ID. Typical scenarios: the comment's author chooses to\n   * remove their reply, or a moderator removes content that violates policy.\n   * The comment remains in the database (for auditability), but becomes\n   * invisible to regular users and excluded from normal listings.\n   *\n   * Authorization checks enforce only the author, moderator, or admin can\n   * perform this. Related error handling includes not found, already deleted,\n   * and unauthorized access. Audit logs are typically recorded. Related\n   * endpoints: create (POST /posts/comments), update (PUT\n   * /posts/comments/{id}), retrieve (GET /posts/comments/{id}), list (PATCH\n   * /posts/comments).\n   *\n   * @param id The comment's ID to delete\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IComment.IDeleteResult> {\n    id;\n    return typia.random<IComment.IDeleteResult>();\n  }\n}\n",
      "src/controllers/votes/votes/VotesVotesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IVote } from \"../../../api/structures/IVote\";\nimport { IPageIVote } from \"../../../api/structures/IPageIVote\";\n\n@Controller(\"/votes/votes\")\nexport class VotesVotesController {\n  /**\n   * Create a new vote (Votes domain, 'votes' table).\n   *\n   * Lets a user cast a vote—either upvote or downvote—on a post or comment.\n   * Input: must include user ID, value (+1/-1), and reference to either a\n   * post or a comment (but not both). Performs validation to ensure target\n   * exists and user has not already voted. On success, returns created vote\n   * record.\n   *\n   * Vote limit: only one vote per user per content item, enforced via unique\n   * constraint. Can be used for voting analytics, user history, and tally\n   * calculations. Related endpoints: retrieve (GET /votes/votes/{id}), update\n   * (PUT /votes/votes/{id}), delete (DELETE /votes/votes/{id}), list (PATCH\n   * /votes/votes).\n   *\n   * @param body Cast a vote on a post or comment: must include value (+1 or\n   *   -1) and target (postId or commentId).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IVote.ICreate,\n  ): Promise<IVote> {\n    body;\n    return typia.random<IVote>();\n  }\n\n  /**\n   * Retrieve a filtered, paginated list of votes (Votes domain, 'votes'\n   * table).\n   *\n   * This API returns a list of vote records, most commonly used for reviewing\n   * moderation history, analytics, or a user's own votes. Supports filtering\n   * by userId, postId, or commentId; pagination (offset/limit); sort order\n   * (most recent, oldest first). Optionally, can search for patterns if\n   * metadata fields exist.\n   *\n   * References the 'votes' table (Votes domain) and makes use of unique\n   * constraints (one vote per user per item) in its filtering logic. Security\n   * notes: regular users can only see their own votes, admins/moderators may\n   * audit all. Related endpoints: create (POST /votes/votes), update (PUT\n   * /votes/votes/{id}), detail (GET /votes/votes/{id}), delete (DELETE\n   * /votes/votes/{id}).\n   *\n   * @param body Filtering, pagination, and sorting for votes list. Fields:\n   *   userId, postId, commentId, offset, limit, sort.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IVote.IRequest,\n  ): Promise<IPageIVote> {\n    body;\n    return typia.random<IPageIVote>();\n  }\n\n  /**\n   * Retrieve full details for a single vote (Votes domain, 'votes' table).\n   *\n   * Fetches detail for a specific vote, identified by its unique ID. Useful\n   * for moderation review or self-audit by a voting user. Information\n   * includes which user voted, the value (+1/-1), what post/comment was\n   * targeted, and timestamps.\n   *\n   * References the 'votes' table (Votes domain). Only visible to the vote's\n   * owner or those with sufficient privilege. Error handling covers not\n   * found, unauthorized access, and malformed IDs. Related endpoints: create\n   * (POST /votes/votes), update (PUT /votes/votes/{id}), details (PATCH\n   * /votes/votes), delete (DELETE /votes/votes/{id}).\n   *\n   * @param id Vote record's ID\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IVote> {\n    id;\n    return typia.random<IVote>();\n  }\n\n  /**\n   * Edit an existing vote's value (Votes domain, 'votes' table).\n   *\n   * Lets a user (or moderator/admin) edit an existing vote—typically to\n   * change their upvote to downvote or vice versa, or to correct an input\n   * error. Only the vote's owner or privileged users may edit. Only value can\n   * change; postId or commentId are immutable.\n   *\n   * Business logic is enforced as per the 'votes' table (Votes domain): only\n   * one vote per user/content, mutual exclusivity between postId/commentId,\n   * and all references must remain valid. Returns the updated vote on\n   * success. Related endpoints: create (POST /votes/votes), retrieve (GET\n   * /votes/votes/{id}), list (PATCH /votes/votes), delete (DELETE\n   * /votes/votes/{id}).\n   *\n   * @param id Vote record's ID to update\n   * @param body Fields to update in the vote (only value may be changed).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IVote.IUpdate,\n  ): Promise<IVote> {\n    id;\n    body;\n    return typia.random<IVote>();\n  }\n\n  /**\n   * Delete a vote record from the database (Votes domain, 'votes' table).\n   *\n   * This endpoint removes a specific vote by its ID. Common use-cases: a user\n   * withdraws their vote or a moderator/admin removes a vote for violating\n   * policy. The vote is deleted from the database (hard delete), and any\n   * relevant tally is decremented.\n   *\n   * Authorization checks ensure only the vote's owner or privileged roles may\n   * perform deletion. Related endpoints: create (POST /votes/votes), update\n   * (PUT /votes/votes/{id}), retrieve (GET /votes/votes/{id}), list (PATCH\n   * /votes/votes). Audit logging may be triggered for moderation actions.\n   *\n   * @param id Vote record's ID to delete\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IVote.IDeleteResult> {\n    id;\n    return typia.random<IVote.IDeleteResult>();\n  }\n}\n",
      "src/api/structures/IPost.ts": "import { tags } from \"typia\";\n\n/**\n * 토론 게시판의 게시글(포스트) 정보를 담는 도메인 오브젝트입니다.\n *\n * 작성자, 카테고리, 제목·본문, 생성/수정/삭제일 등을 보유하여 커뮤니티 핵심 콘텐츠 구조를 이룹니다.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPost = {\n  /** 게시글의 고유 ID (Prisma 'posts.id'). */\n  id: string & tags.Format<\"uuid\">;\n\n  /** 작성자(유저) ID (Prisma 'posts.user_id'). */\n  user_id: string & tags.Format<\"uuid\">;\n\n  /** 카테고리 ID (Prisma 'posts.category_id'). */\n  category_id: string & tags.Format<\"uuid\">;\n\n  /** 게시글 제목 (Prisma 'posts.title'). */\n  title: string;\n\n  /** 게시글 본문 (Prisma 'posts.content'). */\n  content: string;\n\n  /** 생성 시각 (Prisma 'posts.created_at'). */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /** 수정 시각 (Prisma 'posts.updated_at'). */\n  updated_at: string & tags.Format<\"date-time\">;\n\n  /** 삭제(soft delete) 시각(Prisma 'posts.deleted_at'). 삭제 안된 경우 null. */\n  deleted_at?: (string & tags.Format<\"date-time\">) | null;\n};\nexport namespace IPost {\n  /**\n   * 게시글(포스트)의 요약 정보를 제공하는 타입입니다. 목록 조회, 관계 프로퍼티 등에서 사용됩니다.\n   *\n   * 게시글의 고유 ID, 제목, 작성자 ID, 카테고리 ID, 생성일, 수정일, 댓글/추천 등 카운트 필수 정보를 담고 있어, 리스트\n   * UI 테이블/카드 등 요약 리스트용으로 활용합니다. 본문 전체나 관계 정보는 포함하지 않습니다.\n   */\n  export type ISummary = {\n    /** 게시글 고유 식별자(UUID). 예: '973c0116-ac2c-4ffb-b38b-7c4c45c7b2df' */\n    id: string & tags.Format<\"uuid\">;\n\n    /** 작성자(user)의 ID(UUID) */\n    user_id: string & tags.Format<\"uuid\">;\n\n    /** 속한 카테고리의 ID(UUID) */\n    category_id: string & tags.Format<\"uuid\">;\n\n    /** 게시글 제목 */\n    title: string;\n\n    /** 게시글 작성일시(ISO8601) */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /** 게시글 마지막 수정 시각(ISO8601) */\n    updated_at: string & tags.Format<\"date-time\">;\n\n    /** 해당 글의 댓글 개수 */\n    comment_count: number & tags.Type<\"int32\">;\n\n    /** 해당 글의 추천(투표) 합계 */\n    vote_count: number & tags.Type<\"int32\">;\n  };\n\n  /**\n   * 게시글 검색, 필터, 페이징에 요청 정보로 사용되는 객체입니다.\n   *\n   * 카테고리, 작성자, 키워드, 기간, 페이징 등 다양한 필터를 지원하여 게시글 탐색 UX를 구현합니다.\n   */\n  export type IRequest = {\n    /**\n     * 검색/필터링용 카테고리 ID.\n     *\n     * 특정 카테고리 내 게시글만 조회하고자 할 때 사용합니다.\n     */\n    category_id?: string & tags.Format<\"uuid\">;\n\n    /**\n     * 검색/필터링용 작성자(유저) ID.\n     *\n     * 특정 사용자가 작성한 게시글만 조회할 때 활용합니다.\n     */\n    user_id?: string & tags.Format<\"uuid\">;\n\n    /**\n     * 제목 키워드 검색 (부분 일치 허용).\n     *\n     * 게시글의 제목에 포함된 키워드로 검색합니다.\n     */\n    title?: string;\n\n    /**\n     * 본문 키워드 검색 (부분 일치 허용).\n     *\n     * 게시글의 전체 텍스트에서 키워드로 검색합니다.\n     */\n    content?: string;\n\n    /** 게시글 생성 시작일(검색 필터용, ISO8601). */\n    created_from?: string & tags.Format<\"date-time\">;\n\n    /** 게시글 생성 종료일(검색 필터용, ISO8601). */\n    created_to?: string & tags.Format<\"date-time\">;\n\n    /** 페이지 번호(1 이상). */\n    page: number & tags.Type<\"int32\"> & tags.Minimum<1>;\n\n    /** 페이지당 데이터 수(기본 100). */\n    limit: number & tags.Type<\"int32\"> & tags.Minimum<1>;\n  };\n\n  /**\n   * 게시글 신규 작성 요청에 전달되는 바디입니다.\n   *\n   * 카테고리, 제목, 본문, 작성자 정보를 반드시 포함해야 합니다. 생성일시 등은 서버에서 자동 처리합니다.\n   */\n  export type ICreate = {\n    /** 작성할 게시글의 카테고리 ID. (필수) */\n    category_id: string & tags.Format<\"uuid\">;\n\n    /** 게시글 제목. 예: '2025년 물가·인플레이션 전망' */\n    title: string;\n\n    /** 게시글 본문 내용. (텍스트·포맷팅 지원) */\n    content: string;\n\n    /** 작성자(Author) ID. 회원 작성 시 필수 */\n    user_id: string & tags.Format<\"uuid\">;\n\n    /** 생성시각 (시스템 자동 할당이지만, 조직 배치용으로도 허용될 수 있음) */\n    created_at?: string & tags.Format<\"date-time\">;\n  };\n\n  /**\n   * 기존 게시글(포스트)의 제목/본문/카테고리를 수정하는 요청 바디입니다.\n   *\n   * 각 필드는 선택값으로, 일부만 수정 가능하며 누락시 기존 값 유지합니다.\n   */\n  export type IUpdate = {\n    /** 변경할 게시글 제목 (옵션) */\n    title?: string;\n\n    /** 변경할 게시글 본문 (옵션) */\n    content?: string;\n\n    /** 변경할 카테고리 ID (옵션) */\n    category_id?: string & tags.Format<\"uuid\">;\n  };\n\n  /**\n   * 게시글 삭제(soft/hard) 요청 결과나 상태를 반환하는 결과 객체입니다.\n   *\n   * 정상 삭제(숨김) 시 success=true, 실패 시 false와 설명 메시지를 제공합니다.\n   */\n  export type IDeleteResult = {\n    /** 삭제(Soft 또는 Hard) 성공 여부 */\n    success: boolean;\n\n    /** 삭제 결과 메시지 */\n    message: string;\n  };\n}\n",
      "src/api/structures/IUser.ts": "import { tags } from \"typia\";\n\nimport { IUserRole } from \"./IUserRole\";\nimport { IPost } from \"./IPost\";\nimport { IComment } from \"./IComment\";\nimport { IVote } from \"./IVote\";\n\n/**\n * Full user entity, as per users Prisma schema. Contains all non-confidential\n * account info and relations.\n *\n * Detailed per-table and per-field documentation referenced from schema.\n * Represents user profiles for detail pages and admin/mod tools.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IUser = {\n  /**\n   * Unique internal user ID (users.id). Used system-wide to link all user\n   * objects, references, and foreign keys.\n   *\n   * Required; generated upon account creation and immutable.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Foreign key to user_roles.id; denotes the active permission set (member,\n   * moderator, admin, etc).\n   *\n   * Required at creation; determines access, moderation, and board\n   * capabilities.\n   */\n  user_role_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Unique public display name; visible to all, and referenced in discussion,\n   * voting, and moderation.\n   *\n   * Database-enforced as unique.\n   */\n  username: string;\n\n  /**\n   * User's email address. Used for login and communication.\n   *\n   * Never displayed publicly. Must be unique.\n   */\n  email: string & tags.Format<\"email\">;\n\n  /**\n   * Free-form user biography/self-description.\n   *\n   * Optional, enhances social context on the board.\n   */\n  bio?: string | null;\n\n  /**\n   * Account creation datetime (with timezone). Used for auditing, ordering,\n   * and admin reporting.\n   *\n   * Immutable.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Most recent profile update timestamp for this user.\n   *\n   * Updated whenever profile fields are changed.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Current account status (active, suspended, banned, etc.).\n   *\n   * Enforced per moderation/business rule policies.\n   */\n  status: string;\n  role: IUserRole;\n\n  /**\n   * Array of summaries for posts authored by the user (board threads or\n   * articles).\n   */\n  posts?: IPost.ISummary[];\n\n  /** List of summaries for comments made by this user. */\n  comments?: IComment.ISummary[];\n\n  /** Summary array of votes cast by the user on posts/comments. */\n  votes?: IVote.ISummary[];\n};\nexport namespace IUser {\n  /**\n   * User list request/filter parameters, supporting pagination, search, and\n   * filtering by role or status.\n   *\n   * Implements board requirements around user management and moderation.\n   * Based on database and business rules from Core.users and relevant API\n   * operation specs.\n   */\n  export type IRequest = {\n    /**\n     * Page number for user list pagination. Optional field, aligns with\n     * standard best practices for paginated APIs.\n     *\n     * Used to retrieve a specific page of user data. Default follows the\n     * IPage IRequest definition.\n     */\n    page?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /**\n     * Number of users per page (for pagination). Optional, defaults to 100\n     * if unspecified as per IPage specification.\n     *\n     * Restricts how many user records are returned in each page.\n     */\n    limit?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /**\n     * Filter by user role (user_roles.id) to return users with a specific\n     * role (e.g., member, moderator, administrator).\n     *\n     * Helps admins/moderators filter and locate users of a particular type\n     * or permission set.\n     */\n    role?: string & tags.Format<\"uuid\">;\n\n    /**\n     * Filter users by account status (e.g., 'active', 'suspended',\n     * 'banned').\n     *\n     * Enables moderation and administrative user management by quickly\n     * finding users in specific states.\n     */\n    status?: string;\n\n    /**\n     * Search string, matches username or email in user list queries.\n     *\n     * Supports quick filtering of users when searching by identifying\n     * fields; case-insensitive partial match.\n     */\n    search?: string;\n  };\n\n  /**\n   * Concise user summary as returned in user listing responses. Hides\n   * sensitive fields.\n   *\n   * Includes only public profile, role summary, and status info. Used in\n   * paginated user lists and admin/member lookup features.\n   */\n  export type ISummary = {\n    /**\n     * User's unique identifier (UUID).\n     *\n     * Referenced from users.id in the database, required for user profile\n     * lookups.\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Public username (displayed in the board and visible to all users).\n     *\n     * Unique and required; serves as the user's main identifier for\n     * discussions, voting, and moderation.\n     */\n    username: string;\n\n    /**\n     * Optional user biography; a short self-description or interests\n     * section.\n     *\n     * May be empty; helps other members know basic info about the user.\n     */\n    bio?: string | null;\n    role: IUserRole.ISummary;\n\n    /**\n     * Current user account status (e.g., 'active', 'suspended', 'banned').\n     *\n     * Reflects moderation, login eligibility, and enforcement of platform\n     * rules.\n     */\n    status: string;\n  };\n\n  /**\n   * Request body schema for new user registration/account creation.\n   *\n   * All required/optional fields per users model. Password is accepted as\n   * clear text but is hashed internally.\n   */\n  export type ICreate = {\n    /**\n     * Role assignment for new user; must match user_roles.id. Required at\n     * registration. E.g., 'member', 'moderator', or 'administrator'.\n     */\n    user_role_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * New user's unique public display name. Required, must be unique,\n     * visible on the board.\n     */\n    username: string;\n\n    /**\n     * New user's email address. Required for registration, must be unique,\n     * never public.\n     */\n    email: string & tags.Format<\"email\">;\n\n    /** Optional user bio/about section. May be empty upon registration. */\n    bio?: string | null;\n\n    /**\n     * User password, plain text at registration. Required; will be securely\n     * hashed before storage. Never returned by API.\n     */\n    password: string;\n\n    /**\n     * Initial status for user: normally 'active', but admin can specify\n     * e.g., 'pending', 'suspended'.\n     */\n    status: string;\n  };\n\n  /**\n   * Request body for updating an existing user profile/account.\n   *\n   * Only fields supplied are updated; all are optional. Password change is\n   * NOT handled here.\n   */\n  export type IUpdate = {\n    /**\n     * (Optional) Role update for user. Admin/moderator action only. Must\n     * match an existing user_roles.id.\n     */\n    user_role_id?: string & tags.Format<\"uuid\">;\n\n    /**\n     * (Optional) Update to user's public display name. Must be unique if\n     * updated.\n     */\n    username?: string;\n\n    /**\n     * (Optional) Update to user's email address. Uniqueness required if\n     * changed.\n     */\n    email?: string & tags.Format<\"email\">;\n\n    /** (Optional) Update to bio/about me field. */\n    bio?: string | null;\n\n    /** (Optional) Modify user account status (active, suspended, etc.). */\n    status?: string;\n\n    /** Update timestamp; automatically set by the server on update. */\n    updated_at?: string & tags.Format<\"date-time\">;\n  };\n\n  /**\n   * Response for user deletion operation. Contains minimal identifying and\n   * audit info.\n   *\n   * Does not reveal sensitive user fields.\n   */\n  export type IDeleteResponse = {\n    /**\n     * ID of user deleted or marked for deletion. Used for reference in\n     * audit trails and deletion confirmations.\n     */\n    id?: string & tags.Format<\"uuid\">;\n\n    /**\n     * Status message (e.g., 'deleted', 'suspended', etc.) after\n     * deletion/disable action.\n     */\n    status?: string;\n  };\n}\n",
      "src/api/structures/IUserRole.ts": "import { tags } from \"typia\";\n\nimport { IUser } from \"./IUser\";\n\n/**\n * Full user role entity, as per user_roles Prisma model. Details all\n * privilege/permission details, assignment context, and required unique\n * properties.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IUserRole = {\n  /**\n   * Unique ID for this user role entry.\n   *\n   * Primary key in user_roles. Required for all entity referencing\n   * (assignment, lookup, etc.).\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Machine- and human-readable name for the user role, e.g., 'member',\n   * 'moderator', or 'administrator'.\n   *\n   * Must be unique, and required for referential integrity.\n   */\n  name: string;\n\n  /**\n   * Human explanation of what privileges and duties this role holds.\n   *\n   * Aids in assigning and documenting permissions for users. Required for\n   * compliance with admin/business rule traceability.\n   */\n  description: string;\n\n  /**\n   * (For reference/audit) Array of users holding this role. May be omitted if\n   * not required at runtime.\n   */\n  users?: IUser.ISummary[];\n};\nexport namespace IUserRole {\n  /**\n   * Summary/view version of a user role entity. Contains only essential\n   * fields (id, name).\n   *\n   * Used for responses where full details are unnecessary but reference is\n   * required.\n   */\n  export type ISummary = {\n    /**\n     * Unique identifier for user role (user_roles.id field).\n     *\n     * Enforces referential integrity for permission assignments.\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Short label name for the user role (e.g., 'member', 'moderator',\n     * 'administrator').\n     *\n     * Used in dropdowns, labels, admin tools. Required and unique per\n     * database schema.\n     */\n    name: string;\n  };\n\n  /**\n   * List/request filtering schema for user roles table.\n   *\n   * Supports pagination, keyword search for role management dashboards,\n   * registration, and editor widgets.\n   */\n  export type IRequest = {\n    /**\n     * Page number for role list pagination. Optional; aligns with IPage\n     * best-practice.\n     */\n    page?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /**\n     * Pagination limit for number of roles per page. Defaults to 100 if\n     * missing.\n     *\n     * Standard for IPage APIs.\n     */\n    limit?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /**\n     * Keyword filter for role name or description fields. Enables quick\n     * role lookup.\n     */\n    search?: string;\n  };\n\n  /**\n   * Request schema for creating new user roles.\n   *\n   * Allows admin tools to set up new permissions/policies in the board, with\n   * full business rule auditing.\n   */\n  export type ICreate = {\n    /**\n     * Unique name for new role; will become user_roles.name. E.g.,\n     * 'moderator', 'editor', or custom label.\n     */\n    name: string;\n\n    /**\n     * Text description covering what the role enables/limits for users\n     * assigned to it.\n     */\n    description: string;\n  };\n\n  /**\n   * Request schema for editing an existing user role entry.\n   *\n   * All fields optional; only modified fields must be sent.\n   */\n  export type IUpdate = {\n    /** (Optional) New/updated role name. Must remain unique if updated. */\n    name?: string;\n\n    /** (Optional) Update/extend role meaning or allowed actions. */\n    description?: string;\n  };\n\n  /**\n   * Response schema for confirming user role deletion (admin-only).\n   *\n   * Includes minimal info required for audit logs and error/success\n   * reporting.\n   */\n  export type IDeleteResponse = {\n    /**\n     * ID of user role entry deleted or marked deleted. For audit and\n     * post-delete reference.\n     */\n    id?: string & tags.Format<\"uuid\">;\n\n    /**\n     * Delete or audit status: e.g., 'deleted', 'archived', 'in use - not\n     * deleted'.\n     */\n    status?: string;\n  };\n}\n",
      "src/api/structures/IPageIUser.ts": "import { IPage } from \"./IPage\";\nimport { IUser } from \"./IUser\";\n\nexport namespace IPageIUser {\n  /**\n   * Paginated user summary list container.\n   *\n   * Standardized IPage<T> wrapper for user listings, as per business\n   * requirements.\n   */\n  export type ISummary = {\n    pagination: IPage.IPagination;\n\n    /** Paginated list of user summaries matching request filters. */\n    data: IUser.ISummary[];\n  };\n}\n",
      "src/api/structures/IPageIUserRole.ts": "import { IPage } from \"./IPage\";\nimport { IUserRole } from \"./IUserRole\";\n\n/**\n * Paginated wrapper of user roles, for admin lookup and registration dropdowns.\n *\n * Implements standard IPage format with list of IUserRole.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIUserRole = {\n  pagination: IPage.IPagination;\n\n  /** Array of role entities for administrative/user assignment purposes. */\n  data: IUserRole[];\n};\n",
      "src/api/structures/IPage.ts": "import { tags } from \"typia\";\n\nexport namespace IPage {\n  /**\n   * Pagination metadata for paged responses, including\n   * current/limit/total/pageCount as per business requirements and search\n   * usability.\n   */\n  export type IPagination = {\n    /** Current page number. */\n    current: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /** Limitation of records per a page. Default: 100. */\n    limit: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /** Total records in the database. */\n    records: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /** Total number of pages (records/limit, ceiled). */\n    pages: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n  };\n}\n",
      "src/api/structures/ICategory.ts": "import { tags } from \"typia\";\n\n/**\n * 토론 게시판의 주제분류(카테고리) 정보를 담는 엔터티입니다.\n *\n * 각 카테고리는 고유명, 설명, 생성일시 필드를 가지며 게시글(Posts)과 1:N 관계입니다. 관리자가 생성·관리하며, 게시글 작성 시\n * 반드시 할당해야 하는 구조입니다.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type ICategory = {\n  /**\n   * 카테고리의 고유 식별자(UUID).\n   *\n   * Prisma 'categories.id' 컬럼. 예: 'b4682df2-b264-4e1b-807d-381340390a64'.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * 카테고리 이름(고유).\n   *\n   * Prisma 'categories.name' 컬럼. 예: '정치', '경제'\n   */\n  name: string;\n\n  /**\n   * 카테고리 상세 설명.\n   *\n   * Prisma 'categories.description' 컬럼. 예: '정치 제도와 관련된 모든 주제를 다룹니다.'\n   */\n  description: string;\n\n  /**\n   * 카테고리 생성 일시(ISO8601).\n   *\n   * Prisma 'categories.created_at' 컬럼. 예: '2024-06-09T09:00:00+09:00'.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace ICategory {\n  /**\n   * 카테고리 리스트/검색 요청에 이용되는 필터, 검색, 페이징 정보 객체입니다.\n   *\n   * 카테고리 명, 설명, 기간 필터, 페이징 조작(페이지, limit) 등 검색 옵션을 다루며, 관리자 또는 일반 사용자의 카테고리\n   * 목록 검색 시 활용됩니다.\n   */\n  export type IRequest = {\n    /**\n     * 필터링 또는 검색을 위한 카테고리 이름입니다.\n     *\n     * 예: '정치', '경제'\n     */\n    name?: string;\n\n    /**\n     * 카테고리 설명의 검색을 위한 옵션 필드입니다.\n     *\n     * 예: '정치 체계와 관련된 논의', '국제 경제 토론'\n     */\n    description?: string;\n\n    /** 검색 시작일자(ISO8601 형식). 예: '2024-06-09T00:00:00+09:00'. */\n    created_from?: string & tags.Format<\"date-time\">;\n\n    /** 검색 종료일자(ISO8601 형식). 예: '2024-07-09T23:59:59+09:00'. */\n    created_to?: string & tags.Format<\"date-time\">;\n\n    /** 페이지 번호(1부터 시작). */\n    page: number & tags.Type<\"int32\"> & tags.Minimum<1>;\n\n    /** 페이지당 반환할 레코드 수(기본값 100). */\n    limit: number & tags.Type<\"int32\"> & tags.Minimum<1>;\n  };\n\n  /**\n   * 카테고리 신규 생성시 전달하는 요청 바디 객체입니다.\n   *\n   * 이름(고유), 설명을 필수로 제공해야 하며, 관리자가 카테고리를 추가할 때 활용됩니다.\n   */\n  export type ICreate = {\n    /** 신규 카테고리의 이름(고유). 예: '시사', '국제'. */\n    name: string;\n\n    /** 카테고리 상세 설명. 예: '글로벌 경제 및 정치 이슈를 다루는 공간입니다.' */\n    description: string;\n  };\n\n  /**\n   * 기존 카테고리의 이름·설명을 수정하는 요청 바디입니다.\n   *\n   * 두 필드 모두 선택적이며, 하나 또는 모두 변경할 수 있습니다.\n   */\n  export type IUpdate = {\n    /** 변경할 카테고리명(옵션). 예: '사회' */\n    name?: string;\n\n    /** 변경할 카테고리 설명(옵션). */\n    description?: string;\n  };\n\n  /**\n   * 카테고리 삭제(soft/hard delete) 결과를 나타내는 오브젝트입니다.\n   *\n   * 성공/실패의 플래그 및 설명 메시지를 포함해 후처리 사용자 안내에 활용합니다.\n   */\n  export type IDeleteResult = {\n    /** 삭제 성공 여부. true 이면 정상 삭제, false 이면 오류. */\n    success: boolean;\n\n    /** 삭제 결과 메시지(실패 이유, 성공 안내 등). */\n    message: string;\n  };\n}\n",
      "src/api/structures/IPageICategory.ts": "import { IPage } from \"./IPage\";\nimport { ICategory } from \"./ICategory\";\n\n/**\n * 카테고리 검색/조회 결과를 담는 페이지 컨테이너 타입입니다.\n *\n * 페이지네이션 메타데이터와 함께 실제 데이터 목록(카테고리 배열)을 포함해, 목록 화면 및 검색 결과에서 활용합니다.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageICategory = {\n  /** 페이지네이션 정보로, 현재 페이지, 전체 레코드 수, 전체 페이지 수 등을 제공합니다. */\n  pagination: IPage.IPagination;\n\n  /** 카테고리 목록 데이터 배열입니다. */\n  data: ICategory[];\n};\n",
      "src/api/structures/IPageIPost.ts": "import { IPage } from \"./IPage\";\nimport { IPost } from \"./IPost\";\n\n/**\n * 게시글 검색/조회 결과를 담는 페이지 컨테이너 타입입니다.\n *\n * 페이지 정보와 게시글 배열을 함께 반환하여 결과 화면에서 활용합니다.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIPost = {\n  /** 페이지네이션 메타데이터 */\n  pagination: IPage.IPagination;\n\n  /** 검색 결과 게시글(Posts) 배열 */\n  data: IPost[];\n};\n",
      "src/api/structures/IComment.ts": "import { tags } from \"typia\";\n\n/**\n * Represents a Comment record, as per the Posts domain comments model and\n * requirements analysis.\n *\n * Includes all primary properties as described in the Prisma schema, with full\n * typing and references to related entities (users, posts, parent comments).\n * Supports auditability, moderation, and business logic for threaded\n * conversations.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IComment = {\n  /**\n   * Primary Key. Unique identifier for each comment (see comments.id in\n   * schema).\n   *\n   * Assigned at creation; required for retrieval, update, and reference by\n   * other entities (votes, replies).\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Author's {@link users.id}.\n   *\n   * Stores the user's unique identifier responsible for the comment, using\n   * the relationship to users. Enables auditing, author lookup, and\n   * permissions checks.\n   */\n  user_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * The ID of the post this comment is attached to ({@link posts.id}).\n   *\n   * Crucial for associating the comment as a reply to a given post,\n   * reflecting business rules and ERD documentation.\n   */\n  post_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Parent comment's {@link comments.id}.\n   *\n   * Used for nested (threaded) replies. Null for top-level comments. Enables\n   * tree-based conversations.\n   */\n  parent_id?: (string & tags.Format<\"uuid\">) | null;\n\n  /**\n   * Main text of the comment; user-provided reply content.\n   *\n   * References the comments.content field; holds message body visible to\n   * users.\n   */\n  content: string;\n\n  /**\n   * Timestamp when the comment was first authored (see comments.created_at).\n   *\n   * Used for chronological ordering, moderation, and audit.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Timestamp of last edit to the comment (see comments.updated_at).\n   *\n   * Enables edit history, moderation, or user accountability.\n   */\n  updated_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Soft deletion timestamp (see comments.deleted_at).\n   *\n   * Null if not deleted; otherwise contains date/time when marked deleted for\n   * moderation/auditing.\n   */\n  deleted_at?: (string & tags.Format<\"date-time\">) | null;\n};\nexport namespace IComment {\n  /**\n   * Defines filtering, pagination, and sorting criteria for retrieving\n   * comments. Fields draw directly from the requirements and Prisma comments\n   * model.\n   *\n   * This allows filtering by comments made on a post, by a user, or as\n   * replies to a parent, along with keyword search and pagination. Reflects\n   * full API and business use cases for comment listing endpoints.\n   */\n  export type IRequest = {\n    /**\n     * The unique ID of the target post to which comments should be\n     * filtered.\n     *\n     * Based on the comments table, 'post_id' field links the comment to a\n     * particular post for thread-based filtering. Sourced from the business\n     * rule: 'Each Comment is linked to a Post.'\n     */\n    postId?: string & tags.Format<\"uuid\">;\n\n    /**\n     * The unique ID of the user who authored comments.\n     *\n     * Designed for filtering comments made by a specific user, as\n     * referenced in the comments.user_id column.\n     */\n    userId?: string & tags.Format<\"uuid\">;\n\n    /**\n     * The parent comment's ID, for retrieving or searching nested replies.\n     *\n     * This relates to the self-referential thread system: filtering for\n     * replies to a specific comment.\n     */\n    parentId?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * A keyword or phrase to search in comment content.\n     *\n     * Implements full-text search capability as referenced in content field\n     * and API description.\n     */\n    search?: string;\n\n    /**\n     * The starting index for pagination.\n     *\n     * Allows skipping records in list pagination, supporting usability in\n     * large thread navigation.\n     */\n    offset?: number &\n      tags.Type<\"int32\"> &\n      tags.Default<0> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n\n    /**\n     * Maximum number of records to return per page. Defaults to 20 if not\n     * specified.\n     */\n    limit?: number &\n      tags.Type<\"int32\"> &\n      tags.Default<20> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n\n    /**\n     * Sorting order or field, e.g., 'created_at:desc', 'created_at:asc'.\n     *\n     * Aligns with thread listing sorting as described in business and API\n     * requirements.\n     */\n    sort?: string;\n  };\n\n  /**\n   * Object for creating a new comment. Includes required properties for new\n   * replies, including references to post, author, and optionally a parent\n   * for nested threading. Matches business rules requiring each comment to\n   * have an associated user (author) and post, plus the option to nest under\n   * another comment.\n   */\n  export type ICreate = {\n    /**\n     * User ID (author's identifier). Must reference an existing user.\n     * Required to ensure only registered users may comment.\n     *\n     * Fulfills business rule that only registered users can create\n     * comments.\n     */\n    user_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * ID of the post this comment is on. Implements business rule requiring\n     * every comment to be attached to a post.\n     */\n    post_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Parent comment's ID for nested replies. Optional. Enables thread\n     * hierarchy as in the business requirements.\n     */\n    parent_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * Main comment body text. Required; validated for length and content\n     * rules by business logic.\n     */\n    content: string;\n  };\n\n  /**\n   * Object for updating an existing comment (edit or soft-delete). User or\n   * moderator may use this to change content or to mark the comment as\n   * deleted.\n   *\n   * References the comments Prisma model and moderation business rules: only\n   * content or soft-delete flag is usually editable.\n   */\n  export type IUpdate = {\n    /**\n     * New comment body, if editing. Must meet length/content requirements\n     * from business logic.\n     */\n    content?: string;\n\n    /**\n     * Timestamp for marking a comment as deleted (for moderation/audit).\n     * Set to current time for 'soft delete,' or null to un-delete if\n     * allowed.\n     */\n    deleted_at?: (string & tags.Format<\"date-time\">) | null;\n  };\n\n  /**\n   * Result object for delete operations on comments. Confirms deletion (soft\n   * or hard), as required by business rules and audit requirements. Returns\n   * the comment ID, deletion status, and optional human-readable message.\n   */\n  export type IDeleteResult = {\n    /** ID of the comment that was deleted. */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Status: true if successfully deleted (soft or hard as per policy),\n     * false otherwise.\n     */\n    deleted: boolean;\n\n    /** A confirmation or informative message about the deletion result. */\n    message?: string;\n  };\n\n  /**\n   * A concise summary type for comments, covering the most important\n   * references and metadata for paginated or overview lists.\n   */\n  export type ISummary = {\n    /** Unique identifier for the comment. */\n    id: string & tags.Format<\"uuid\">;\n\n    /** User (author) of the comment. */\n    user_id: string & tags.Format<\"uuid\">;\n\n    /** Parent post for the comment. */\n    post_id: string & tags.Format<\"uuid\">;\n\n    /** Parent comment (if any). */\n    parent_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /** Timestamp of comment creation. */\n    created_at: string & tags.Format<\"date-time\">;\n  };\n}\n",
      "src/api/structures/IPageIComment.ts": "import { IPage } from \"./IPage\";\nimport { IComment } from \"./IComment\";\n\n/**\n * A paginated list of comment summaries, including pagination metadata (page,\n * limit, total, etc.) and a summary array.\n *\n * Combines IPage (standard) with IComment.ISummary as required by comment\n * browsing scenarios.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIComment = {\n  pagination: IPage.IPagination;\n\n  /**\n   * A list of comment summary objects on the current page.\n   *\n   * Each item is a concise representation of a comment as described in\n   * business use-cases: post/reply thread listings.\n   */\n  data: IComment.ISummary[];\n};\n",
      "src/api/structures/IVote.ts": "import { tags } from \"typia\";\n\n/**\n * Represents a Vote as defined in the votes table: one record for each\n * upvote/downvote action on a post or comment. Covers voter ID, target (post or\n * comment), value (+1/-1), and creation timestamp. Fully aligned with\n * requirements analysis and business logic for\n * single-vote-per-user-per-content.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IVote = {\n  /** Primary Key. Unique identifier for each vote record (votes.id). */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * The ID of the user casting the vote (votes.user_id), referencing users\n   * table for author.\n   */\n  user_id: string & tags.Format<\"uuid\">;\n\n  /** The voted post's ID (votes.post_id). Mutually exclusive with comment_id. */\n  post_id?: (string & tags.Format<\"uuid\">) | null;\n\n  /**\n   * The voted comment's ID (votes.comment_id). Mutually exclusive with\n   * post_id.\n   */\n  comment_id?: (string & tags.Format<\"uuid\">) | null;\n\n  /**\n   * Value of the vote (+1 for upvote, -1 for downvote). Aggregated to compute\n   * content rankings.\n   */\n  value: number & tags.Type<\"int32\">;\n\n  /** Timestamp of when the vote was created (votes.created_at). */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IVote {\n  /**\n   * Filtering, pagination, and sorting criteria for votes listing requests,\n   * following the votes table business logic and related requirements.\n   *\n   * Filters support querying by voter, target post, or comment, with support\n   * for pagination and sorting. Business rules enforce only mutual\n   * exclusivity between postId/commentId (never both set).\n   */\n  export type IRequest = {\n    /**\n     * Unique identifier of the user who cast the vote. Used for filtering\n     * votes by a specific voter (see votes.user_id in schema and ERD).\n     */\n    userId?: string & tags.Format<\"uuid\">;\n\n    /**\n     * Unique identifier of the post that received the vote (see\n     * votes.post_id). Mutually exclusive with commentId.\n     */\n    postId?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * Unique identifier of the comment that received the vote (see\n     * votes.comment_id). Mutually exclusive with postId.\n     */\n    commentId?: (string & tags.Format<\"uuid\">) | null;\n\n    /** Starting index for pagination (default 0). */\n    offset?: number &\n      tags.Type<\"int32\"> &\n      tags.Default<0> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n\n    /** Maximum number of records to return per page. */\n    limit?: number &\n      tags.Type<\"int32\"> &\n      tags.Default<20> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n\n    /** Sorting field or order (default 'created_at:desc'). */\n    sort?: string;\n  };\n\n  /**\n   * Object for creating a new vote as per voting business rules:\n   *\n   * - User_id: registered voter\n   * - Value: +1 (upvote) or -1 (downvote)\n   * - Target: must specify either post_id or comment_id (never both) Enforces\n   *   one vote per user/content as described in requirements.\n   */\n  export type ICreate = {\n    /**\n     * ID of the user casting the vote. References the users table; ensures\n     * only registered users can vote.\n     */\n    user_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Vote value: +1 or -1 as per business requirements. Used for up/down\n     * voting of posts/comments.\n     */\n    value: number & tags.Type<\"int32\">;\n\n    /**\n     * Target post's ID, if voting on a post. Mutually exclusive with\n     * comment_id.\n     */\n    post_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * Target comment's ID, if voting on a comment. Mutually exclusive with\n     * post_id.\n     */\n    comment_id?: (string & tags.Format<\"uuid\">) | null;\n  };\n\n  /**\n   * Object for updating existing votes, specifically editing the vote value\n   * (from +1 to -1, etc.).\n   *\n   * Does not allow changing the vote target (post_id/comment_id); supports\n   * audit and business logic for corrections.\n   */\n  export type IUpdate = {\n    /**\n     * The new vote value. Allows changing an upvote to downvote (or vice\n     * versa), strictly for existing votes per business rules.\n     */\n    value: number & tags.Type<\"int32\">;\n  };\n\n  /**\n   * Delete operation result for a vote record. Returns deleted vote's ID,\n   * deletion status, and optional result message, as required by business\n   * logic and for user/admin confirmation.\n   */\n  export type IDeleteResult = {\n    /** ID of the vote record that was deleted. */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Indicates if the vote was successfully deleted. */\n    deleted: boolean;\n\n    /** A human-readable confirmation message about the delete operation. */\n    message?: string;\n  };\n\n  /**\n   * Summary of a Vote for paginated/result lists, not including creation date\n   * but identifying all main relationships and value.\n   */\n  export type ISummary = {\n    /** Unique identifier for the vote. */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Voter's user ID. */\n    user_id: string & tags.Format<\"uuid\">;\n\n    /** Target post. */\n    post_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /** Target comment. */\n    comment_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /** Vote value (+1 or -1). */\n    value: number & tags.Type<\"int32\">;\n  };\n}\n",
      "src/api/structures/IPageIVote.ts": "import { IPage } from \"./IPage\";\nimport { IVote } from \"./IVote\";\n\n/**\n * A paginated set of votes, as used in vote listing, audit history, or\n * analytics use-cases. Follows IPage pattern with IVote.ISummary records per\n * voting business and DB design.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIVote = {\n  pagination: IPage.IPagination;\n\n  /** Array of vote summary records on this page. */\n  data: IVote.ISummary[];\n};\n",
      "src/api/functional/core/users/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IUser } from \"../../../structures/IUser\";\nimport { IPageIUser } from \"../../../structures/IPageIUser\";\n\n/**\n * Register a new user (core.users table).\n *\n * This operation handles new user registration or administrator-created user\n * accounts. It accepts all required and optional fields per the users model:\n * username, email, bio (optional), status, and an associated user_role_id.\n * Passwords are securely hashed before saving, never stored in plain text.\n *\n * Unique constraints are enforced for both username and email to prevent\n * duplicates. The user role must point to an existing role defined in\n * user_roles. Timestamps for creation and update are handled automatically.\n * Successful creation returns the newly registered user's public profile and\n * role association (never the password hash).\n *\n * Security and validation reflect business rules, e.g., email visibility,\n * profile privacy, and initial status setting. Input errors or duplicates\n * return clear messages and codes. Related endpoints: list (PATCH), read (GET),\n * update (PUT), delete (DELETE).\n *\n * @param props.body Registration info for the new user, including username,\n *   email, password, user role, etc.\n * @path /core/users\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /**\n     * Registration info for the new user, including username, email,\n     * password, user role, etc.\n     */\n    body: IUser.ICreate;\n  };\n  export type Body = IUser.ICreate;\n  export type Response = IUser;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/core/users\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/core/users\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>\n    typia.random<IUser>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve a paginated, filterable list of users (core.users table).\n *\n * This operation returns a paginated and filtered list of users registered on\n * the discussion board. Users may be searched by username, email, user role, or\n * status, and results are sorted and paginated according to the provided\n * parameters. The endpoint refers to the users table, whose structure includes\n * fields for username, email, bio, role reference, password hash, timestamps,\n * and status. Filters can help administrators or moderators locate specific\n * accounts, monitor new signups, or audit activity. Security is enforced: only\n * users with moderator or administrator roles can access or use advanced\n * filters.\n *\n * The endpoint applies business rules from the requirements, such as hiding\n * sensitive (e.g., password) information, and supports relations to user_roles\n * for displaying or filtering by user type. Pagination and sorting follow best\n * practices for usability and performance. Related endpoints: create (POST),\n * retrieve detail (GET), update (PUT), and delete (DELETE) for users.\n *\n * Error handling ensures invalid queries, unauthorized access, or database\n * issues are managed gracefully, returning clear status codes and messages.\n * Sensitive data, such as password hashes, is never included in responses.\n *\n * @param props.body Filtering, sorting, and pagination info for user listing\n *   request.\n * @path /core/users\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Filtering, sorting, and pagination info for user listing request. */\n    body: IUser.IRequest;\n  };\n  export type Body = IUser.IRequest;\n  export type Response = IPageIUser.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/core/users\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/core/users\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIUser.ISummary => typia.random<IPageIUser.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve detailed profile info for a specific user (core.users table).\n *\n * This operation retrieves the full profile and related information for a\n * specific user, identified by their unique user ID. Fields returned follow the\n * schema comments: username, email, bio, status, timestamps, and a reference to\n * their user role. User roles are resolved to human-readable labels where\n * appropriate.\n *\n * Sensitive fields such as password_hash are never returned. This endpoint is\n * typically used by administrators for user management, or by users to view\n * their own account details. Where authorized, moderators may use this endpoint\n * for resolving moderation cases or audits. The data aligns exactly with the\n * users table comments and model.\n *\n * Related endpoints include listing (PATCH), creation (POST), update (PUT), and\n * deletion (DELETE) for users. Error handling covers not found, unauthorized,\n * or forbidden cases, always giving appropriate error codes and minimal leak of\n * protected info.\n *\n * @param props.id Target user's ID (UUID).\n * @path /core/users/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target user's ID (UUID). */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IUser;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/core/users/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/core/users/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>\n    typia.random<IUser>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update user profile and account fields (core.users table).\n *\n * Updates an existing user's information, addressing fields in the users\n * schema, such as username, email, bio, role, status, and update timestamp. The\n * input must include the user ID and only permitted fields are updateable.\n * Username/email uniqueness is enforced on update as well.\n * Moderators/administrators can change roles/statuses as permitted by business\n * rules.\n *\n * The request never allows direct password updates (managed by a separate\n * dedicated endpoint, or by password reset process for security). All change\n * history is reflected in the updated_at timestamp. Security measures prevent\n * users from editing others' profiles unless authorized; self-edits are limited\n * to certain fields.\n *\n * Related endpoints: detail (GET), list (PATCH), create (POST), delete\n * (DELETE). Strict validation and business rule application ensure stability\n * and data quality.\n *\n * @param props.id Target user's ID (UUID).\n * @param props.body Editable fields for user update, such as profile details or\n *   status/role changes (excludes password updates).\n * @path /core/users/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Target user's ID (UUID). */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Editable fields for user update, such as profile details or\n     * status/role changes (excludes password updates).\n     */\n    body: IUser.IUpdate;\n  };\n  export type Body = IUser.IUpdate;\n  export type Response = IUser;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/core/users/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/core/users/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IUser =>\n    typia.random<IUser>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Softly or fully delete a user (core.users table).\n *\n * Deletes a user account with the specified ID. This typically marks the user's\n * status as deleted or suspended and/or sets a deletion flag in audit fields,\n * per the users Prisma schema and moderation rules. Associated content (posts,\n * comments, votes) may be retained for community reference, moderation, or\n * audit logs, as described in requirements.\n *\n * Only administrators may perform this action, and a detailed audit trail is\n * kept. Related endpoints are used for restoration or final hard-delete (if\n * policy allows). Errors for not found or forbidden actions are handled\n * appropriately; sensitive information on deleted users is not exposed.\n *\n * @param props.id Target user's ID (UUID).\n * @path /core/users/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Target user's ID (UUID). */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IUser.IDeleteResponse;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/core/users/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/core/users/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IUser.IDeleteResponse => typia.random<IUser.IDeleteResponse>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/core/index.ts": "export * as users from \"./users\";\nexport * as userRoles from \"./userRoles\";\nexport * as categories from \"./categories\";\n",
      "src/api/functional/index.ts": "export * as core from \"./core\";\nexport * as posts from \"./posts\";\nexport * as votes from \"./votes\";\n",
      "src/api/functional/core/userRoles/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IUserRole } from \"../../../structures/IUserRole\";\nimport { IPageIUserRole } from \"../../../structures/IPageIUserRole\";\n\n/**\n * Create a new user role (core.userRoles table).\n *\n * Creates a new user role based on the schema structure, with fields for name\n * (label) and description. Enforces the uniqueness of the role name and ensures\n * all required information is provided, following the comments and requirements\n * detailed in the Prisma schema.\n *\n * Intended for administrator setup or customization of new permission levels.\n * Errors are sent in case of duplicate names, missing fields, or insufficient\n * permissions. Successful creation returns the new user role record, suitable\n * for immediate assignment to users.\n *\n * Related endpoints: list (PATCH), single GET, update (PUT), and delete\n * (DELETE) for user roles.\n *\n * @param props.body New user role details, including name and description.\n * @path /core/userRoles\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** New user role details, including name and description. */\n    body: IUserRole.ICreate;\n  };\n  export type Body = IUserRole.ICreate;\n  export type Response = IUserRole;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/core/userRoles\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/core/userRoles\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IUserRole =>\n    typia.random<IUserRole>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List and filter user roles (core.userRoles table).\n *\n * This operation returns a paginated list of user roles available to assign, as\n * defined by the user_roles model. Roles govern permissions across the board\n * (e.g., member, moderator, administrator). Designed for use in registration\n * processes, admin dashboards, or role management panels, enabling filtering by\n * role name or description and ordering of results.\n *\n * Data returned is defined strictly by the Prisma model and schema comments.\n * This operation is auditable and respects business constraints on who may\n * view/assign roles. Related endpoints: single role GET, create (POST), update\n * (PUT), and delete (DELETE).\n *\n * Error cases (e.g., forbidden access) are handled with appropriate status\n * codes. Pagination and search parameters maximize usability and efficiency,\n * especially for large deployments with custom roles.\n *\n * @param props.body Filter, search, and pagination info for user roles listing.\n * @path /core/userRoles\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Filter, search, and pagination info for user roles listing. */\n    body: IUserRole.IRequest;\n  };\n  export type Body = IUserRole.IRequest;\n  export type Response = IPageIUserRole;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/core/userRoles\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/core/userRoles\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIUserRole =>\n    typia.random<IPageIUserRole>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a single user role's details (core.userRoles table).\n *\n * Retrieves all details for a single user role, specified by ID. Used in admin\n * panels to display all properties of a role, or in account registration to\n * inform users about the meaning and permissions of each role (as described in\n * schema comments: name, description, etc).\n *\n * Respects all business rules regarding role assignment and application.\n * Related endpoints: list (PATCH), creation (POST), update (PUT), delete\n * (DELETE). Errors for missing roles or unauthorized actions are handled\n * gracefully, with clear messaging.\n *\n * @param props.id Target role's ID (UUID).\n * @path /core/userRoles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target role's ID (UUID). */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IUserRole;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/core/userRoles/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/core/userRoles/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IUserRole =>\n    typia.random<IUserRole>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Edit label/description for a user role (core.userRoles table).\n *\n * Updates an existing user role's properties (name and/or description).\n * Uniqueness of the name is enforced by Prisma schema rules. Typical in systems\n * where additional roles/policies are introduced or for correcting role\n * definitions.\n *\n * Only administrators are permitted to update roles. Change history is tracked\n * and any update is reflected in audit fields. Related endpoints: detail GET,\n * list PATCH, creation POST, and deletion DELETE for user roles.\n *\n * Any errors due to duplicates, forbidden edits, or missing records generate\n * suitable error codes in response. Endpoint matches structure and intentions\n * described in requirements and schema comments.\n *\n * @param props.id Target role's ID (UUID).\n * @param props.body New values for user role fields (name/description).\n * @path /core/userRoles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Target role's ID (UUID). */\n    id: string & tags.Format<\"uuid\">;\n\n    /** New values for user role fields (name/description). */\n    body: IUserRole.IUpdate;\n  };\n  export type Body = IUserRole.IUpdate;\n  export type Response = IUserRole;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/core/userRoles/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/core/userRoles/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IUserRole =>\n    typia.random<IUserRole>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Delete a user role from the system (core.userRoles table).\n *\n * Deletes a user role identified by its ID. Enforces business and schema rules\n * about which roles can be deleted (e.g., prevents deletion of critical roles\n * if protected by business logic). If the role is in use (referenced by users),\n * operation will fail with a clear error message.\n *\n * Administrative rights are required. Detailed audit trails are maintained for\n * changes. Related endpoints: create (POST), list (PATCH), update (PUT), detail\n * (GET). All operations match Prisma schema and requirements. Appropriate\n * handling is provided for not found, forbidden, or dependency errors.\n *\n * @param props.id Target role's ID (UUID).\n * @path /core/userRoles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Target role's ID (UUID). */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IUserRole.IDeleteResponse;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/core/userRoles/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/core/userRoles/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IUserRole.IDeleteResponse => typia.random<IUserRole.IDeleteResponse>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/core/categories/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { ICategory } from \"../../../structures/ICategory\";\nimport { IPageICategory } from \"../../../structures/IPageICategory\";\n\n/**\n * Create new category (Core.categories).\n *\n * Allows creation of a new category topic for the discussion board, by\n * inserting a new record into the 'categories' table in the database. The\n * provided name must be unique among all categories. Description field gives\n * users context. Only authorized users (administrators) are permitted to\n * execute this operation.\n *\n * Input validation includes ensuring that required fields are present, name\n * does not duplicate existing entries, and description respects length/content\n * rules. On success, the new category is created and returned with full detail\n * including its assigned UUID and creation timestamp.\n *\n * Error handling covers invalid parameters, uniqueness violations, or\n * insufficient permissions.\n *\n * Related endpoints: list/search (PATCH), get (GET), update (PUT), and delete\n * (DELETE) for categories.\n *\n * @param props.body Data for new category including unique name and\n *   description.\n * @path /core/categories\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** Data for new category including unique name and description. */\n    body: ICategory.ICreate;\n  };\n  export type Body = ICategory.ICreate;\n  export type Response = ICategory;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/core/categories\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/core/categories\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): ICategory =>\n    typia.random<ICategory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List and search categories (Core.categories).\n *\n * This API operation returns a list of categories, leveraging the 'categories'\n * table from the database.\n *\n * The response is paginated and may be filtered based on optional query\n * parameters such as name, partial matches in description, or created_at\n * window. Secure endpoints may restrict certain filters or result fields to\n * administrators. The main purpose is to allow users to browse or search\n * available discussion categories for post assignment or exploration.\n *\n * Security: Some filtering/search options may be restricted to users with\n * elevated roles, such as administrators or moderators. Regular users typically\n * see all active categories only.\n *\n * This endpoint is commonly used in category selection modals, administrative\n * dashboards, and on board homepages. Validation ensures page and pageSize are\n * non-negative, and sortBy field must match a valid column. Error handling will\n * return informative failures for invalid filter parameters or database\n * errors.\n *\n * This operation is related to single-category get, create, update, and delete\n * operations, and in large systems may be supplemented by category\n * suggestion/approval flows.\n *\n * @param props.body Search criteria, pagination, and sorting parameters for\n *   categories list query.\n * @path /core/categories\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /**\n     * Search criteria, pagination, and sorting parameters for categories\n     * list query.\n     */\n    body: ICategory.IRequest;\n  };\n  export type Body = ICategory.IRequest;\n  export type Response = IPageICategory;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/core/categories\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/core/categories\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPageICategory =>\n    typia.random<IPageICategory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve specific category by ID (Core.categories).\n *\n * Retrieves category information for the specified ID from the 'categories'\n * table, including name, description, creation timestamp, and potentially\n * related post count or status if extended.\n *\n * If the category does not exist, the API returns a clear error message. Access\n * policies determine visibility of archived or deactivated categories—regular\n * users can only view active categories, while admins may retrieve all states.\n *\n * This endpoint is essential for screens displaying category details prior to\n * editing/deleting, or for referencing during post creation/editing workflows.\n * Includes validation of the UUID path parameter. Returns 404 if not found or\n * permission denied.\n *\n * Related endpoints: categories list/search (PATCH), create (POST), update\n * (PUT), and delete (DELETE).\n *\n * @param props.id Unique ID of the target category\n * @path /core/categories/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Unique ID of the target category */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = ICategory;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/core/categories/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/core/categories/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): ICategory =>\n    typia.random<ICategory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a category by ID (Core.categories).\n *\n * Updates an existing category's name or description by changing the relevant\n * fields in the 'categories' table. The category is referenced by its unique\n * UUID path parameter, and the body provides updated data.\n *\n * This operation may only be performed by users with appropriate administrative\n * roles. Validation checks include verifying that the new category name does\n * not duplicate any other categories and that all required fields meet\n * formatting rules.\n *\n * Partial or full updates are supported; fields not included may retain their\n * current values. Business rules may restrict changes if the category is\n * currently associated with posts. On success, the full updated category\n * information is returned.\n *\n * Error handling includes failing if the category does not exist, trying to use\n * a duplicate name, or lacking sufficient rights. Related operations: get,\n * create, delete, and list/search categories.\n *\n * @param props.id Unique ID of the target category\n * @param props.body Updated name and/or description for the category.\n * @path /core/categories/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Unique ID of the target category */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Updated name and/or description for the category. */\n    body: ICategory.IUpdate;\n  };\n  export type Body = ICategory.IUpdate;\n  export type Response = ICategory;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/core/categories/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/core/categories/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): ICategory =>\n    typia.random<ICategory>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Delete a category by ID (Core.categories).\n *\n * Deletes (or marks as deleted) a category based on its unique ID. This\n * operation usually employs soft-deletion: the category is flagged so it no\n * longer appears in lists or selection menus, but remains in the database for\n * historical tracking and audit purposes. Some implementations may require hard\n * deletion if the category has no posts attached.\n *\n * Permission to use this operation is typically restricted to administrators.\n * Attempts to delete active categories in use by posts may be rejected or\n * require confirmation. All deletion attempts are logged for audit.\n *\n * Error cases include non-existent category ID, attempts to delete categories\n * linked to live posts, or insufficient permissions. Related endpoints: create,\n * get, update, and list/search categories.\n *\n * @param props.id Unique ID of the target category\n * @path /core/categories/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Unique ID of the target category */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = ICategory.IDeleteResult;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/core/categories/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/core/categories/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): ICategory.IDeleteResult => typia.random<ICategory.IDeleteResult>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/posts/posts/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IPost } from \"../../../structures/IPost\";\nimport { IPageIPost } from \"../../../structures/IPageIPost\";\n\n/**\n * Create a new post (Posts.posts).\n *\n * Allows a user to create a new post by providing required information such as\n * category, title, and content. The new post is assigned to the authoring user\n * and is inserted into the database. Creation may be subject to moderation or\n * review depending on platform policies.\n *\n * Input validation includes ensuring a valid category reference, unique/valid\n * title, and legitimate content (length, formatting). On success, the API\n * returns the full details of the created post, including assigned UUID,\n * timestamps, and author/category references.\n *\n * Error cases include missing/invalid data, attempts to create a post in\n * non-existent category, or by unauthorized/blocked users. Related endpoints:\n * list/search (PATCH), get (GET), update (PUT), delete (DELETE); plus comment\n * APIs.\n *\n * @param props.body All information required for new post: categoryId, title,\n *   content.\n * @path /posts/posts\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** All information required for new post: categoryId, title, content. */\n    body: IPost.ICreate;\n  };\n  export type Body = IPost.ICreate;\n  export type Response = IPost;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/posts/posts\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/posts/posts\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPost =>\n    typia.random<IPost>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List and search posts (Posts.posts).\n *\n * This API operation returns a list of posts (discussion threads or articles)\n * with full support for filtering by category, author, or keywords, as well as\n * sorting and pagination. Non-admin users typically see only non-deleted,\n * non-archived posts, while administrators may have visibility into all post\n * states. Standard search validation is performed for page, pageSize, and sort\n * field inputs.\n *\n * The endpoint supports community browsing, category threads, author-centric\n * feeds, and search result pages. It also includes support for keyword-based\n * full-text search on titles and content. Additional metadata such as comment\n * and vote counts may be included per business requirements. Error handling\n * addresses invalid filters, missing results, or backend errors.\n *\n * Related to post retrieval (GET), post creation (POST), update (PUT), and\n * delete (DELETE) endpoints, as well as comment and vote-related APIs.\n *\n * @param props.body Criteria for searching, paging, and sorting posts.\n * @path /posts/posts\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /** Criteria for searching, paging, and sorting posts. */\n    body: IPost.IRequest;\n  };\n  export type Body = IPost.IRequest;\n  export type Response = IPageIPost;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/posts/posts\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/posts/posts\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIPost =>\n    typia.random<IPageIPost>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve specific post by ID (Posts.posts).\n *\n * Retrieves full details of a single post, identified by its unique ID. Returns\n * all fields visible to the viewing user, such as title, content, author\n * reference, category reference, creation and update times, etc. Admin users\n * may access deleted posts if required, while normal users only see active\n * posts.\n *\n * This API is the primary source of detail for displaying or editing a\n * discussion post. It validates the UUID input, and returns a 404 or permission\n * error if the post does not exist or the user lacks rights.\n *\n * Related endpoints: post list/search (PATCH), create (POST), update (PUT),\n * delete (DELETE). Also supports comment and voting APIs.\n *\n * @param props.id Unique ID of the target post\n * @path /posts/posts/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Unique ID of the target post */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IPost;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/posts/posts/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/posts/posts/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPost =>\n    typia.random<IPost>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a post by ID (Posts.posts).\n *\n * Updates an existing post, referenced by its unique ID. Input may update\n * title, content, and/or category reference. Only the author or an\n * administrator/moderator may perform this operation. All updates are validated\n * for required structure, content, and permission.\n *\n * Partial updates retain other fields unchanged. History tracking is enabled\n * via timestamps. Changing category may have restrictions if the post has live\n * comments. On success, returns updated post data; on failure, returns\n * validation or permission errors.\n *\n * Related endpoints: get, list/search, create, delete for posts. This endpoint\n * supports editing discussion threads after posting.\n *\n * @param props.id Unique ID of the target post\n * @param props.body Fields to update for post (title, content, category).\n * @path /posts/posts/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Unique ID of the target post */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Fields to update for post (title, content, category). */\n    body: IPost.IUpdate;\n  };\n  export type Body = IPost.IUpdate;\n  export type Response = IPost;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/posts/posts/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/posts/posts/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPost =>\n    typia.random<IPost>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Delete a post by ID (Posts.posts).\n *\n * Deletes (or marks as deleted) a post record by its ID. Standard\n * implementation is soft-deletion: post remains in database for moderation and\n * audit but is removed from normal views and feeds. Only the original author,\n * admin, or moderator can perform deletion. Attempts to delete posts with\n * active comments or votes may be subject to business rule restrictions or\n * warnings.\n *\n * All delete actions are logged. The response provides confirmation or error.\n * Related endpoints: create, get, update, and list/search for posts. Deletion\n * cascades may apply to comments and votes as policy dictates.\n *\n * @param props.id Unique ID of the target post\n * @path /posts/posts/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Unique ID of the target post */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IPost.IDeleteResult;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/posts/posts/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/posts/posts/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPost.IDeleteResult => typia.random<IPost.IDeleteResult>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/posts/index.ts": "export * as posts from \"./posts\";\nexport * as comments from \"./comments\";\n",
      "src/api/functional/posts/comments/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IComment } from \"../../../structures/IComment\";\nimport { IPageIComment } from \"../../../structures/IPageIComment\";\n\n/**\n * Create a new comment (Posts domain, 'comments' table).\n *\n * This API lets a registered user create a new comment (either as a direct\n * reply to a post or as a nested reply to another comment). Necessary fields\n * include the content, target postId, and optionally a parentId (for\n * replies-to-replies).\n *\n * Input is validated for minimum/maximum length, appropriate content, and\n * ensuring the parent exists and belongs to the same post. The endpoint checks\n * author authentication and standard anti-abuse policies (e.g., rate limiting).\n * On success, it returns the created comment record with all metadata (author,\n * timestamp, etc.).\n *\n * Business logic from the 'comments' table (Posts domain) is implemented: only\n * registered users may comment; soft deletion rules apply. Related endpoints:\n * retrieval (GET /posts/comments/{id}), update (PUT /posts/comments/{id}), and\n * listing (PATCH /posts/comments).\n *\n * @param props.body New comment data, including content, postId, and optional\n *   parentId.\n * @path /posts/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /** New comment data, including content, postId, and optional parentId. */\n    body: IComment.ICreate;\n  };\n  export type Body = IComment.ICreate;\n  export type Response = IComment;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/posts/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/posts/comments\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IComment =>\n    typia.random<IComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve a filtered, paginated list of comments (Posts domain, 'comments'\n * table).\n *\n * This API retrieves a paged list of comments from the discussion board.\n * Typically, users or moderators use it to see all comments on a specific\n * thread, all comments by a particular user, or to moderate recent activity.\n *\n * The route supports filtering (e.g., by postId, userId, parentId), pagination\n * (offset/limit), full-text search on comment content, and sorting (e.g.,\n * newest first). Security considerations include only exposing non-deleted\n * comments by default, unless requested by a privileged moderator/admin.\n * Comment content is filtered to remove inappropriate language if the requester\n * has insufficient privileges.\n *\n * It references the 'comments' table (Posts domain). Query performance is\n * optimized via relevant indexes. Related APIs include: create (POST\n * /posts/comments), update (PUT /posts/comments/{id}), retrieve detail (GET\n * /posts/comments/{id}), and delete (DELETE /posts/comments/{id}).\n *\n * Input validation includes correct types for filters, max page size, and valid\n * sort orders. Error handling covers unauthorized access, malformed filters,\n * and nonexistent references.\n *\n * @param props.body Defines filtering, pagination, and sorting criteria for\n *   retrieving comments. Fields may include postId, userId, parentId, search,\n *   offset, limit, and sort.\n * @path /posts/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /**\n     * Defines filtering, pagination, and sorting criteria for retrieving\n     * comments. Fields may include postId, userId, parentId, search,\n     * offset, limit, and sort.\n     */\n    body: IComment.IRequest;\n  };\n  export type Body = IComment.IRequest;\n  export type Response = IPageIComment;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/posts/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/posts/comments\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIComment =>\n    typia.random<IPageIComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Fetch detailed information about a single comment (Posts domain, 'comments'\n * table).\n *\n * This API fetches the detail of a single comment in the discussion board by\n * its unique ID. Common scenarios include users viewing a nested reply,\n * moderators inspecting a reported comment, or when displaying a comment in\n * thread view.\n *\n * It returns full details such as content, author, timestamps, post reference,\n * parent comment reference, and vote tallies. The route references the\n * 'comments' table (Posts domain) and is optimized for quick retrieval. It will\n * not return comments marked as deleted unless accessed by a user with\n * sufficient privileges (e.g., moderator or admin).\n *\n * Error handling includes returning appropriate errors for nonexistent,\n * deleted, or unauthorized access. Related APIs: listing (PATCH\n * /posts/comments), update (PUT /posts/comments/{id}), creation (POST\n * /posts/comments), and deletion (DELETE /posts/comments/{id}).\n *\n * @param props.id Target comment's ID\n * @path /posts/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Target comment's ID */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IComment;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/posts/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/posts/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IComment =>\n    typia.random<IComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update an existing comment's content or deletion status (Posts domain,\n * 'comments' table).\n *\n * This API allows an authorized user (typically the comment's original author\n * or a moderator/admin) to update the content or status of a comment. Supported\n * fields for update include content (for editing), and soft deletion flag.\n *\n * Checks include author authentication, edit time-window (if enforced by\n * policy), and protection against editing after moderation/deletion. Input\n * validation ensures updated content meets platform standards, and references\n * are unaltered (cannot change post or parentId).\n *\n * The endpoint references the 'comments' table (Posts domain). On success,\n * returns the updated comment object. Error scenarios include not found,\n * unauthorized modification, or invalid updates. Related APIs: create (POST\n * /posts/comments), retrieve (GET /posts/comments/{id}), delete (DELETE\n * /posts/comments/{id}).\n *\n * @param props.id The target comment's ID to update\n * @param props.body Fields to update in the comment (content and/or soft\n *   delete).\n * @path /posts/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** The target comment's ID to update */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Fields to update in the comment (content and/or soft delete). */\n    body: IComment.IUpdate;\n  };\n  export type Body = IComment.IUpdate;\n  export type Response = IComment;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/posts/comments/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/posts/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IComment =>\n    typia.random<IComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Soft-delete a comment (Posts domain, 'comments' table).\n *\n * This API performs a soft deletion (marks as deleted) of a comment identified\n * by its ID. Typical scenarios: the comment's author chooses to remove their\n * reply, or a moderator removes content that violates policy. The comment\n * remains in the database (for auditability), but becomes invisible to regular\n * users and excluded from normal listings.\n *\n * Authorization checks enforce only the author, moderator, or admin can perform\n * this. Related error handling includes not found, already deleted, and\n * unauthorized access. Audit logs are typically recorded. Related endpoints:\n * create (POST /posts/comments), update (PUT /posts/comments/{id}), retrieve\n * (GET /posts/comments/{id}), list (PATCH /posts/comments).\n *\n * @param props.id The comment's ID to delete\n * @path /posts/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** The comment's ID to delete */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IComment.IDeleteResult;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/posts/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/posts/comments/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IComment.IDeleteResult => typia.random<IComment.IDeleteResult>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/votes/votes/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IVote } from \"../../../structures/IVote\";\nimport { IPageIVote } from \"../../../structures/IPageIVote\";\n\n/**\n * Create a new vote (Votes domain, 'votes' table).\n *\n * Lets a user cast a vote—either upvote or downvote—on a post or comment.\n * Input: must include user ID, value (+1/-1), and reference to either a post or\n * a comment (but not both). Performs validation to ensure target exists and\n * user has not already voted. On success, returns created vote record.\n *\n * Vote limit: only one vote per user per content item, enforced via unique\n * constraint. Can be used for voting analytics, user history, and tally\n * calculations. Related endpoints: retrieve (GET /votes/votes/{id}), update\n * (PUT /votes/votes/{id}), delete (DELETE /votes/votes/{id}), list (PATCH\n * /votes/votes).\n *\n * @param props.body Cast a vote on a post or comment: must include value (+1 or\n *   -1) and target (postId or commentId).\n * @path /votes/votes\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  props: post.Props,\n): Promise<post.Response> {\n  return !!connection.simulate\n    ? post.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace post {\n  export type Props = {\n    /**\n     * Cast a vote on a post or comment: must include value (+1 or -1) and\n     * target (postId or commentId).\n     */\n    body: IVote.ICreate;\n  };\n  export type Body = IVote.ICreate;\n  export type Response = IVote;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/votes/votes\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/votes/votes\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IVote =>\n    typia.random<IVote>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: post.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve a filtered, paginated list of votes (Votes domain, 'votes' table).\n *\n * This API returns a list of vote records, most commonly used for reviewing\n * moderation history, analytics, or a user's own votes. Supports filtering by\n * userId, postId, or commentId; pagination (offset/limit); sort order (most\n * recent, oldest first). Optionally, can search for patterns if metadata fields\n * exist.\n *\n * References the 'votes' table (Votes domain) and makes use of unique\n * constraints (one vote per user per item) in its filtering logic. Security\n * notes: regular users can only see their own votes, admins/moderators may\n * audit all. Related endpoints: create (POST /votes/votes), update (PUT\n * /votes/votes/{id}), detail (GET /votes/votes/{id}), delete (DELETE\n * /votes/votes/{id}).\n *\n * @param props.body Filtering, pagination, and sorting for votes list. Fields:\n *   userId, postId, commentId, offset, limit, sort.\n * @path /votes/votes\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  props: patch.Props,\n): Promise<patch.Response> {\n  return !!connection.simulate\n    ? patch.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace patch {\n  export type Props = {\n    /**\n     * Filtering, pagination, and sorting for votes list. Fields: userId,\n     * postId, commentId, offset, limit, sort.\n     */\n    body: IVote.IRequest;\n  };\n  export type Body = IVote.IRequest;\n  export type Response = IPageIVote;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/votes/votes\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/votes/votes\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IPageIVote =>\n    typia.random<IPageIVote>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: patch.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve full details for a single vote (Votes domain, 'votes' table).\n *\n * Fetches detail for a specific vote, identified by its unique ID. Useful for\n * moderation review or self-audit by a voting user. Information includes which\n * user voted, the value (+1/-1), what post/comment was targeted, and\n * timestamps.\n *\n * References the 'votes' table (Votes domain). Only visible to the vote's owner\n * or those with sufficient privilege. Error handling covers not found,\n * unauthorized access, and malformed IDs. Related endpoints: create (POST\n * /votes/votes), update (PUT /votes/votes/{id}), details (PATCH /votes/votes),\n * delete (DELETE /votes/votes/{id}).\n *\n * @param props.id Vote record's ID\n * @path /votes/votes/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  props: getById.Props,\n): Promise<getById.Response> {\n  return !!connection.simulate\n    ? getById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Props = {\n    /** Vote record's ID */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IVote;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/votes/votes/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/votes/votes/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IVote =>\n    typia.random<IVote>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: getById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Edit an existing vote's value (Votes domain, 'votes' table).\n *\n * Lets a user (or moderator/admin) edit an existing vote—typically to change\n * their upvote to downvote or vice versa, or to correct an input error. Only\n * the vote's owner or privileged users may edit. Only value can change; postId\n * or commentId are immutable.\n *\n * Business logic is enforced as per the 'votes' table (Votes domain): only one\n * vote per user/content, mutual exclusivity between postId/commentId, and all\n * references must remain valid. Returns the updated vote on success. Related\n * endpoints: create (POST /votes/votes), retrieve (GET /votes/votes/{id}), list\n * (PATCH /votes/votes), delete (DELETE /votes/votes/{id}).\n *\n * @param props.id Vote record's ID to update\n * @param props.body Fields to update in the vote (only value may be changed).\n * @path /votes/votes/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  props: putById.Props,\n): Promise<putById.Response> {\n  return !!connection.simulate\n    ? putById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(props),\n          status: null,\n        },\n        props.body,\n      );\n}\nexport namespace putById {\n  export type Props = {\n    /** Vote record's ID to update */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Fields to update in the vote (only value may be changed). */\n    body: IVote.IUpdate;\n  };\n  export type Body = IVote.IUpdate;\n  export type Response = IVote;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/votes/votes/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Omit<Props, \"body\">) =>\n    `/votes/votes/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IVote =>\n    typia.random<IVote>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: putById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n      assert.body(() => typia.assert(props.body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Delete a vote record from the database (Votes domain, 'votes' table).\n *\n * This endpoint removes a specific vote by its ID. Common use-cases: a user\n * withdraws their vote or a moderator/admin removes a vote for violating\n * policy. The vote is deleted from the database (hard delete), and any relevant\n * tally is decremented.\n *\n * Authorization checks ensure only the vote's owner or privileged roles may\n * perform deletion. Related endpoints: create (POST /votes/votes), update (PUT\n * /votes/votes/{id}), retrieve (GET /votes/votes/{id}), list (PATCH\n * /votes/votes). Audit logging may be triggered for moderation actions.\n *\n * @param props.id Vote record's ID to delete\n * @path /votes/votes/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  props: eraseById.Props,\n): Promise<eraseById.Response> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, props)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(props),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Props = {\n    /** Vote record's ID to delete */\n    id: string & tags.Format<\"uuid\">;\n  };\n  export type Response = IVote.IDeleteResult;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/votes/votes/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (props: Props) =>\n    `/votes/votes/${encodeURIComponent(props.id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IVote.IDeleteResult => typia.random<IVote.IDeleteResult>(g);\n  export const simulate = (\n    connection: IConnection,\n    props: eraseById.Props,\n  ): Response => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(props),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(props.id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/votes/index.ts": "export * as votes from \"./votes\";\n",
      "test/features/api/test_api_core_users_post.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\n\nexport async function test_api_core_users_post(connection: api.IConnection) {\n  const output: IUser = await api.functional.core.users.post(connection, {\n    body: typia.random<IUser.ICreate>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_core_users_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageIUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUser\";\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\n\nexport async function test_api_core_users_patch(connection: api.IConnection) {\n  const output: IPageIUser.ISummary = await api.functional.core.users.patch(\n    connection,\n    {\n      body: typia.random<IUser.IRequest>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_core_users_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\n\nexport async function test_api_core_users_getById(connection: api.IConnection) {\n  const output: IUser = await api.functional.core.users.getById(connection, {\n    id: typia.random<string & tags.Format<\"uuid\">>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_core_users_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\n\nexport async function test_api_core_users_putById(connection: api.IConnection) {\n  const output: IUser = await api.functional.core.users.putById(connection, {\n    id: typia.random<string & tags.Format<\"uuid\">>(),\n    body: typia.random<IUser.IUpdate>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_core_users_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUser\";\n\nexport async function test_api_core_users_eraseById(\n  connection: api.IConnection,\n) {\n  const output: IUser.IDeleteResponse =\n    await api.functional.core.users.eraseById(connection, {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_core_userRoles_post.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\nexport async function test_api_core_userRoles_post(\n  connection: api.IConnection,\n) {\n  const output: IUserRole = await api.functional.core.userRoles.post(\n    connection,\n    {\n      body: typia.random<IUserRole.ICreate>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_core_userRoles_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageIUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIUserRole\";\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\nexport async function test_api_core_userRoles_patch(\n  connection: api.IConnection,\n) {\n  const output: IPageIUserRole = await api.functional.core.userRoles.patch(\n    connection,\n    {\n      body: typia.random<IUserRole.IRequest>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_core_userRoles_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\nexport async function test_api_core_userRoles_getById(\n  connection: api.IConnection,\n) {\n  const output: IUserRole = await api.functional.core.userRoles.getById(\n    connection,\n    {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_core_userRoles_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\nexport async function test_api_core_userRoles_putById(\n  connection: api.IConnection,\n) {\n  const output: IUserRole = await api.functional.core.userRoles.putById(\n    connection,\n    {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n      body: typia.random<IUserRole.IUpdate>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_core_userRoles_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IUserRole } from \"@ORGANIZATION/PROJECT-api/lib/structures/IUserRole\";\n\nexport async function test_api_core_userRoles_eraseById(\n  connection: api.IConnection,\n) {\n  const output: IUserRole.IDeleteResponse =\n    await api.functional.core.userRoles.eraseById(connection, {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_core_categories_post.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_api_core_categories_post(\n  connection: api.IConnection,\n) {\n  const output: ICategory = await api.functional.core.categories.post(\n    connection,\n    {\n      body: typia.random<ICategory.ICreate>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_core_categories_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageICategory\";\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_api_core_categories_patch(\n  connection: api.IConnection,\n) {\n  const output: IPageICategory = await api.functional.core.categories.patch(\n    connection,\n    {\n      body: typia.random<ICategory.IRequest>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_core_categories_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_api_core_categories_getById(\n  connection: api.IConnection,\n) {\n  const output: ICategory = await api.functional.core.categories.getById(\n    connection,\n    {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_core_categories_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_api_core_categories_putById(\n  connection: api.IConnection,\n) {\n  const output: ICategory = await api.functional.core.categories.putById(\n    connection,\n    {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n      body: typia.random<ICategory.IUpdate>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_core_categories_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { ICategory } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICategory\";\n\nexport async function test_api_core_categories_eraseById(\n  connection: api.IConnection,\n) {\n  const output: ICategory.IDeleteResult =\n    await api.functional.core.categories.eraseById(connection, {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_posts_posts_post.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\nexport async function test_api_posts_posts_post(connection: api.IConnection) {\n  const output: IPost = await api.functional.posts.posts.post(connection, {\n    body: typia.random<IPost.ICreate>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_posts_posts_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageIPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIPost\";\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\nexport async function test_api_posts_posts_patch(connection: api.IConnection) {\n  const output: IPageIPost = await api.functional.posts.posts.patch(\n    connection,\n    {\n      body: typia.random<IPost.IRequest>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_posts_posts_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\nexport async function test_api_posts_posts_getById(\n  connection: api.IConnection,\n) {\n  const output: IPost = await api.functional.posts.posts.getById(connection, {\n    id: typia.random<string & tags.Format<\"uuid\">>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_posts_posts_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\nexport async function test_api_posts_posts_putById(\n  connection: api.IConnection,\n) {\n  const output: IPost = await api.functional.posts.posts.putById(connection, {\n    id: typia.random<string & tags.Format<\"uuid\">>(),\n    body: typia.random<IPost.IUpdate>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_posts_posts_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IPost } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPost\";\n\nexport async function test_api_posts_posts_eraseById(\n  connection: api.IConnection,\n) {\n  const output: IPost.IDeleteResult =\n    await api.functional.posts.posts.eraseById(connection, {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_posts_comments_post.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\nexport async function test_api_posts_comments_post(\n  connection: api.IConnection,\n) {\n  const output: IComment = await api.functional.posts.comments.post(\n    connection,\n    {\n      body: typia.random<IComment.ICreate>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_posts_comments_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageIComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIComment\";\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\nexport async function test_api_posts_comments_patch(\n  connection: api.IConnection,\n) {\n  const output: IPageIComment = await api.functional.posts.comments.patch(\n    connection,\n    {\n      body: typia.random<IComment.IRequest>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_posts_comments_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\nexport async function test_api_posts_comments_getById(\n  connection: api.IConnection,\n) {\n  const output: IComment = await api.functional.posts.comments.getById(\n    connection,\n    {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_posts_comments_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\nexport async function test_api_posts_comments_putById(\n  connection: api.IConnection,\n) {\n  const output: IComment = await api.functional.posts.comments.putById(\n    connection,\n    {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n      body: typia.random<IComment.IUpdate>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_posts_comments_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IComment\";\n\nexport async function test_api_posts_comments_eraseById(\n  connection: api.IConnection,\n) {\n  const output: IComment.IDeleteResult =\n    await api.functional.posts.comments.eraseById(connection, {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_votes_votes_post.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\nexport async function test_api_votes_votes_post(connection: api.IConnection) {\n  const output: IVote = await api.functional.votes.votes.post(connection, {\n    body: typia.random<IVote.ICreate>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_votes_votes_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageIVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIVote\";\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\nexport async function test_api_votes_votes_patch(connection: api.IConnection) {\n  const output: IPageIVote = await api.functional.votes.votes.patch(\n    connection,\n    {\n      body: typia.random<IVote.IRequest>(),\n    },\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_votes_votes_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\nexport async function test_api_votes_votes_getById(\n  connection: api.IConnection,\n) {\n  const output: IVote = await api.functional.votes.votes.getById(connection, {\n    id: typia.random<string & tags.Format<\"uuid\">>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_votes_votes_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\nexport async function test_api_votes_votes_putById(\n  connection: api.IConnection,\n) {\n  const output: IVote = await api.functional.votes.votes.putById(connection, {\n    id: typia.random<string & tags.Format<\"uuid\">>(),\n    body: typia.random<IVote.IUpdate>(),\n  });\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_votes_votes_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IVote } from \"@ORGANIZATION/PROJECT-api/lib/structures/IVote\";\n\nexport async function test_api_votes_votes_eraseById(\n  connection: api.IConnection,\n) {\n  const output: IVote.IDeleteResult =\n    await api.functional.votes.votes.eraseById(connection, {\n      id: typia.random<string & tags.Format<\"uuid\">>(),\n    });\n  typia.assert(output);\n}\n",
      "packages/api/swagger.json": "{\n  \"openapi\": \"3.1.0\",\n  \"paths\": {\n    \"/core/users\": {\n      \"patch\": {\n        \"summary\": \"Retrieve a paginated, filterable list of users (core.users table).\",\n        \"description\": \"This operation returns a paginated and filtered list of users registered on the discussion board. Users may be searched by username, email, user role, or status, and results are sorted and paginated according to the provided parameters. The endpoint refers to the users table, whose structure includes fields for username, email, bio, role reference, password hash, timestamps, and status. Filters can help administrators or moderators locate specific accounts, monitor new signups, or audit activity. Security is enforced: only users with moderator or administrator roles can access or use advanced filters.\\n\\nThe endpoint applies business rules from the requirements, such as hiding sensitive (e.g., password) information, and supports relations to user_roles for displaying or filtering by user type. Pagination and sorting follow best practices for usability and performance. Related endpoints: create (POST), retrieve detail (GET), update (PUT), and delete (DELETE) for users.\\n\\nError handling ensures invalid queries, unauthorized access, or database issues are managed gracefully, returning clear status codes and messages. Sensitive data, such as password hashes, is never included in responses.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IUser.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Filtering, sorting, and pagination info for user listing request.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIUser.ISummary\"\n                }\n              }\n            },\n            \"description\": \"A paginated set of user summaries matching the search conditions, with profile and role info (never includes sensitive authentication fields).\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Register a new user (core.users table).\",\n        \"description\": \"This operation handles new user registration or administrator-created user accounts. It accepts all required and optional fields per the users model: username, email, bio (optional), status, and an associated user_role_id. Passwords are securely hashed before saving, never stored in plain text.\\n\\nUnique constraints are enforced for both username and email to prevent duplicates. The user role must point to an existing role defined in user_roles. Timestamps for creation and update are handled automatically. Successful creation returns the newly registered user's public profile and role association (never the password hash).\\n\\nSecurity and validation reflect business rules, e.g., email visibility, profile privacy, and initial status setting. Input errors or duplicates return clear messages and codes. Related endpoints: list (PATCH), read (GET), update (PUT), delete (DELETE).\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IUser.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Registration info for the new user, including username, email, password, user role, etc.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUser\"\n                }\n              }\n            },\n            \"description\": \"Full profile of the newly created user, including assigned role, minus authentication secrets.\"\n          }\n        }\n      }\n    },\n    \"/core/users/{id}\": {\n      \"get\": {\n        \"summary\": \"Retrieve detailed profile info for a specific user (core.users table).\",\n        \"description\": \"This operation retrieves the full profile and related information for a specific user, identified by their unique user ID. Fields returned follow the schema comments: username, email, bio, status, timestamps, and a reference to their user role. User roles are resolved to human-readable labels where appropriate.\\n\\nSensitive fields such as password_hash are never returned. This endpoint is typically used by administrators for user management, or by users to view their own account details. Where authorized, moderators may use this endpoint for resolving moderation cases or audits. The data aligns exactly with the users table comments and model.\\n\\nRelated endpoints include listing (PATCH), creation (POST), update (PUT), and deletion (DELETE) for users. Error handling covers not found, unauthorized, or forbidden cases, always giving appropriate error codes and minimal leak of protected info.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target user's ID (UUID).\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUser\"\n                }\n              }\n            },\n            \"description\": \"Full user profile detail with relevant account and role information, excluding authentication secrets.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update user profile and account fields (core.users table).\",\n        \"description\": \"Updates an existing user's information, addressing fields in the users schema, such as username, email, bio, role, status, and update timestamp. The input must include the user ID and only permitted fields are updateable. Username/email uniqueness is enforced on update as well. Moderators/administrators can change roles/statuses as permitted by business rules.\\n\\nThe request never allows direct password updates (managed by a separate dedicated endpoint, or by password reset process for security). All change history is reflected in the updated_at timestamp. Security measures prevent users from editing others' profiles unless authorized; self-edits are limited to certain fields.\\n\\nRelated endpoints: detail (GET), list (PATCH), create (POST), delete (DELETE). Strict validation and business rule application ensure stability and data quality.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target user's ID (UUID).\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IUser.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Editable fields for user update, such as profile details or status/role changes (excludes password updates).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUser\"\n                }\n              }\n            },\n            \"description\": \"Full, updated user profile after modifications, including associated role info.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Softly or fully delete a user (core.users table).\",\n        \"description\": \"Deletes a user account with the specified ID. This typically marks the user's status as deleted or suspended and/or sets a deletion flag in audit fields, per the users Prisma schema and moderation rules. Associated content (posts, comments, votes) may be retained for community reference, moderation, or audit logs, as described in requirements.\\n\\nOnly administrators may perform this action, and a detailed audit trail is kept. Related endpoints are used for restoration or final hard-delete (if policy allows). Errors for not found or forbidden actions are handled appropriately; sensitive information on deleted users is not exposed.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target user's ID (UUID).\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUser.IDeleteResponse\"\n                }\n              }\n            },\n            \"description\": \"Confirmation of successful deletion or status update, with minimal identifying info.\"\n          }\n        }\n      }\n    },\n    \"/core/userRoles\": {\n      \"patch\": {\n        \"summary\": \"List and filter user roles (core.userRoles table).\",\n        \"description\": \"This operation returns a paginated list of user roles available to assign, as defined by the user_roles model. Roles govern permissions across the board (e.g., member, moderator, administrator). Designed for use in registration processes, admin dashboards, or role management panels, enabling filtering by role name or description and ordering of results.\\n\\nData returned is defined strictly by the Prisma model and schema comments. This operation is auditable and respects business constraints on who may view/assign roles. Related endpoints: single role GET, create (POST), update (PUT), and delete (DELETE).\\n\\nError cases (e.g., forbidden access) are handled with appropriate status codes. Pagination and search parameters maximize usability and efficiency, especially for large deployments with custom roles.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IUserRole.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Filter, search, and pagination info for user roles listing.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIUserRole\"\n                }\n              }\n            },\n            \"description\": \"A paginated list of available user roles with label and description.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new user role (core.userRoles table).\",\n        \"description\": \"Creates a new user role based on the schema structure, with fields for name (label) and description. Enforces the uniqueness of the role name and ensures all required information is provided, following the comments and requirements detailed in the Prisma schema.\\n\\nIntended for administrator setup or customization of new permission levels. Errors are sent in case of duplicate names, missing fields, or insufficient permissions. Successful creation returns the new user role record, suitable for immediate assignment to users.\\n\\nRelated endpoints: list (PATCH), single GET, update (PUT), and delete (DELETE) for user roles.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IUserRole.ICreate\"\n              }\n            }\n          },\n          \"description\": \"New user role details, including name and description.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUserRole\"\n                }\n              }\n            },\n            \"description\": \"Details for the created user role, ready for assignment to users.\"\n          }\n        }\n      }\n    },\n    \"/core/userRoles/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a single user role's details (core.userRoles table).\",\n        \"description\": \"Retrieves all details for a single user role, specified by ID. Used in admin panels to display all properties of a role, or in account registration to inform users about the meaning and permissions of each role (as described in schema comments: name, description, etc).\\n\\nRespects all business rules regarding role assignment and application. Related endpoints: list (PATCH), creation (POST), update (PUT), delete (DELETE). Errors for missing roles or unauthorized actions are handled gracefully, with clear messaging.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target role's ID (UUID).\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUserRole\"\n                }\n              }\n            },\n            \"description\": \"Details about the specified user role, including label and full description.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Edit label/description for a user role (core.userRoles table).\",\n        \"description\": \"Updates an existing user role's properties (name and/or description). Uniqueness of the name is enforced by Prisma schema rules. Typical in systems where additional roles/policies are introduced or for correcting role definitions.\\n\\nOnly administrators are permitted to update roles. Change history is tracked and any update is reflected in audit fields. Related endpoints: detail GET, list PATCH, creation POST, and deletion DELETE for user roles.\\n\\nAny errors due to duplicates, forbidden edits, or missing records generate suitable error codes in response. Endpoint matches structure and intentions described in requirements and schema comments.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target role's ID (UUID).\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IUserRole.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"New values for user role fields (name/description).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUserRole\"\n                }\n              }\n            },\n            \"description\": \"Updated role details after successful edit.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Delete a user role from the system (core.userRoles table).\",\n        \"description\": \"Deletes a user role identified by its ID. Enforces business and schema rules about which roles can be deleted (e.g., prevents deletion of critical roles if protected by business logic). If the role is in use (referenced by users), operation will fail with a clear error message.\\n\\nAdministrative rights are required. Detailed audit trails are maintained for changes. Related endpoints: create (POST), list (PATCH), update (PUT), detail (GET). All operations match Prisma schema and requirements. Appropriate handling is provided for not found, forbidden, or dependency errors.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target role's ID (UUID).\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IUserRole.IDeleteResponse\"\n                }\n              }\n            },\n            \"description\": \"Confirmation of role deletion or status update; references deleted role.\"\n          }\n        }\n      }\n    },\n    \"/core/categories\": {\n      \"patch\": {\n        \"summary\": \"List and search categories (Core.categories)\",\n        \"description\": \"This API operation returns a list of categories, leveraging the 'categories' table from the database. \\n\\nThe response is paginated and may be filtered based on optional query parameters such as name, partial matches in description, or created_at window. Secure endpoints may restrict certain filters or result fields to administrators. The main purpose is to allow users to browse or search available discussion categories for post assignment or exploration. \\n\\nSecurity: Some filtering/search options may be restricted to users with elevated roles, such as administrators or moderators. Regular users typically see all active categories only. \\n\\nThis endpoint is commonly used in category selection modals, administrative dashboards, and on board homepages. Validation ensures page and pageSize are non-negative, and sortBy field must match a valid column. Error handling will return informative failures for invalid filter parameters or database errors.\\n\\nThis operation is related to single-category get, create, update, and delete operations, and in large systems may be supplemented by category suggestion/approval flows.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/ICategory.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Search criteria, pagination, and sorting parameters for categories list query.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageICategory\"\n                }\n              }\n            },\n            \"description\": \"Paginated result including array of category summaries and pagination metadata.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create new category (Core.categories)\",\n        \"description\": \"Allows creation of a new category topic for the discussion board, by inserting a new record into the 'categories' table in the database. The provided name must be unique among all categories. Description field gives users context. Only authorized users (administrators) are permitted to execute this operation.\\n\\nInput validation includes ensuring that required fields are present, name does not duplicate existing entries, and description respects length/content rules. On success, the new category is created and returned with full detail including its assigned UUID and creation timestamp.\\n\\nError handling covers invalid parameters, uniqueness violations, or insufficient permissions. \\n\\nRelated endpoints: list/search (PATCH), get (GET), update (PUT), and delete (DELETE) for categories.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/ICategory.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Data for new category including unique name and description.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/ICategory\"\n                }\n              }\n            },\n            \"description\": \"The newly created category with full details.\"\n          }\n        }\n      }\n    },\n    \"/core/categories/{id}\": {\n      \"get\": {\n        \"summary\": \"Retrieve specific category by ID (Core.categories)\",\n        \"description\": \"Retrieves category information for the specified ID from the 'categories' table, including name, description, creation timestamp, and potentially related post count or status if extended.\\n\\nIf the category does not exist, the API returns a clear error message. Access policies determine visibility of archived or deactivated categories—regular users can only view active categories, while admins may retrieve all states.\\n\\nThis endpoint is essential for screens displaying category details prior to editing/deleting, or for referencing during post creation/editing workflows. Includes validation of the UUID path parameter. Returns 404 if not found or permission denied.\\n\\nRelated endpoints: categories list/search (PATCH), create (POST), update (PUT), and delete (DELETE).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Unique ID of the target category\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/ICategory\"\n                }\n              }\n            },\n            \"description\": \"Full detail of the specified category, including all public fields.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a category by ID (Core.categories)\",\n        \"description\": \"Updates an existing category's name or description by changing the relevant fields in the 'categories' table. The category is referenced by its unique UUID path parameter, and the body provides updated data.\\n\\nThis operation may only be performed by users with appropriate administrative roles. Validation checks include verifying that the new category name does not duplicate any other categories and that all required fields meet formatting rules.\\n\\nPartial or full updates are supported; fields not included may retain their current values. Business rules may restrict changes if the category is currently associated with posts. On success, the full updated category information is returned.\\n\\nError handling includes failing if the category does not exist, trying to use a duplicate name, or lacking sufficient rights. Related operations: get, create, delete, and list/search categories.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Unique ID of the target category\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/ICategory.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Updated name and/or description for the category.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/ICategory\"\n                }\n              }\n            },\n            \"description\": \"The updated category details after saving changes.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Delete a category by ID (Core.categories)\",\n        \"description\": \"Deletes (or marks as deleted) a category based on its unique ID. This operation usually employs soft-deletion: the category is flagged so it no longer appears in lists or selection menus, but remains in the database for historical tracking and audit purposes. Some implementations may require hard deletion if the category has no posts attached.\\n\\nPermission to use this operation is typically restricted to administrators. Attempts to delete active categories in use by posts may be rejected or require confirmation. All deletion attempts are logged for audit.\\n\\nError cases include non-existent category ID, attempts to delete categories linked to live posts, or insufficient permissions. Related endpoints: create, get, update, and list/search categories.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Unique ID of the target category\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/ICategory.IDeleteResult\"\n                }\n              }\n            },\n            \"description\": \"Result of the delete operation, such as a confirmation message or status object.\"\n          }\n        }\n      }\n    },\n    \"/posts/posts\": {\n      \"patch\": {\n        \"summary\": \"List and search posts (Posts.posts)\",\n        \"description\": \"This API operation returns a list of posts (discussion threads or articles) with full support for filtering by category, author, or keywords, as well as sorting and pagination. Non-admin users typically see only non-deleted, non-archived posts, while administrators may have visibility into all post states. Standard search validation is performed for page, pageSize, and sort field inputs.\\n\\nThe endpoint supports community browsing, category threads, author-centric feeds, and search result pages. It also includes support for keyword-based full-text search on titles and content. Additional metadata such as comment and vote counts may be included per business requirements. Error handling addresses invalid filters, missing results, or backend errors.\\n\\nRelated to post retrieval (GET), post creation (POST), update (PUT), and delete (DELETE) endpoints, as well as comment and vote-related APIs.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IPost.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Criteria for searching, paging, and sorting posts.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIPost\"\n                }\n              }\n            },\n            \"description\": \"Paginated result of posts with summary data, and metadata for pagination.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new post (Posts.posts)\",\n        \"description\": \"Allows a user to create a new post by providing required information such as category, title, and content. The new post is assigned to the authoring user and is inserted into the database. Creation may be subject to moderation or review depending on platform policies.\\n\\nInput validation includes ensuring a valid category reference, unique/valid title, and legitimate content (length, formatting). On success, the API returns the full details of the created post, including assigned UUID, timestamps, and author/category references.\\n\\nError cases include missing/invalid data, attempts to create a post in non-existent category, or by unauthorized/blocked users. Related endpoints: list/search (PATCH), get (GET), update (PUT), delete (DELETE); plus comment APIs.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IPost.ICreate\"\n              }\n            }\n          },\n          \"description\": \"All information required for new post: categoryId, title, content.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPost\"\n                }\n              }\n            },\n            \"description\": \"Full detail for the newly created post, including IDs and timestamps.\"\n          }\n        }\n      }\n    },\n    \"/posts/posts/{id}\": {\n      \"get\": {\n        \"summary\": \"Retrieve specific post by ID (Posts.posts)\",\n        \"description\": \"Retrieves full details of a single post, identified by its unique ID. Returns all fields visible to the viewing user, such as title, content, author reference, category reference, creation and update times, etc. Admin users may access deleted posts if required, while normal users only see active posts.\\n\\nThis API is the primary source of detail for displaying or editing a discussion post. It validates the UUID input, and returns a 404 or permission error if the post does not exist or the user lacks rights.\\n\\nRelated endpoints: post list/search (PATCH), create (POST), update (PUT), delete (DELETE). Also supports comment and voting APIs.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Unique ID of the target post\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPost\"\n                }\n              }\n            },\n            \"description\": \"All detail fields of the requested post, as permitted by current user role.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a post by ID (Posts.posts)\",\n        \"description\": \"Updates an existing post, referenced by its unique ID. Input may update title, content, and/or category reference. Only the author or an administrator/moderator may perform this operation. All updates are validated for required structure, content, and permission.\\n\\nPartial updates retain other fields unchanged. History tracking is enabled via timestamps. Changing category may have restrictions if the post has live comments. On success, returns updated post data; on failure, returns validation or permission errors.\\n\\nRelated endpoints: get, list/search, create, delete for posts. This endpoint supports editing discussion threads after posting.\\n\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Unique ID of the target post\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IPost.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Fields to update for post (title, content, category).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPost\"\n                }\n              }\n            },\n            \"description\": \"The updated post's full details after saving changes.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Delete a post by ID (Posts.posts)\",\n        \"description\": \"Deletes (or marks as deleted) a post record by its ID. Standard implementation is soft-deletion: post remains in database for moderation and audit but is removed from normal views and feeds. Only the original author, admin, or moderator can perform deletion. Attempts to delete posts with active comments or votes may be subject to business rule restrictions or warnings.\\n\\nAll delete actions are logged. The response provides confirmation or error. Related endpoints: create, get, update, and list/search for posts. Deletion cascades may apply to comments and votes as policy dictates.\\n\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Unique ID of the target post\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPost.IDeleteResult\"\n                }\n              }\n            },\n            \"description\": \"Result or confirmation of post deletion (success, message, etc.)\"\n          }\n        }\n      }\n    },\n    \"/posts/comments\": {\n      \"patch\": {\n        \"summary\": \"Retrieve a filtered, paginated list of comments (Posts domain, 'comments' table).\",\n        \"description\": \"This API retrieves a paged list of comments from the discussion board. Typically, users or moderators use it to see all comments on a specific thread, all comments by a particular user, or to moderate recent activity.\\n\\nThe route supports filtering (e.g., by postId, userId, parentId), pagination (offset/limit), full-text search on comment content, and sorting (e.g., newest first). Security considerations include only exposing non-deleted comments by default, unless requested by a privileged moderator/admin. Comment content is filtered to remove inappropriate language if the requester has insufficient privileges.\\n\\nIt references the 'comments' table (Posts domain). Query performance is optimized via relevant indexes. Related APIs include: create (POST /posts/comments), update (PUT /posts/comments/{id}), retrieve detail (GET /posts/comments/{id}), and delete (DELETE /posts/comments/{id}).\\n\\nInput validation includes correct types for filters, max page size, and valid sort orders. Error handling covers unauthorized access, malformed filters, and nonexistent references.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IComment.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Defines filtering, pagination, and sorting criteria for retrieving comments. Fields may include postId, userId, parentId, search, offset, limit, and sort.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIComment\"\n                }\n              }\n            },\n            \"description\": \"Paged list of comments matching given filters.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new comment (Posts domain, 'comments' table).\",\n        \"description\": \"This API lets a registered user create a new comment (either as a direct reply to a post or as a nested reply to another comment). Necessary fields include the content, target postId, and optionally a parentId (for replies-to-replies).\\n\\nInput is validated for minimum/maximum length, appropriate content, and ensuring the parent exists and belongs to the same post. The endpoint checks author authentication and standard anti-abuse policies (e.g., rate limiting). On success, it returns the created comment record with all metadata (author, timestamp, etc.).\\n\\nBusiness logic from the 'comments' table (Posts domain) is implemented: only registered users may comment; soft deletion rules apply. Related endpoints: retrieval (GET /posts/comments/{id}), update (PUT /posts/comments/{id}), and listing (PATCH /posts/comments).\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"New comment data, including content, postId, and optional parentId.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IComment\"\n                }\n              }\n            },\n            \"description\": \"The newly created comment record, with full metadata.\"\n          }\n        }\n      }\n    },\n    \"/posts/comments/{id}\": {\n      \"get\": {\n        \"summary\": \"Fetch detailed information about a single comment (Posts domain, 'comments' table).\",\n        \"description\": \"This API fetches the detail of a single comment in the discussion board by its unique ID. Common scenarios include users viewing a nested reply, moderators inspecting a reported comment, or when displaying a comment in thread view.\\n\\nIt returns full details such as content, author, timestamps, post reference, parent comment reference, and vote tallies. The route references the 'comments' table (Posts domain) and is optimized for quick retrieval. It will not return comments marked as deleted unless accessed by a user with sufficient privileges (e.g., moderator or admin).\\n\\nError handling includes returning appropriate errors for nonexistent, deleted, or unauthorized access. Related APIs: listing (PATCH /posts/comments), update (PUT /posts/comments/{id}), creation (POST /posts/comments), and deletion (DELETE /posts/comments/{id}).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment's ID\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IComment\"\n                }\n              }\n            },\n            \"description\": \"Full comment info, including content, author, timestamps, post and parent references.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update an existing comment's content or deletion status (Posts domain, 'comments' table).\",\n        \"description\": \"This API allows an authorized user (typically the comment's original author or a moderator/admin) to update the content or status of a comment. Supported fields for update include content (for editing), and soft deletion flag.\\n\\nChecks include author authentication, edit time-window (if enforced by policy), and protection against editing after moderation/deletion. Input validation ensures updated content meets platform standards, and references are unaltered (cannot change post or parentId).\\n\\nThe endpoint references the 'comments' table (Posts domain). On success, returns the updated comment object. Error scenarios include not found, unauthorized modification, or invalid updates. Related APIs: create (POST /posts/comments), retrieve (GET /posts/comments/{id}), delete (DELETE /posts/comments/{id}).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The target comment's ID to update\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IComment.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Fields to update in the comment (content and/or soft delete).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IComment\"\n                }\n              }\n            },\n            \"description\": \"The updated comment record.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Soft-delete a comment (Posts domain, 'comments' table).\",\n        \"description\": \"This API performs a soft deletion (marks as deleted) of a comment identified by its ID. Typical scenarios: the comment's author chooses to remove their reply, or a moderator removes content that violates policy. The comment remains in the database (for auditability), but becomes invisible to regular users and excluded from normal listings.\\n\\nAuthorization checks enforce only the author, moderator, or admin can perform this. Related error handling includes not found, already deleted, and unauthorized access. Audit logs are typically recorded. Related endpoints: create (POST /posts/comments), update (PUT /posts/comments/{id}), retrieve (GET /posts/comments/{id}), list (PATCH /posts/comments).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The comment's ID to delete\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IComment.IDeleteResult\"\n                }\n              }\n            },\n            \"description\": \"Indicates successful deletion or details if already deleted.\"\n          }\n        }\n      }\n    },\n    \"/votes/votes\": {\n      \"patch\": {\n        \"summary\": \"Retrieve a filtered, paginated list of votes (Votes domain, 'votes' table).\",\n        \"description\": \"This API returns a list of vote records, most commonly used for reviewing moderation history, analytics, or a user's own votes. Supports filtering by userId, postId, or commentId; pagination (offset/limit); sort order (most recent, oldest first). Optionally, can search for patterns if metadata fields exist.\\n\\nReferences the 'votes' table (Votes domain) and makes use of unique constraints (one vote per user per item) in its filtering logic. Security notes: regular users can only see their own votes, admins/moderators may audit all. Related endpoints: create (POST /votes/votes), update (PUT /votes/votes/{id}), detail (GET /votes/votes/{id}), delete (DELETE /votes/votes/{id}).\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IVote.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Filtering, pagination, and sorting for votes list. Fields: userId, postId, commentId, offset, limit, sort.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIVote\"\n                }\n              }\n            },\n            \"description\": \"Paged list of vote records matching given filters.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new vote (Votes domain, 'votes' table).\",\n        \"description\": \"Lets a user cast a vote—either upvote or downvote—on a post or comment. Input: must include user ID, value (+1/-1), and reference to either a post or a comment (but not both). Performs validation to ensure target exists and user has not already voted. On success, returns created vote record.\\n\\nVote limit: only one vote per user per content item, enforced via unique constraint. Can be used for voting analytics, user history, and tally calculations. Related endpoints: retrieve (GET /votes/votes/{id}), update (PUT /votes/votes/{id}), delete (DELETE /votes/votes/{id}), list (PATCH /votes/votes).\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IVote.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Cast a vote on a post or comment: must include value (+1 or -1) and target (postId or commentId).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IVote\"\n                }\n              }\n            },\n            \"description\": \"The newly created vote record.\"\n          }\n        }\n      }\n    },\n    \"/votes/votes/{id}\": {\n      \"get\": {\n        \"summary\": \"Retrieve full details for a single vote (Votes domain, 'votes' table).\",\n        \"description\": \"Fetches detail for a specific vote, identified by its unique ID. Useful for moderation review or self-audit by a voting user. Information includes which user voted, the value (+1/-1), what post/comment was targeted, and timestamps.\\n\\nReferences the 'votes' table (Votes domain). Only visible to the vote's owner or those with sufficient privilege. Error handling covers not found, unauthorized access, and malformed IDs. Related endpoints: create (POST /votes/votes), update (PUT /votes/votes/{id}), details (PATCH /votes/votes), delete (DELETE /votes/votes/{id}).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Vote record's ID\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IVote\"\n                }\n              }\n            },\n            \"description\": \"Full vote record, including user, content, and metadata.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Edit an existing vote's value (Votes domain, 'votes' table).\",\n        \"description\": \"Lets a user (or moderator/admin) edit an existing vote—typically to change their upvote to downvote or vice versa, or to correct an input error. Only the vote's owner or privileged users may edit. Only value can change; postId or commentId are immutable.\\n\\nBusiness logic is enforced as per the 'votes' table (Votes domain): only one vote per user/content, mutual exclusivity between postId/commentId, and all references must remain valid. Returns the updated vote on success. Related endpoints: create (POST /votes/votes), retrieve (GET /votes/votes/{id}), list (PATCH /votes/votes), delete (DELETE /votes/votes/{id}).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Vote record's ID to update\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IVote.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Fields to update in the vote (only value may be changed).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IVote\"\n                }\n              }\n            },\n            \"description\": \"The updated vote record.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Delete a vote record from the database (Votes domain, 'votes' table).\",\n        \"description\": \"This endpoint removes a specific vote by its ID. Common use-cases: a user withdraws their vote or a moderator/admin removes a vote for violating policy. The vote is deleted from the database (hard delete), and any relevant tally is decremented.\\n\\nAuthorization checks ensure only the vote's owner or privileged roles may perform deletion. Related endpoints: create (POST /votes/votes), update (PUT /votes/votes/{id}), retrieve (GET /votes/votes/{id}), list (PATCH /votes/votes). Audit logging may be triggered for moderation actions.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Vote record's ID to delete\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IVote.IDeleteResult\"\n                }\n              }\n            },\n            \"description\": \"Indicates success or provides result details of the delete action.\"\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"IPost.ISummary\": {\n        \"type\": \"object\",\n        \"description\": \"게시글(포스트)의 요약 정보를 제공하는 타입입니다. 목록 조회, 관계 프로퍼티 등에서 사용됩니다.\\n\\n게시글의 고유 ID, 제목, 작성자 ID, 카테고리 ID, 생성일, 수정일, 댓글/추천 등 카운트 필수 정보를 담고 있어, 리스트 UI 테이블/카드 등 요약 리스트용으로 활용합니다. 본문 전체나 관계 정보는 포함하지 않습니다.\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"게시글 고유 식별자(UUID). 예: '973c0116-ac2c-4ffb-b38b-7c4c45c7b2df'\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"작성자(user)의 ID(UUID)\"\n          },\n          \"category_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"속한 카테고리의 ID(UUID)\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"게시글 제목\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"게시글 작성일시(ISO8601)\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"게시글 마지막 수정 시각(ISO8601)\"\n          },\n          \"comment_count\": {\n            \"type\": \"integer\",\n            \"description\": \"해당 글의 댓글 개수\"\n          },\n          \"vote_count\": {\n            \"type\": \"integer\",\n            \"description\": \"해당 글의 추천(투표) 합계\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"category_id\",\n          \"title\",\n          \"created_at\",\n          \"updated_at\",\n          \"comment_count\",\n          \"vote_count\"\n        ]\n      },\n      \"IUser.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"page\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Page number for user list pagination. Optional field, aligns with standard best practices for paginated APIs.\\n\\nUsed to retrieve a specific page of user data. Default follows the IPage IRequest definition.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Number of users per page (for pagination). Optional, defaults to 100 if unspecified as per IPage specification.\\n\\nRestricts how many user records are returned in each page.\"\n          },\n          \"role\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Filter by user role (user_roles.id) to return users with a specific role (e.g., member, moderator, administrator).\\n\\nHelps admins/moderators filter and locate users of a particular type or permission set.\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Filter users by account status (e.g., 'active', 'suspended', 'banned').\\n\\nEnables moderation and administrative user management by quickly finding users in specific states.\"\n          },\n          \"search\": {\n            \"type\": \"string\",\n            \"description\": \"Search string, matches username or email in user list queries.\\n\\nSupports quick filtering of users when searching by identifying fields; case-insensitive partial match.\"\n          }\n        },\n        \"description\": \"User list request/filter parameters, supporting pagination, search, and filtering by role or status.\\n\\nImplements board requirements around user management and moderation. Based on database and business rules from Core.users and relevant API operation specs.\",\n        \"required\": []\n      },\n      \"IUser.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"User's unique identifier (UUID).\\n\\nReferenced from users.id in the database, required for user profile lookups.\"\n          },\n          \"username\": {\n            \"type\": \"string\",\n            \"description\": \"Public username (displayed in the board and visible to all users).\\n\\nUnique and required; serves as the user's main identifier for discussions, voting, and moderation.\"\n          },\n          \"bio\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Optional user biography; a short self-description or interests section.\\n\\nMay be empty; helps other members know basic info about the user.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Optional user biography; a short self-description or interests section.\\n\\nMay be empty; helps other members know basic info about the user.\"\n          },\n          \"role\": {\n            \"$ref\": \"#/components/schemas/IUserRole.ISummary\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Current user account status (e.g., 'active', 'suspended', 'banned').\\n\\nReflects moderation, login eligibility, and enforcement of platform rules.\"\n          }\n        },\n        \"description\": \"Concise user summary as returned in user listing responses. Hides sensitive fields.\\n\\nIncludes only public profile, role summary, and status info. Used in paginated user lists and admin/member lookup features.\",\n        \"required\": [\n          \"id\",\n          \"username\",\n          \"role\",\n          \"status\"\n        ]\n      },\n      \"IUserRole.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for user role (user_roles.id field).\\n\\nEnforces referential integrity for permission assignments.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"Short label name for the user role (e.g., 'member', 'moderator', 'administrator').\\n\\nUsed in dropdowns, labels, admin tools. Required and unique per database schema.\"\n          }\n        },\n        \"description\": \"Summary/view version of a user role entity. Contains only essential fields (id, name).\\n\\nUsed for responses where full details are unnecessary but reference is required.\",\n        \"required\": [\n          \"id\",\n          \"name\"\n        ]\n      },\n      \"IPageIUser.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IUser.ISummary\"\n            },\n            \"description\": \"Paginated list of user summaries matching request filters.\"\n          }\n        },\n        \"description\": \"Paginated user summary list container.\\n\\nStandardized IPage<T> wrapper for user listings, as per business requirements.\",\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ]\n      },\n      \"IUser\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique internal user ID (users.id). Used system-wide to link all user objects, references, and foreign keys.\\n\\nRequired; generated upon account creation and immutable.\"\n          },\n          \"user_role_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Foreign key to user_roles.id; denotes the active permission set (member, moderator, admin, etc).\\n\\nRequired at creation; determines access, moderation, and board capabilities.\"\n          },\n          \"username\": {\n            \"type\": \"string\",\n            \"description\": \"Unique public display name; visible to all, and referenced in discussion, voting, and moderation.\\n\\nDatabase-enforced as unique.\"\n          },\n          \"email\": {\n            \"type\": \"string\",\n            \"format\": \"email\",\n            \"description\": \"User's email address. Used for login and communication.\\n\\nNever displayed publicly. Must be unique.\"\n          },\n          \"bio\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Free-form user biography/self-description.\\n\\nOptional, enhances social context on the board.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Free-form user biography/self-description.\\n\\nOptional, enhances social context on the board.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Account creation datetime (with timezone). Used for auditing, ordering, and admin reporting.\\n\\nImmutable.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Most recent profile update timestamp for this user.\\n\\nUpdated whenever profile fields are changed.\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Current account status (active, suspended, banned, etc.).\\n\\nEnforced per moderation/business rule policies.\"\n          },\n          \"role\": {\n            \"$ref\": \"#/components/schemas/IUserRole\"\n          },\n          \"posts\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IPost.ISummary\"\n            },\n            \"description\": \"Array of summaries for posts authored by the user (board threads or articles).\"\n          },\n          \"comments\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IComment.ISummary\"\n            },\n            \"description\": \"List of summaries for comments made by this user.\"\n          },\n          \"votes\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IVote.ISummary\"\n            },\n            \"description\": \"Summary array of votes cast by the user on posts/comments.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_role_id\",\n          \"username\",\n          \"email\",\n          \"created_at\",\n          \"updated_at\",\n          \"status\",\n          \"role\"\n        ],\n        \"description\": \"Full user entity, as per users Prisma schema. Contains all non-confidential account info and relations.\\n\\nDetailed per-table and per-field documentation referenced from schema. Represents user profiles for detail pages and admin/mod tools.\"\n      },\n      \"IUser.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"user_role_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Role assignment for new user; must match user_roles.id. Required at registration. E.g., 'member', 'moderator', or 'administrator'.\"\n          },\n          \"username\": {\n            \"type\": \"string\",\n            \"description\": \"New user's unique public display name. Required, must be unique, visible on the board.\"\n          },\n          \"email\": {\n            \"type\": \"string\",\n            \"format\": \"email\",\n            \"description\": \"New user's email address. Required for registration, must be unique, never public.\"\n          },\n          \"bio\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Optional user bio/about section. May be empty upon registration.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Optional user bio/about section. May be empty upon registration.\"\n          },\n          \"password\": {\n            \"type\": \"string\",\n            \"description\": \"User password, plain text at registration. Required; will be securely hashed before storage. Never returned by API.\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Initial status for user: normally 'active', but admin can specify e.g., 'pending', 'suspended'.\"\n          }\n        },\n        \"required\": [\n          \"user_role_id\",\n          \"username\",\n          \"email\",\n          \"password\",\n          \"status\"\n        ],\n        \"description\": \"Request body schema for new user registration/account creation.\\n\\nAll required/optional fields per users model. Password is accepted as clear text but is hashed internally.\"\n      },\n      \"IUser.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"user_role_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"(Optional) Role update for user. Admin/moderator action only. Must match an existing user_roles.id.\"\n          },\n          \"username\": {\n            \"type\": \"string\",\n            \"description\": \"(Optional) Update to user's public display name. Must be unique if updated.\"\n          },\n          \"email\": {\n            \"type\": \"string\",\n            \"format\": \"email\",\n            \"description\": \"(Optional) Update to user's email address. Uniqueness required if changed.\"\n          },\n          \"bio\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"(Optional) Update to bio/about me field.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"(Optional) Update to bio/about me field.\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"(Optional) Modify user account status (active, suspended, etc.).\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Update timestamp; automatically set by the server on update.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Request body for updating an existing user profile/account.\\n\\nOnly fields supplied are updated; all are optional. Password change is NOT handled here.\"\n      },\n      \"IUser.IDeleteResponse\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of user deleted or marked for deletion. Used for reference in audit trails and deletion confirmations.\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Status message (e.g., 'deleted', 'suspended', etc.) after deletion/disable action.\"\n          }\n        },\n        \"description\": \"Response for user deletion operation. Contains minimal identifying and audit info.\\n\\nDoes not reveal sensitive user fields.\",\n        \"required\": []\n      },\n      \"IUserRole.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"page\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Page number for role list pagination. Optional; aligns with IPage best-practice.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Pagination limit for number of roles per page. Defaults to 100 if missing.\\n\\nStandard for IPage APIs.\"\n          },\n          \"search\": {\n            \"type\": \"string\",\n            \"description\": \"Keyword filter for role name or description fields. Enables quick role lookup.\"\n          }\n        },\n        \"description\": \"List/request filtering schema for user roles table.\\n\\nSupports pagination, keyword search for role management dashboards, registration, and editor widgets.\",\n        \"required\": []\n      },\n      \"IPageIUserRole\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IUserRole\"\n            },\n            \"description\": \"Array of role entities for administrative/user assignment purposes.\"\n          }\n        },\n        \"description\": \"Paginated wrapper of user roles, for admin lookup and registration dropdowns.\\n\\nImplements standard IPage format with list of IUserRole.\",\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ]\n      },\n      \"IUserRole\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique ID for this user role entry.\\n\\nPrimary key in user_roles. Required for all entity referencing (assignment, lookup, etc.).\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"Machine- and human-readable name for the user role, e.g., 'member', 'moderator', or 'administrator'.\\n\\nMust be unique, and required for referential integrity.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"Human explanation of what privileges and duties this role holds.\\n\\nAids in assigning and documenting permissions for users. Required for compliance with admin/business rule traceability.\"\n          },\n          \"users\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IUser.ISummary\"\n            },\n            \"description\": \"(For reference/audit) Array of users holding this role. May be omitted if not required at runtime.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"name\",\n          \"description\"\n        ],\n        \"description\": \"Full user role entity, as per user_roles Prisma model. Details all privilege/permission details, assignment context, and required unique properties.\"\n      },\n      \"IUserRole.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"Unique name for new role; will become user_roles.name. E.g., 'moderator', 'editor', or custom label.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"Text description covering what the role enables/limits for users assigned to it.\"\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"description\"\n        ],\n        \"description\": \"Request schema for creating new user roles.\\n\\nAllows admin tools to set up new permissions/policies in the board, with full business rule auditing.\"\n      },\n      \"IUserRole.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"(Optional) New/updated role name. Must remain unique if updated.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"(Optional) Update/extend role meaning or allowed actions.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Request schema for editing an existing user role entry.\\n\\nAll fields optional; only modified fields must be sent.\"\n      },\n      \"IUserRole.IDeleteResponse\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of user role entry deleted or marked deleted. For audit and post-delete reference.\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Delete or audit status: e.g., 'deleted', 'archived', 'in use - not deleted'.\"\n          }\n        },\n        \"description\": \"Response schema for confirming user role deletion (admin-only).\\n\\nIncludes minimal info required for audit logs and error/success reporting.\",\n        \"required\": []\n      },\n      \"IPage.IPagination\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"current\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Current page number.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Limitation of records per a page. Default: 100.\"\n          },\n          \"records\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Total records in the database.\"\n          },\n          \"pages\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Total number of pages (records/limit, ceiled).\"\n          }\n        },\n        \"required\": [\n          \"current\",\n          \"limit\",\n          \"records\",\n          \"pages\"\n        ],\n        \"description\": \"Pagination metadata for paged responses, including current/limit/total/pageCount as per business requirements and search usability.\"\n      },\n      \"ICategory.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"필터링 또는 검색을 위한 카테고리 이름입니다.\\n\\n예: '정치', '경제'\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"카테고리 설명의 검색을 위한 옵션 필드입니다.\\n\\n예: '정치 체계와 관련된 논의', '국제 경제 토론'\"\n          },\n          \"created_from\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"검색 시작일자(ISO8601 형식). 예: '2024-06-09T00:00:00+09:00'.\"\n          },\n          \"created_to\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"검색 종료일자(ISO8601 형식). 예: '2024-07-09T23:59:59+09:00'.\"\n          },\n          \"page\": {\n            \"type\": \"integer\",\n            \"description\": \"페이지 번호(1부터 시작).\",\n            \"minimum\": 1\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"description\": \"페이지당 반환할 레코드 수(기본값 100).\",\n            \"minimum\": 1\n          }\n        },\n        \"description\": \"카테고리 리스트/검색 요청에 이용되는 필터, 검색, 페이징 정보 객체입니다.\\n\\n카테고리 명, 설명, 기간 필터, 페이징 조작(페이지, limit) 등 검색 옵션을 다루며, 관리자 또는 일반 사용자의 카테고리 목록 검색 시 활용됩니다.\",\n        \"required\": [\n          \"page\",\n          \"limit\"\n        ]\n      },\n      \"IPageICategory\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"description\": \"페이지네이션 정보로, 현재 페이지, 전체 레코드 수, 전체 페이지 수 등을 제공합니다.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/ICategory\"\n            },\n            \"description\": \"카테고리 목록 데이터 배열입니다.\"\n          }\n        },\n        \"description\": \"카테고리 검색/조회 결과를 담는 페이지 컨테이너 타입입니다.\\n\\n페이지네이션 메타데이터와 함께 실제 데이터 목록(카테고리 배열)을 포함해, 목록 화면 및 검색 결과에서 활용합니다.\",\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ]\n      },\n      \"ICategory\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"카테고리의 고유 식별자(UUID).\\n\\nPrisma 'categories.id' 컬럼. 예: 'b4682df2-b264-4e1b-807d-381340390a64'.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"카테고리 이름(고유).\\n\\nPrisma 'categories.name' 컬럼. 예: '정치', '경제'\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"카테고리 상세 설명.\\n\\nPrisma 'categories.description' 컬럼. 예: '정치 제도와 관련된 모든 주제를 다룹니다.'\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"카테고리 생성 일시(ISO8601).\\n\\nPrisma 'categories.created_at' 컬럼. 예: '2024-06-09T09:00:00+09:00'.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"name\",\n          \"description\",\n          \"created_at\"\n        ],\n        \"description\": \"토론 게시판의 주제분류(카테고리) 정보를 담는 엔터티입니다.\\n\\n각 카테고리는 고유명, 설명, 생성일시 필드를 가지며 게시글(Posts)과 1:N 관계입니다. 관리자가 생성·관리하며, 게시글 작성 시 반드시 할당해야 하는 구조입니다.\"\n      },\n      \"ICategory.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"신규 카테고리의 이름(고유). 예: '시사', '국제'.\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"카테고리 상세 설명. 예: '글로벌 경제 및 정치 이슈를 다루는 공간입니다.'\"\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"description\"\n        ],\n        \"description\": \"카테고리 신규 생성시 전달하는 요청 바디 객체입니다.\\n\\n이름(고유), 설명을 필수로 제공해야 하며, 관리자가 카테고리를 추가할 때 활용됩니다.\"\n      },\n      \"ICategory.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"변경할 카테고리명(옵션). 예: '사회'\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"변경할 카테고리 설명(옵션).\"\n          }\n        },\n        \"description\": \"기존 카테고리의 이름·설명을 수정하는 요청 바디입니다.\\n\\n두 필드 모두 선택적이며, 하나 또는 모두 변경할 수 있습니다.\",\n        \"required\": []\n      },\n      \"ICategory.IDeleteResult\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"success\": {\n            \"type\": \"boolean\",\n            \"description\": \"삭제 성공 여부. true 이면 정상 삭제, false 이면 오류.\"\n          },\n          \"message\": {\n            \"type\": \"string\",\n            \"description\": \"삭제 결과 메시지(실패 이유, 성공 안내 등).\"\n          }\n        },\n        \"required\": [\n          \"success\",\n          \"message\"\n        ],\n        \"description\": \"카테고리 삭제(soft/hard delete) 결과를 나타내는 오브젝트입니다.\\n\\n성공/실패의 플래그 및 설명 메시지를 포함해 후처리 사용자 안내에 활용합니다.\"\n      },\n      \"IPost.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"category_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"검색/필터링용 카테고리 ID.\\n\\n특정 카테고리 내 게시글만 조회하고자 할 때 사용합니다.\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"검색/필터링용 작성자(유저) ID.\\n\\n특정 사용자가 작성한 게시글만 조회할 때 활용합니다.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"제목 키워드 검색 (부분 일치 허용).\\n\\n게시글의 제목에 포함된 키워드로 검색합니다.\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"본문 키워드 검색 (부분 일치 허용).\\n\\n게시글의 전체 텍스트에서 키워드로 검색합니다.\"\n          },\n          \"created_from\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"게시글 생성 시작일(검색 필터용, ISO8601).\"\n          },\n          \"created_to\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"게시글 생성 종료일(검색 필터용, ISO8601).\"\n          },\n          \"page\": {\n            \"type\": \"integer\",\n            \"description\": \"페이지 번호(1 이상).\",\n            \"minimum\": 1\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"description\": \"페이지당 데이터 수(기본 100).\",\n            \"minimum\": 1\n          }\n        },\n        \"description\": \"게시글 검색, 필터, 페이징에 요청 정보로 사용되는 객체입니다.\\n\\n카테고리, 작성자, 키워드, 기간, 페이징 등 다양한 필터를 지원하여 게시글 탐색 UX를 구현합니다.\",\n        \"required\": [\n          \"page\",\n          \"limit\"\n        ]\n      },\n      \"IPageIPost\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"description\": \"페이지네이션 메타데이터\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IPost\"\n            },\n            \"description\": \"검색 결과 게시글(Posts) 배열\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"게시글 검색/조회 결과를 담는 페이지 컨테이너 타입입니다.\\n\\n페이지 정보와 게시글 배열을 함께 반환하여 결과 화면에서 활용합니다.\"\n      },\n      \"IPost\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"게시글의 고유 ID (Prisma 'posts.id').\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"작성자(유저) ID (Prisma 'posts.user_id').\"\n          },\n          \"category_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"카테고리 ID (Prisma 'posts.category_id').\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"게시글 제목 (Prisma 'posts.title').\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"게시글 본문 (Prisma 'posts.content').\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"생성 시각 (Prisma 'posts.created_at').\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"수정 시각 (Prisma 'posts.updated_at').\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"삭제(soft delete) 시각(Prisma 'posts.deleted_at'). 삭제 안된 경우 null.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"삭제(soft delete) 시각(Prisma 'posts.deleted_at'). 삭제 안된 경우 null.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"category_id\",\n          \"title\",\n          \"content\",\n          \"created_at\",\n          \"updated_at\"\n        ],\n        \"description\": \"토론 게시판의 게시글(포스트) 정보를 담는 도메인 오브젝트입니다.\\n\\n작성자, 카테고리, 제목·본문, 생성/수정/삭제일 등을 보유하여 커뮤니티 핵심 콘텐츠 구조를 이룹니다.\"\n      },\n      \"IPost.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"category_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"작성할 게시글의 카테고리 ID. (필수)\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"게시글 제목. 예: '2025년 물가·인플레이션 전망'\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"게시글 본문 내용. (텍스트·포맷팅 지원)\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"작성자(Author) ID. 회원 작성 시 필수\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"생성시각 (시스템 자동 할당이지만, 조직 배치용으로도 허용될 수 있음)\"\n          }\n        },\n        \"required\": [\n          \"category_id\",\n          \"title\",\n          \"content\",\n          \"user_id\"\n        ],\n        \"description\": \"게시글 신규 작성 요청에 전달되는 바디입니다.\\n\\n카테고리, 제목, 본문, 작성자 정보를 반드시 포함해야 합니다. 생성일시 등은 서버에서 자동 처리합니다.\"\n      },\n      \"IPost.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"변경할 게시글 제목 (옵션)\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"변경할 게시글 본문 (옵션)\"\n          },\n          \"category_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"변경할 카테고리 ID (옵션)\"\n          }\n        },\n        \"description\": \"기존 게시글(포스트)의 제목/본문/카테고리를 수정하는 요청 바디입니다.\\n\\n각 필드는 선택값으로, 일부만 수정 가능하며 누락시 기존 값 유지합니다.\",\n        \"required\": []\n      },\n      \"IPost.IDeleteResult\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"success\": {\n            \"type\": \"boolean\",\n            \"description\": \"삭제(Soft 또는 Hard) 성공 여부\"\n          },\n          \"message\": {\n            \"type\": \"string\",\n            \"description\": \"삭제 결과 메시지\"\n          }\n        },\n        \"required\": [\n          \"success\",\n          \"message\"\n        ],\n        \"description\": \"게시글 삭제(soft/hard) 요청 결과나 상태를 반환하는 결과 객체입니다.\\n\\n정상 삭제(숨김) 시 success=true, 실패 시 false와 설명 메시지를 제공합니다.\"\n      },\n      \"IComment.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"postId\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"The unique ID of the target post to which comments should be filtered.\\n\\nBased on the comments table, 'post_id' field links the comment to a particular post for thread-based filtering. Sourced from the business rule: 'Each Comment is linked to a Post.'\"\n          },\n          \"userId\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"The unique ID of the user who authored comments.\\n\\nDesigned for filtering comments made by a specific user, as referenced in the comments.user_id column.\"\n          },\n          \"parentId\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"The parent comment's ID, for retrieving or searching nested replies.\\n\\nThis relates to the self-referential thread system: filtering for replies to a specific comment.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"The parent comment's ID, for retrieving or searching nested replies.\\n\\nThis relates to the self-referential thread system: filtering for replies to a specific comment.\"\n          },\n          \"search\": {\n            \"type\": \"string\",\n            \"description\": \"A keyword or phrase to search in comment content.\\n\\nImplements full-text search capability as referenced in content field and API description.\"\n          },\n          \"offset\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"default\": 0,\n            \"description\": \"The starting index for pagination.\\n\\nAllows skipping records in list pagination, supporting usability in large thread navigation.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"default\": 20,\n            \"description\": \"Maximum number of records to return per page. Defaults to 20 if not specified.\"\n          },\n          \"sort\": {\n            \"type\": \"string\",\n            \"description\": \"Sorting order or field, e.g., 'created_at:desc', 'created_at:asc'.\\n\\nAligns with thread listing sorting as described in business and API requirements.\"\n          }\n        },\n        \"description\": \"Defines filtering, pagination, and sorting criteria for retrieving comments. Fields draw directly from the requirements and Prisma comments model.\\n\\nThis allows filtering by comments made on a post, by a user, or as replies to a parent, along with keyword search and pagination. Reflects full API and business use cases for comment listing endpoints.\",\n        \"required\": []\n      },\n      \"IPageIComment\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IComment.ISummary\"\n            },\n            \"description\": \"A list of comment summary objects on the current page.\\n\\nEach item is a concise representation of a comment as described in business use-cases: post/reply thread listings.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A paginated list of comment summaries, including pagination metadata (page, limit, total, etc.) and a summary array.\\n\\nCombines IPage (standard) with IComment.ISummary as required by comment browsing scenarios.\"\n      },\n      \"IComment\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Primary Key. Unique identifier for each comment (see comments.id in schema).\\n\\nAssigned at creation; required for retrieval, update, and reference by other entities (votes, replies).\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Author's {@link users.id}.\\n\\nStores the user's unique identifier responsible for the comment, using the relationship to users. Enables auditing, author lookup, and permissions checks.\"\n          },\n          \"post_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"The ID of the post this comment is attached to ({@link posts.id}).\\n\\nCrucial for associating the comment as a reply to a given post, reflecting business rules and ERD documentation.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Parent comment's {@link comments.id}.\\n\\nUsed for nested (threaded) replies. Null for top-level comments. Enables tree-based conversations.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Parent comment's {@link comments.id}.\\n\\nUsed for nested (threaded) replies. Null for top-level comments. Enables tree-based conversations.\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"Main text of the comment; user-provided reply content.\\n\\nReferences the comments.content field; holds message body visible to users.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp when the comment was first authored (see comments.created_at).\\n\\nUsed for chronological ordering, moderation, and audit.\"\n          },\n          \"updated_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp of last edit to the comment (see comments.updated_at).\\n\\nEnables edit history, moderation, or user accountability.\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Soft deletion timestamp (see comments.deleted_at).\\n\\nNull if not deleted; otherwise contains date/time when marked deleted for moderation/auditing.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Soft deletion timestamp (see comments.deleted_at).\\n\\nNull if not deleted; otherwise contains date/time when marked deleted for moderation/auditing.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"post_id\",\n          \"content\",\n          \"created_at\",\n          \"updated_at\"\n        ],\n        \"description\": \"Represents a Comment record, as per the Posts domain comments model and requirements analysis.\\n\\nIncludes all primary properties as described in the Prisma schema, with full typing and references to related entities (users, posts, parent comments). Supports auditability, moderation, and business logic for threaded conversations.\"\n      },\n      \"IComment.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"User ID (author's identifier). Must reference an existing user. Required to ensure only registered users may comment.\\n\\nFulfills business rule that only registered users can create comments.\"\n          },\n          \"post_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of the post this comment is on. Implements business rule requiring every comment to be attached to a post.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Parent comment's ID for nested replies. Optional. Enables thread hierarchy as in the business requirements.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Parent comment's ID for nested replies. Optional. Enables thread hierarchy as in the business requirements.\"\n          },\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"Main comment body text. Required; validated for length and content rules by business logic.\"\n          }\n        },\n        \"required\": [\n          \"user_id\",\n          \"post_id\",\n          \"content\"\n        ],\n        \"description\": \"Object for creating a new comment. Includes required properties for new replies, including references to post, author, and optionally a parent for nested threading. Matches business rules requiring each comment to have an associated user (author) and post, plus the option to nest under another comment.\"\n      },\n      \"IComment.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"content\": {\n            \"type\": \"string\",\n            \"description\": \"New comment body, if editing. Must meet length/content requirements from business logic.\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Timestamp for marking a comment as deleted (for moderation/audit). Set to current time for 'soft delete,' or null to un-delete if allowed.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Timestamp for marking a comment as deleted (for moderation/audit). Set to current time for 'soft delete,' or null to un-delete if allowed.\"\n          }\n        },\n        \"description\": \"Object for updating an existing comment (edit or soft-delete). User or moderator may use this to change content or to mark the comment as deleted.\\n\\nReferences the comments Prisma model and moderation business rules: only content or soft-delete flag is usually editable.\",\n        \"required\": []\n      },\n      \"IComment.IDeleteResult\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of the comment that was deleted.\"\n          },\n          \"deleted\": {\n            \"type\": \"boolean\",\n            \"description\": \"Status: true if successfully deleted (soft or hard as per policy), false otherwise.\"\n          },\n          \"message\": {\n            \"type\": \"string\",\n            \"description\": \"A confirmation or informative message about the deletion result.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"deleted\"\n        ],\n        \"description\": \"Result object for delete operations on comments. Confirms deletion (soft or hard), as required by business rules and audit requirements. Returns the comment ID, deletion status, and optional human-readable message.\"\n      },\n      \"IVote.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"userId\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier of the user who cast the vote. Used for filtering votes by a specific voter (see votes.user_id in schema and ERD).\"\n          },\n          \"postId\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Unique identifier of the post that received the vote (see votes.post_id). Mutually exclusive with commentId.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Unique identifier of the post that received the vote (see votes.post_id). Mutually exclusive with commentId.\"\n          },\n          \"commentId\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Unique identifier of the comment that received the vote (see votes.comment_id). Mutually exclusive with postId.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Unique identifier of the comment that received the vote (see votes.comment_id). Mutually exclusive with postId.\"\n          },\n          \"offset\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"default\": 0,\n            \"description\": \"Starting index for pagination (default 0).\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"default\": 20,\n            \"description\": \"Maximum number of records to return per page.\"\n          },\n          \"sort\": {\n            \"type\": \"string\",\n            \"description\": \"Sorting field or order (default 'created_at:desc').\"\n          }\n        },\n        \"description\": \"Filtering, pagination, and sorting criteria for votes listing requests, following the votes table business logic and related requirements.\\n\\nFilters support querying by voter, target post, or comment, with support for pagination and sorting. Business rules enforce only mutual exclusivity between postId/commentId (never both set).\",\n        \"required\": []\n      },\n      \"IPageIVote\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IVote.ISummary\"\n            },\n            \"description\": \"Array of vote summary records on this page.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"A paginated set of votes, as used in vote listing, audit history, or analytics use-cases. Follows IPage pattern with IVote.ISummary records per voting business and DB design.\"\n      },\n      \"IVote\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Primary Key. Unique identifier for each vote record (votes.id).\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"The ID of the user casting the vote (votes.user_id), referencing users table for author.\"\n          },\n          \"post_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"The voted post's ID (votes.post_id). Mutually exclusive with comment_id.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"The voted post's ID (votes.post_id). Mutually exclusive with comment_id.\"\n          },\n          \"comment_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"The voted comment's ID (votes.comment_id). Mutually exclusive with post_id.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"The voted comment's ID (votes.comment_id). Mutually exclusive with post_id.\"\n          },\n          \"value\": {\n            \"type\": \"integer\",\n            \"description\": \"Value of the vote (+1 for upvote, -1 for downvote). Aggregated to compute content rankings.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp of when the vote was created (votes.created_at).\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"value\",\n          \"created_at\"\n        ],\n        \"description\": \"Represents a Vote as defined in the votes table: one record for each upvote/downvote action on a post or comment. Covers voter ID, target (post or comment), value (+1/-1), and creation timestamp. Fully aligned with requirements analysis and business logic for single-vote-per-user-per-content.\"\n      },\n      \"IVote.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of the user casting the vote. References the users table; ensures only registered users can vote.\"\n          },\n          \"value\": {\n            \"type\": \"integer\",\n            \"description\": \"Vote value: +1 or -1 as per business requirements. Used for up/down voting of posts/comments.\"\n          },\n          \"post_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Target post's ID, if voting on a post. Mutually exclusive with comment_id.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Target post's ID, if voting on a post. Mutually exclusive with comment_id.\"\n          },\n          \"comment_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Target comment's ID, if voting on a comment. Mutually exclusive with post_id.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Target comment's ID, if voting on a comment. Mutually exclusive with post_id.\"\n          }\n        },\n        \"required\": [\n          \"user_id\",\n          \"value\"\n        ],\n        \"description\": \"Object for creating a new vote as per voting business rules:\\n- user_id: registered voter\\n- value: +1 (upvote) or -1 (downvote)\\n- target: must specify either post_id or comment_id (never both)\\nEnforces one vote per user/content as described in requirements.\"\n      },\n      \"IVote.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"value\": {\n            \"type\": \"integer\",\n            \"description\": \"The new vote value. Allows changing an upvote to downvote (or vice versa), strictly for existing votes per business rules.\"\n          }\n        },\n        \"required\": [\n          \"value\"\n        ],\n        \"description\": \"Object for updating existing votes, specifically editing the vote value (from +1 to -1, etc.).\\n\\nDoes not allow changing the vote target (post_id/comment_id); supports audit and business logic for corrections.\"\n      },\n      \"IVote.IDeleteResult\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of the vote record that was deleted.\"\n          },\n          \"deleted\": {\n            \"type\": \"boolean\",\n            \"description\": \"Indicates if the vote was successfully deleted.\"\n          },\n          \"message\": {\n            \"type\": \"string\",\n            \"description\": \"A human-readable confirmation message about the delete operation.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"deleted\"\n        ],\n        \"description\": \"Delete operation result for a vote record. Returns deleted vote's ID, deletion status, and optional result message, as required by business logic and for user/admin confirmation.\"\n      },\n      \"IComment.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the comment.\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"User (author) of the comment.\"\n          },\n          \"post_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Parent post for the comment.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Parent comment (if any).\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Parent comment (if any).\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp of comment creation.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"post_id\",\n          \"created_at\"\n        ],\n        \"description\": \"A concise summary type for comments, covering the most important references and metadata for paginated or overview lists.\"\n      },\n      \"IVote.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the vote.\"\n          },\n          \"user_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Voter's user ID.\"\n          },\n          \"post_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Target post.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Target post.\"\n          },\n          \"comment_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Target comment.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Target comment.\"\n          },\n          \"value\": {\n            \"type\": \"integer\",\n            \"description\": \"Vote value (+1 or -1).\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"user_id\",\n          \"value\"\n        ],\n        \"description\": \"Summary of a Vote for paginated/result lists, not including creation date but identifying all main relationships and value.\"\n      }\n    }\n  },\n  \"x-samchon-emended-v4\": true\n}"
    },
    "reason": "The requirements analysis and simple database schema for the political/economic discussion board are completed. Now, generate the API interface specification, including OpenAPI and basic DTOs, reflecting essential features such as user authentication, posting, and commenting in an easy-to-understand format.",
    "step": 0,
    "created_at": "2025-06-09T05:54:30.876Z",
    "completed_at": "2025-06-09T05:57:38.849Z"
  }
]